<link rel="import" href="annotations.html">

<script>

  /*
   * Parses the annotations map created by `annotations` features to perform
   * declarative desugaring.
   * 
   * Depends on `annotations` feature and `bind` feature.
   * 
   * Two tasks are supported:
   * 
   * - nodes with 'id' are described in a virtual annotation map at 
   *   registration time. This map is then concretized per instance.
   * 
   * - Simple mustache expressions consisting of a single property name
   *   in a `textContent` context are bound using `bind` features
   *   `bindMethod`. In this mode, the bound method is constructed at
   *   registration time, so marshaling is done done via the concretized 
   *   `_nodes` at every access.
   *    
   *   TODO(sjmiles): ph3ar general confusion between registration and 
   *   instance time tasks. Is there a cleaner way to disambiguate? 
   */
  Base.addFeature({

    register: function(prototype) {
      if (prototype._template && prototype._template.map) {
        this.preprocessBindAnnotations(prototype, prototype._template.map);
      }
    },

    // construct binding meta-data at *registration* time
    preprocessBindAnnotations: function(prototype, map) {
      // create a virtual annotation map, must be concretized at instance time 
      prototype._nodes = [];
      // process annotations that have been parsed from template
      map.forEach(function(annotation) {
        // where to find the node in the concretized map 
        var index = this._nodes.push(annotation) - 1;
        // TODO(sjmiles): we probably need to multiplex the bind method
        // to handle multiple binding targets, right now you
        // only get one
        var binding = annotation.bindings[0];
        // TODO(sjmiles): this is property binding only, but 
        // bind-annotations produces other kinds of annotations,
        // impedence mismatch borne of mutating the project from earlier
        // versions. 
        if (binding.kind === 'text') {
          // TODO(sjmiles): not using `bind` feature code because this is 
          // a slightly different use case. IOW, we want a combination of 
          // `bindProperty` and `bindMethod`. Consider how to unify.
          this.bindAnnotation(binding.value, index);
        }
      }, prototype);
    },

    // TODO(sjmiles): this method is absurdly specialized
    bindAnnotation: function(property, index) {
      // TODO(sjmiles): _bound is ad hoc
      this._bound.push(property);
      Object.defineProperty(this, property, {
        set: function(value) {
          this._nodes[index].textContent = value;
        },
        get: function() {
          return this._nodes[index].textContent;
        }
      });
    },

    // concretize `_nodes` map at *instance* time
    marshalBoundNodes: function() {
      if (this._nodes) {
        this._nodes = this._nodes.map(function(a) {
          return this.findAnnotatedNode(this.root, a);
        }, this);
      }
    }

  });

</script>
