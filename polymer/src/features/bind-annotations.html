<link rel="import" href="annotations.html">

<script>

  /*
   * Parses the annotations map created by `annotations` features to perform
   * declarative desugaring.
   * 
   * Depends on `annotations` feature and `bind` feature.
   * 
   * Two tasks are supported:
   * 
   * - nodes with 'id' are described in a virtual annotation map at 
   *   registration time. This map is then concretized per instance.
   * 
   * - Simple mustache expressions consisting of a single property name
   *   in a `textContent` context are bound using `bind` features
   *   `bindMethod`. In this mode, the bound method is constructed at
   *   registration time, so marshaling is done done via the concretized 
   *   `_nodes` at every access.
   *    
   *   TODO(sjmiles): ph3ar general confusion between registration and 
   *   instance time tasks. Is there a cleaner way to disambiguate? 
   */
  Base.addFeature({

    register: function(prototype) {
      if (prototype._template && prototype._template.map) {
        this.preprocessBindAnnotations(prototype, prototype._template.map);
      }
    },

    // construct binding meta-data at *registration* time
    preprocessBindAnnotations: function(prototype, map) {
      // create a virtual annotation map, must be concretized at instance time 
      prototype._nodes = [];
      // process annotations that have been parsed from template
      map.forEach(function(annotation) {
        // where to find the node in the concretized map 
        var index = this._nodes.push(annotation) - 1;
        // TODO(sjmiles): we need to support multi-bind, right now you only get 
        // one (not including kind === `id`)
        annotation.bindings.forEach(function(binding) {
          this.bindAnnotationBinding(binding, index);
        }, prototype);
      }, prototype);
    },

    bindAnnotationBinding: function(binding, index) {
      if (binding.kind === 'text') {
        // {{<property>}}
        this.bindAnnotationProperty(binding.value, 'textContent', index);
      } else if (binding.kind === 'attribute') {
        // <target>="{{<property>}}"
        this.bindAnnotationProperty(binding.value, binding.name, index);
      }     
    },

    // TODO(sjmiles): a special flavor of accessor separate from those
    // created by `bind` feature
    bindAnnotationProperty: function(property, target, index) {
      // TODO(sjmiles): _bound is ad hoc
      this._bound.push(property);
      Object.defineProperty(this, property, {
        set: function(value) {
          this._nodes[index][target] = value;
        },
        get: function() {
          return this._nodes[index][target];
        }
      });
    },

    // concretize `_nodes` map at *instance* time
    marshalBoundNodes: function() {
      if (this._nodes) {
        this._nodes = this._nodes.map(function(a) {
          return this.findAnnotatedNode(this.root, a);
        }, this);
      }
    }

  });

</script>
