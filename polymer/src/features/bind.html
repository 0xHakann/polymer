<script>

  /*
   * Needs new name.
   * 
   * Provides a data-binding API, by which a getter/setter pair
   * can be constructed in one of two imperative modes:
   * 
   * bindMethod(property, methodName): constructs a getter/setter pair and a 
   * backing store for the given property; calls the method when the setter
   * is invoked and the value has changed from what is in the backing store.
   * 
   * bindProperty(property, path): constructs a getter/setter pair that 
   * forwards data access to a property on another object.
   * 
   * This feature also supports a `bind` object, which contains expressions
   * that are deconstructed into `bindMethod` or `bindProperty` calls, or
   * into a `multiBinding` construct. `multiBinding` constructs support 
   * multiple side-effects.
   *
   * bind {
   *   // if `method` is the name of a method on the current object, a
   *   // `bindMethod` call is made to define `property` as described above.
   *   property: 'method'
   *   // if the value is not the name of a method, it's assumed to be the
   *   // name in the `$` hash that maps to an element.
   *   // If no target property is specified, `textContent` is assumed to 
   *   // be the backing-store for `property2` accessors.
   *   property2: 'elementId'
   *   // If a path is provided, that element is dereferenced from $ as before, 
   *   // but the full path is used for the backing-store.
   *   // This declaration binds property3 to $.elementId.value  
   *   property3: 'elementId.value'
   *   // If the specified property is also `published`, a multi-binding 
   *   // construct is created which sends a change notification in addition
   *   // to whatever user side-effect is specified. 
   *   publishedProperty: <method name or element property>
   *   // Specify multiple side-effects directly as an array. Only one
   *   // callback method is allowed.
   *   property4: [
   *     'nameOfMethod',
   *     'elementId',
   *     'elementId.property',
   *     ...
   *   ] 
   * } 
   * 
   * Methods bound into multi-bind contexts support a validation feature. If
   * the method returns a value that does not === undefined side-effects are
   * prevented, and the triggering property is set to the returned value, and
   * a new round of side-effects is initiated.
   * 
   * Multi-bind = multiple side-effects for one signal.
   * Note: `signal` today is `set-trap`, should we generalize?
   * Side-effects can be registered by multiple subsystems:
   *   - bind feature
   *   - bind-annotations feature
   *   - computed feature
   *   - published feature
   * We need to accumulate all side-effects for a particular property 
   * before constructing the handler.
   * 
   */
  Base.addFeature({

    // per prototype
    
    // TODO(sjmiles): initialization of `_propertyEffects` and the
    // `addPropertyEffect` itself are really the domain of bind-effects
    // but these things needs to happen before bind-effects itself initializes.
    // We need to factor bind-effects into before and after features instead
    // and let this feature be for dealing with `bind` object.
    
    register: function(prototype) {
      prototype._propertyEffects = {};
      prototype._addPropertyBindEffects();
    },

    addPropertyEffect: function(property, kind, effect) {
      var fx = this._propertyEffects[property];
      if (!fx) {
        fx = this._propertyEffects[property] = [];
      }
      fx.push({
        kind: kind,
        effect: effect
      });
    },

    _addPropertyBindEffects: function() {
      for (var n in this.bind) {
        var bind = this.bind[n];
        if (typeof bind === 'object') {
          // multiplexed definition
          for (var nn in bind) {
            this._addPropertyBindEffect(n, bind[nn]);
          }
        } else {
          // single definition
          this._addPropertyBindEffect(n, bind);
        }
      }
    },

    _addPropertyBindEffect: function(property, bindEffect) {
      this.addPropertyEffect(property, 'bind', bindEffect);
    }

  });

</script>