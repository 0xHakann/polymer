<script>

  /*
   * Needs new name.
   * 
   * Provides a data-binding API, by which a getter/setter pair
   * can be constructed in one of two imperative modes:
   * 
   * bindMethod(property, methodName): constructs a getter/setter pair and a 
   * backing store for the given property; calls the method when the setter
   * is invoked and the value has changed from what is in the backing store.
   * 
   * bindProperty(property, path): constructs a getter/setter pair that 
   * forwards data access to a property on another object.
   * 
   * This feature also supports a `bind` object, which contains expressions
   * that are deconstructed into `bindMethod` or `bindProperty` calls, or
   * into a `multiBinding` construct. `multiBinding` constructs support 
   * multiple side-effects.
   *
   * bind {
   *   // if `method` is the name of a method on the current object, a
   *   // `bindMethod` call is made to define `property` as described above.
   *   property: 'method'
   *   // if the value is not the name of a method, it's assumed to be the
   *   // name in the `$` hash that maps to an element.
   *   // If no target property is specified, `textContent` is assumed to 
   *   // be the backing-store for `property2` accessors.
   *   property2: 'elementId'
   *   // If a path is provided, that element is dereferenced from $ as before, 
   *   // but the full path is used for the backing-store.
   *   // This declaration binds property3 to $.elementId.value  
   *   property3: 'elementId.value'
   *   // If the specified property is also `published`, a multi-binding 
   *   // construct is created which sends a change notification in addition
   *   // to whatever user side-effect is specified. 
   *   publishedProperty: <method name or element property>
   *   // Specify multiple side-effects directly as an array. Only one
   *   // callback method is allowed.
   *   property4: [
   *     'nameOfMethod',
   *     'elementId',
   *     'elementId.property',
   *     ...
   *   ] 
   * } 
   * 
   * Methods bound into multi-bind contexts support a validation feature. If
   * the method returns a value that does not === undefined side-effects are
   * prevented, and the triggering property is set to the returned value, and
   * a new round of side-effects is initiated.
   * 
   *
   */
  Base.addFeature({

    // per instance
    
    init: function() {
      this._privateData = Object.create(null);
    },

    _setupMultiBindListeners: function() {
      for (var n in this._multiData) {
        var data = this._multiData[n];
        data.targets.forEach(function(t) {
          this._setupMultiBindListener(n, t.id, t.property);
        }, this);
      }
    },

    _setupMultiBindListener: function(property, id, source) {
      var host = this;
      //console.log('[bind]: [%s][%s] listening for [%s][%s-changed]', this.localName, property, id, source);
      this.$[id].addEventListener(source + '-changed', function(e) {
        //console.log('[bind]:[%s] heard [%s-changed] this.[%s] = [%s]', host.localName, source, property, e.detail);
        host[property] = e.detail;
      });
    },

    // per prototype
    
    register: function(prototype) {
      // TODO(sjmiles): `_bound` is ad hoc name tracking for custom telemetry
      prototype._bound = [];
      prototype._multiData = Object.create(null);
      prototype.setupBindings();
    },

    setupBindings: function() {
      for (var n in this.bind) {
        this._bound.push(n);
        this.setupBinding(n, this.bind[n]);
      }
    },

    setupBinding: function(property, data) {
      // TODO(sjmiles): ad hoc integration with `attributes:publish` feature
      if (typeof data === 'object' || this.published[property]) {
        this._bindMulti(property, data);
      } else {
        var path = data, paths = path.split('.');
        if (paths.length === 1) {
          if (typeof this[path] === 'function') {
            this.bindMethod(property, path);
            return;
          }
          path += '.textContent';
        }
        this.bindProperty(property, 'this.$.' + path);
      }
    },

    // TODO(sjmiles): currently there is a fourth type of accessor pair
    // that is constructed via bind-annotations feature, unify.

    _bindMulti: function(property, data) {
      var callback, targets = [];
      // parse bind object
      // shove single string into an array for convenience
      if (typeof data === 'string') {
        data = [data];
      }
      // accumulate any side-effects (beyond nominal callback)
      var sideEffects = [];
      // targets are either sub-element properties or a highlander method-name
      for (var i=0, a; a=data[i]; i++) {
        // TODO(sjmiles): ad-hoc: support exactly one callback method
        if (a === null || typeof this[a] === 'function') {
          callback = a;
        } else {
          // otherwise parse target data
          var t = this._createMultiBindTarget(property, a);
          // store target data
          targets.push(t);
          // accumulate effects
          sideEffects.push(t.effect);
        }
      }
      // create side-effect executor
      var sideEffectFn = sideEffects.length ? 
        new Function('value', sideEffects.join('\n')) : null;
      // desugared bind data
      var data = {
        callback: callback,
        targets: targets,
        sideEffectFn: sideEffectFn,
        published: Boolean(this.published[property])
      };
      // create accessors
      Object.defineProperty(this, property, {
        set: function(value) {
          var old = this._setPrivateData(property, value);
          // TODO(sjmiles): dirty-check ftw! 
          if (old !== value) {
            this._multiBindPropertyChanged(property, data, value, old);
          }
        },
        get: function() {
          return this._privateData[property];
        }
      });
      // store bind data
      this._multiData[property] = data;
    },

    _createMultiBindTarget: function(source, path) {
      var paths = path.split('.');
      var id = paths.shift();
      var property = paths.join('.') || 'textContent';
      return {
        id: id,
        property: property,
        effect: 'this.$.' + id + '.' + property + '=this._privateData.' 
          + source + ';'
      };      
    },

    _multiBindPropertyChanged: function(property, data, value, old) {
      //console.log('[bind._multiBindPropertyChanged]:', property, data, value, old);
      // to have validation ability, `callback` must be distinguished
      // from other side-effects
      if (data.callback) {
        var validated = this[data.callback](value, old);
        if (validated !== undefined) {
          // recurse
          this[property] = validated;
          return;
        }
      }
      // process other side-effects
      if (data.sideEffectFn) {
        data.sideEffectFn.call(this, value);
      }
      // if published, notify
      if (data.published) {
        this._notifyChange(property);
      }
    },

    _notifyChange: function(property) {
      this.fire(property + '-changed', this[property], null, false);
    },

    _setPrivateData: function(property, value) {
      var old = this._privateData[property];
      if (old !== value) {
        this._privateData[property] = value;
      }
      return old;
    },

    bindMethod: function(property, path) {
      Object.defineProperty(this, property, {
        set: function(value) {
          var old = this._setPrivateData(property, value);
          // TODO(sjmiles): dirty-checking ftw!
          // A large (?) amount of useless setting is short-circuited here.
          // KISS suggested we choose this blunt modus for circularity defense 
          // as opposed to constructing a true orchestrator. 
          if (old !== value) {
            this[path](value, old);
          }
        },
        get: function() {
          return this._privateData[property];
        }
      });
    },

    bindProperty: function(property, path) {
      Object.defineProperty(this, property, {
        set: new Function('value', path + ' = value;'),
        get: new Function('return ' + path + ';')
      });
    }

  });

</script>