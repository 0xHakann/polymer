<script>

  /*
   * Needs new name.
   * 
   * Provides a data-binding API, by which a getter/setter pair
   * can be constructed in one of two imperative modes:
   * 
   * bindMethod(property, methodName): constructs a getter/setter pair and a 
   * backing store for the given property; calls the method when the setter
   * is invoked and the value has changed from what is in the backing store.
   * 
   * bindProperty(property, path): constructs a getter/setter pair that 
   * forwards data access to a property on another object.
   * 
   * This feature also supports a `bind` object, which contains expressions
   * that are deconstructed into `bindMethod` or `bindProperty` calls, or
   * into a `multiBinding` construct. `multiBinding` constructs support 
   * multiple side-effects.
   *
   * bind {
   *   // if `method` is the name of a method on the current object, a
   *   // `bindMethod` call is made to define `property` as described above.
   *   property: 'method'
   *   // if the value is not the name of a method, it's assumed to be the
   *   // name in the `$` hash that maps to an element.
   *   // If no target property is specified, `textContent` is assumed to 
   *   // be the backing-store for `property2` accessors.
   *   property2: 'elementId'
   *   // If a path is provided, that element is dereferenced from $ as before, 
   *   // but the full path is used for the backing-store.
   *   // This declaration binds property3 to $.elementId.value  
   *   property3: 'elementId.value'
   *   // If the specified property is also `published`, a multi-binding 
   *   // construct is created which sends a change notification in addition
   *   // to whatever user side-effect is specified. 
   *   publishedProperty: <method name or element property>
   *   // Specify multiple side-effects directly as an array. Only one
   *   // callback method is allowed.
   *   property4: [
   *     'nameOfMethod',
   *     'elementId',
   *     'elementId.property',
   *     ...
   *   ] 
   * } 
   * 
   * Methods bound into multi-bind contexts support a validation feature. If
   * the method returns a value that does not === undefined side-effects are
   * prevented, and the triggering property is set to the returned value, and
   * a new round of side-effects is initiated.
   * 
   * Multi-bind = multiple side-effects for one signal.
   * Note: `signal` today is `set-trap`, should we generalize?
   * Side-effects can be registered by multiple subsystems:
   *   - bind feature
   *   - bind-annotations feature
   *   - computed feature
   *   - published feature
   * We need to accumulate all side-effects for a particular property 
   * before constructing the handler.
   * 
   */
  Base.addFeature({

    // per instance
    
    init: function() {
      this._data = Object.create(null);
    },

    _setupBindListeners: function() {
      var bl = this._bindListeners;
      for (var n in bl) {
        bl[n].targets.forEach(function(target) {
          this._setupBindListener(n, target);
        }, this);
      }
    },

    _setupBindListener: function(property, target) {
      //console.log('[bind]: [%s][%s] listening for [%s][%s-changed]', this.localName, property, target.id || target.index, target.property);
      var host = this, property;
      var node = target.id ? this.$[target.id] : this._nodes[target.index];
      node.addEventListener(target.property + '-changed', function(e) {
        //console.log('[bind]:[%s] heard [%s-changed] this.[%s] = [%s]', host.localName, source, property, e.detail);
        host[property] = e.detail;
      });
    },

    // per prototype
    
    register: function(prototype) {
      prototype._prepareBindData();
      prototype._addPropertyBindEffects();
    },

    _notifyChange: function(property) {
      this.fire(property + '-changed', this[property], null, false);
    },

    _setData: function(property, value) {
      var old = this._data[property];
      if (old !== value) {
        this._data[property] = value;
      }
      return old;
    },

    _prepareBindData: function() {
      // TODO(sjmiles): `_bound` is ad hoc name tracking for custom telemetry
      this._bound = [];
      // TODO(sjmiles): legacy structure for adding notify listeners: improve
      this._bindListeners = {};
      // property effect accumulator
      this._propertyEffects = {};
    },

    addPropertyEffect: function(property, kind, effect) {
      var fx = this._propertyEffects[property];
      if (!fx) {
        fx = this._propertyEffects[property] = [];
      }
      fx.push({
        kind: kind,
        effect: effect
      });
    },

    // TODO(sjmiles): called from bind-effects, should be untangled
    _addBindListener: function(source, id, property) {
      var bl = this._requireBindListeners(source);
      bl.targets.push({
        id: id,
        property: property
      });
    },

    _addAnnotatedListener: function(source, index, property) {
      var bl = this._requireBindListeners(source);
      bl.targets.push({
        index: index,
        property: property
      });
    },

    _requireBindListeners: function(source) {
      var bl = this._bindListeners[source];
      if (!bl) {
        bl = this._bindListeners[source] = {targets: []};
      }
      return bl;
    },

    _addPropertyBindEffects: function() {
      for (var n in this.bind) {
        var bind = this.bind[n];
        if (typeof bind === 'object') {
          // multiplexed definition
          for (var nn in bind) {
            this._addPropertyBindEffect(n, bind[nn]);
          }
        } else {
          // single definition
          this._addPropertyBindEffect(n, bind);
        }
      }
    },

    _addPropertyBindEffect: function(property, bindEffect) {
      this.addPropertyEffect(property, 'bind', bindEffect);
    }

  });

</script>