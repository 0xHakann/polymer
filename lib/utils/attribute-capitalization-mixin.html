<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">
<link rel="import" href="mixin.html">
<link rel="import" href="../mixins/property-effects.html">

<script>
(function() {

  'use strict';

  const regex = /[A-Z]/;

  /**
   * Mixin that uses an heuristic to determine the capitalization of HTML
   * attributes. By default, all attributes are lowercased. However, some
   * native attributes have capitalization. `Element.attributes` only returns
   * capitalized attributes if the attribute name is exactly equal to the attribute.
   * In other words, `viewBox$` will be lowercased to `viewbox$`. Therefore, if
   * an attribute name still has capitaliation, we use an attribute effect to
   * update the bindings.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @memberof Polymer
   * @summary Class mixin that uses an heuristic to determine the capitalization
   * of HTML attributes.
   */
  Polymer.AttributeCapitalization = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyEffects}
     * @unrestricted
     */
    const base = Polymer.PropertyEffects(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */
    class AttributeCapitalization extends base {
      /**
       * Overrides default `PropertyEffects` implementation to automatically
       * detect capitalized attributes.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        if (regex.test(name)) {
          node.removeAttribute(name);
          name = name + '$';
        }
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }

    return AttributeCapitalization;
  });
})();
</script>
