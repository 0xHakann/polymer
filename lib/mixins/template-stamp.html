<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/mixin.html">

<script>
(function() {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)
  const templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    let is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      let t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while(t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    let parent = nodeInfo.parent && findTemplateNode(root, nodeInfo.parent);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
        if (nodeInfo.index === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo, host) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, host);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    let handler = function(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   * - Relative URL's relative to original template location
   * - Template binding annotation parsing (note that this library only parses
   *   template bindings and provides annotation metadata; see
   *   `Polymer.PropertyEffects` for a full implementation of data-binding)
   *
   * @polymerMixin
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function(superClass) {

    return class TemplateStamp extends superClass {

      constructor() {
        super();
        this.$ = null;
        this.__templateNodes = null;
        this.__templateNodeInfo = null;
      }

      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * `nodeInfo` metadata captured by this library include the following:
       *
       *   [
       *     {
       *       id: '<id>',  // `id`
       *       events: [
       *         {
       *           name: '<name>'
       *           value: '<expression>'
       *         }, ...
       *       ],
       *       bindings: [
       *         {
       *           kind: ['text'|'attribute'|'property'],
       *           mode: ['auto'|''],
       *           name: '<name>'
       *           value: '<expression>'
       *         }, ...
       *       ],
       *       parent: <reference to parent nodeInfo>,
       *       index: <integer index in parent's `childNodes` collection>
       *     },
       *     ...
       *   ]
       *
       * @param {HTMLTemplateElement} template
       * @param {Object=} outerTemplateInfo
       * @return {Object} Template metadata
       */
      static _parseTemplate(template, outerTemplateInfo) {
        // since a template may be re-used, memo-ize notes.
        if (!template._templateInfo) {
          let templateInfo = template._templateInfo || (template._templateInfo = {});
          templateInfo.nodeInfo = [];
          templateInfo.stripWhiteSpace =
            (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
            template.hasAttribute('strip-whitespace');
          this._parseTemplateNode(template.content, templateInfo, {parent: null});
        }
        return template._templateInfo;
      }

      // add annotations gleaned from subtree at `node` to `notes`
      static _parseTemplateNode(node, templateInfo, nodeInfo) {
        let noted;
        if (node.localName == 'template' && !node.hasAttribute('preserve-content')) {
          noted = this._parseTemplateNestedContent(node, templateInfo, nodeInfo) || noted;
        } else if (node.localName === 'slot') {
          // For ShadyDom optimization, indicating there is an insertion point
          templateInfo.hasInsertionPoint = true;
        }
        if (node.firstChild) {
          noted = this._parseTemplateChildNodes(node, templateInfo, nodeInfo) || noted;
        }
        if (node.hasAttributes && node.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(node, templateInfo, nodeInfo) || noted;
        }
        return noted;
      }

      static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
        for (let node=root.firstChild, index=0, next; node; node=next) {
          // Wrap templates
          if (node.localName == 'template') {
            node = wrapTemplateExtension(node);
          }
          // collapse adjacent textNodes: fixes an IE issue that can cause
          // text nodes to be inexplicably split =(
          // note that root.normalize() should work but does not so we do this
          // manually.
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            let n = next;
            while (n && (n.nodeType === Node.TEXT_NODE)) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            // optionally strip whitespace
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              continue;
            }
          }
          let childInfo = { index, parent: nodeInfo };
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            templateInfo.nodeInfo.push(childInfo);
          }
          index++;
        }
      }

      // Recurse into nested templates
      // 1. Parse annotations from the template and memoize them on
      //    content._templateInfo (recurses into nested templates)
      // 2. Remove template.content and store it in annotation list, where it
      //    will be the responsibility of the host to set it back to the template
      //    (this is both an optimization to avoid re-stamping nested template
      //    children and avoids a bug in Chrome where nested template children
      //    upgrade)
      static _parseTemplateNestedContent(node, outerTemplateInfo, nodeInfo) {
        let templateInfo = this._parseTemplate(node, outerTemplateInfo);
        let content = templateInfo.content =
          node.content.ownerDocument.createDocumentFragment();
        content.appendChild(node.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }

      // add annotation data from attributes to the `annotation` for node `node`
      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        let noted;
        let attrs = Array.from(node.attributes);
        for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
        }
        return noted;
      }

      // construct annotation data from a generic attribute, or undefined
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
          nodeInfo.id = value;
          return true;
        }
      }

      static _contentForTemplate(template) {
        let templateInfo = template.__templateInfo;
        return (templateInfo && templateInfo.content) || template.content;
      }

      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `this.$`
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested <template>.content
       * is removed and stored in notes as well.
       *
       * Note that this method may only be called once per instance (it does
       * not support stamping multiple templates per element instance).
       *
       * @param {HTMLTemplateElement} template Template to stamp
       */
      _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content &&
            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        let templateInfo = this.constructor._parseTemplate(template);
        let nodeInfo = this.__templateNodeInfo = templateInfo.nodeInfo;
        let content = templateInfo.content || template.content;
        let dom = document.importNode(content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        this.$ = {};
        this.__templateNodes = new Array(nodeInfo.length);
        for (let i=0, l=nodeInfo.length, info, node; (i<l) && (info=nodeInfo[i]); i++) {
          node = this.__templateNodes[i] = findTemplateNode(dom, info);
          applyIdToMap(this, this.$, node, info);
          applyTemplateContent(this, node, info);
          applyEventListener(this, node, info, this);
        }
        return dom;
      }

      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }

    }

  });

})();
</script>
