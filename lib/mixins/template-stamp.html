<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/mixin.html">

<script>
(function() {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)
  const templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    let is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      let t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while(t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateAnnotatedNode(root, note) {
    // recursively ascend tree until we hit root
    let parent = note.parent && findTemplateAnnotatedNode(root,
      note.parent);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
        if (note.index === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, note) {
    if (note.id) {
      map[note.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, note, host) {
    if (note.events && note.events.length) {
      for (let j=0, e$=note.events, e; (j<e$.length) && (e=e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, host);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, note) {
    if (note.templateContent) {
      node._content = note.templateContent;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    let handler = function(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   * - Relative URL's relative to original template location
   * - Template binding annotation parsing (note that this library only parses
   *   template bindings and provides annotation metadata; see
   *   `Polymer.PropertyEffects` for a full implementation of data-binding)
   *
   * @polymerMixin
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(function(superClass) {

    return class TemplateStamp extends superClass {

      constructor() {
        super();
        this.$ = null;
        this.__templateNodes = null;
        this.__templateNotes = null;
      }

      /**
       * Scans a template to produce an annotation map that stores expression metadata
       * and information that associates the metadata to nodes in a template instance.
       *
       * Supported annotations are:
       *   * id attributes
       *   * binding annotations in text nodes
       *     * double-mustache expressions: {{expression}}
       *     * double-bracket expressions: [[expression]]
       *   * binding annotations in attributes
       *     * attribute-bind expressions: name="{{expression}} || [[expression]]"
       *     * property-bind expressions: name*="{{expression}} || [[expression]]"
       *     * property-bind expressions: name:="expression"
       *   * event annotations
       *     * event delegation directives: on-<eventName>="expression"
       *
       * Generated data-structure:
       *   [
       *     {
       *       id: '<id>',
       *       events: [
       *         {
       *           mode: ['auto'|''],
       *           name: '<name>'
       *           value: '<expression>'
       *         }, ...
       *       ],
       *       bindings: [
       *         {
       *           kind: ['text'|'attribute'|'property'],
       *           mode: ['auto'|''],
       *           name: '<name>'
       *           value: '<expression>'
       *         }, ...
       *       ],
       *       parent: <reference to parent annotation>,
       *       index: <integer index in parent's childNodes collection>
       *     },
       *     ...
       *   ]
       *
       * @param {HTMLTemplateElement} template
       * @param {boolean=} stripWhiteSpace
       * @param {Document=} ownerDocument
       * @return {Array<Object>}
       */
      static _prepareTemplate(template, stripWhiteSpace, ownerDocument) {
        // TODO(kschaaf): File issue and/or remove when fixed
        // hold a reference to content as _content to prevent odd Chrome gc issue
        // nested templates also may receive their content as _content
        let content = (template._content = template._content || template.content);
        // since a template may be re-used, memo-ize notes.
        if (!content._notes) {
          let notes = content._notes = [];
          notes.ownerDocument = ownerDocument || template.ownerDocument;
          notes.stripWhiteSpace = stripWhiteSpace || template.hasAttribute('strip-whitespace');
          this._parseTemplateNode(content, {notes});
        }
        return content._notes;
      }

      // add annotations gleaned from subtree at `node` to `notes`
      static _parseTemplateNode(node, note) {
        let noted;
        if (node.localName == 'template' &&
          !node.hasAttribute('preserve-content')) {
          noted |= this._parseTemplate(node, note);
        } else if (node.localName === 'slot') {
          node._hasInsertionPoint = true;
        }
        if (node.firstChild) {
          noted |= this._parseTemplateChildNodes(node, note);
        }
        if (node.attributes) {
          noted |= this._parseTemplateNodeAttributes(node, note);
        }
        return noted;
      }

      // add annotations gleaned from children of `root` to `list`, `root`'s
      // `note` is supplied as it is the note.parent of added annotations
      static _parseTemplateChildNodes(root, note) {
        let node = root.firstChild;
        if (node) {
          let i = 0;
          while (node) {
            // Wrap templates
            if (node.localName == 'template') {
              node = wrapTemplateExtension(node);
            }
            // collapse adjacent textNodes: fixes an IE issue that can cause
            // text nodes to be inexplicably split =(
            // note that root.normalize() should work but does not so we do this
            // manually.
            let next = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE) {
              let n = next;
              while (n && (n.nodeType === Node.TEXT_NODE)) {
                node.textContent += n.textContent;
                next = n.nextSibling;
                root.removeChild(n);
                n = next;
              }
              // optionally strip whitespace
              if (note.notes.stripWhiteSpace && !node.textContent.trim()) {
                root.removeChild(node);
                // decrement index since node is removed
                i--;
              }
            }
            // if this node didn't get evacipated, parse it.
            if (node.parentNode) {
              let childNote = {
                notes: note.notes,
                parent: note,
                index: i
              }
              if (this._parseTemplateNode(node, childNote)) {
                note.notes.push(childNote);
              }
            }
            node = next;
            i++;
          }
        }
      }

      // Recurse into nested templates
      // 1. Parse annotations from the template and memoize them on
      //    content._notes (recurses into nested templates)
      // 2. Remove template.content and store it in annotation list, where it
      //    will be the responsibility of the host to set it back to the template
      //    (this is both an optimization to avoid re-stamping nested template
      //    children and avoids a bug in Chrome where nested template children
      //    upgrade)
      static _parseTemplate(node, note) {
        let content = node.content.ownerDocument.createDocumentFragment();
        content._notes = this._prepareTemplate(node,
          note.notes.stripWhiteSpace, note.notes.ownerDocument);
        content.appendChild(node.content);
        note.templateContent = content;
        return true;
      }

      // add annotation data from attributes to the `annotation` for node `node`
      static _parseTemplateNodeAttributes(node, note) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        let attrs = Array.prototype.slice.call(node.attributes);
        let noted;
        for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
          noted |= this._parseTemplateNodeAttribute(node, note, a.name, a.value)
        }
        return noted;
      }

      // construct annotation data from a generic attribute, or undefined
      static _parseTemplateNodeAttribute(node, note, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          note.events = note.events || [];
          note.events.push({
            name: name.slice(3),
            value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
          note.id = value;
          return true;
        }
      }

      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, which identify nodes with declarative
       * event listeners (`on-...``), `id`'s, `<template>`s, and bindings
       * (`{{...}}` and `[[...]]`).  This template metadata ("notes")
       * are stored as `this.__templateNotes`, and any nodes identified in
       * notes are collected for this instance into `__templateNodes` in
       * the same order as the notes array.
       *
       * Finally, this method generates an "id map" for all nodes with id's
       * under `this.$`, passes template content back to templates as `_content`
       * (a performance optimization to avoid deep template cloning), and
       * installs declarative event listeners.
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested <template>.content
       * is removed and stored in notes as well.
       *
       * Note that this method may only be called once per instance (it does
       * not support stamping multiple templates per element instance).
       *
       * @param {HTMLTemplateElement} template Template to stamp
       */
      _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content &&
            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        let notes = this.__templateNotes = this.constructor._prepareTemplate(template);
        let dom = document.importNode(template._content || template.content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !notes._hasInsertionPoint;
        this.$ = {};
        this.__templateNodes = new Array(notes.length);
        for (let i=0, l=notes.length, note, node; (i<l) && (note=notes[i]); i++) {
          node = this.__templateNodes[i] = findTemplateAnnotatedNode(dom, note);
          applyIdToMap(this, this.$, node, note);
          applyTemplateContent(this, node, note);
          applyEventListener(this, node, note, this);
        }
        return dom;
      }

      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }

    }

  });

})();
</script>
