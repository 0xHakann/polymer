<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>
(function() {

  // Common implementation for mixin & behavior
  function mutablePropertyChange(inst, property, value, old, useObjectIdentity) {
    let isObject;
    if (!useObjectIdentity) {
      isObject = (typeof value === 'object' && value !== null);
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    let shouldChange = (old !== value && (old === old || value === value));
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays,
   * for use on elements utilizing `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns or the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays.  This allows a user to make a deep modification to a
   * bound object graph, and then either simply re-set the object (e.g.
   * `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   *
   * @polymerMixin
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(superClass => {

    return class MutableData extends superClass {
      /**
       * Overrides `Polymer.PropertyEffects` to skip strict equality checking
       * for Objects and Arrays.
       *
       * Pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * Users may override this method and call super setting `useObjectIdentity`
       * to `true` to fall back to strict dirty checking if the mutable nature
       * requires configurability.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @param {boolean} useObjectIdentity When true, the method falls back
       *   to using strict object identity dirty checking
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */
      _shouldPropertyChange(property, value, old, useObjectIdentity) {
        return mutablePropertyChange(this, property, value, old, useObjectIdentity);
      }
    }

  });

  // Export for use by legacy behavior
  Polymer.MutableData.mutablePropertyChange = mutablePropertyChange;

})();
</script>
