<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/mixin.html">
<link rel="import" href="../mixins/properties-changed.html">

<script>
(function() {
  'use strict';

  /**
   * Mixin that provides minimal starting point to using the PropertiesChanged
   * mixin by providing a mechanism to declare properties in a static
   * getter (e.g. static get properties() { return { foo: String } }). Changes
   * are reported via the `_propertiesChanged` method.
   *
   * This mixin provides no specific support for rendering. Users are expected
   * to create a shadowRoot and put content into it and update it in whatever
   * way makes sense for the use case.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertiesChanged
   * @memberof Polymer
   * @summary Mixin that provides a minimal starting point for using
   * the PropertiesChanged mixin by providing a declarative `properties` object.
   */
   Polymer.PropertiesMixin = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertiesChanged}
     */
    const base = Polymer.PropertiesChanged(superClass);

    /**
     * Mixes `moreProps` into `props` but upgrades shorthand type
     * syntax to { type: Type}.
     *
     * @param {Object} props Properties to normalize
     * @return {Object} Copy of input `props` with normalized properties that
     * are in the form {type: Type}
     * @private
     */
    function normalizeProperties(props) {
      const output = {};
      for (let p in props) {
        let o = props[p];
        if (typeof o == 'function') {
          o = { type: o };
        }
        output[p] = o;
      }
      return output;
    }

    /**
     * Returns the super class constructor for the given class, if it is an
     * instance of the PropertiesClass.
     *
     * @param {PropertiesClassConstructor} ctor PropertiesClass constructor
     * @return {PropertiesClassConstructor} Super class constructor
     */
    function superForClass(ctor) {
      const proto = /** @type {PropertiesClassConstructor} */ (ctor).prototype;
      const superCtor = Object.getPrototypeOf(proto).constructor;
      if (superCtor.prototype instanceof PropertiesClass) {
        return superCtor;
      }
    }

    /**
     * Returns a memoized version of the `properties` object for the
     * given class. Properties not in object format are converted to at
     * least {type}.
     *
     * @param {PropertiesClassConstructor} ctor PropertiesClass constructor
     * @return {Object} Memoized properties object
     */
    function ownProperties(ctor) {
      if (!ctor.hasOwnProperty(
        JSCompiler_renameProperty('__ownProperties', ctor))) {
        const props = ctor.properties;
        ctor.__ownProperties = props ? normalizeProperties(props) : null;
      }
      return ctor.__ownProperties;
    }

    /**
     * Returns map of properties for attributes for the given class.
     *
     * @param {PropertiesClassConstructor} ctor PropertiesClass constructor
     * @param {string} nane Name of attribute
     * @return {string} Name of property.
     */
    function propertyNameForAttributeMap(ctor) {
      if (!ctor.hasOwnProperty(
        JSCompiler_renameProperty('__propertyNameForAttributeMap', ctor))) {
        ctor.__propertyNameForAttributeMap = {};
      }
      return ctor.__propertyNameForAttributeMap;
    }

    /**
     * @polymer
     * @mixinClass
     * @extends {base}
     * @implements {Polymer_PropertiesMixin}
     * @unrestricted
     */
    class PropertiesClass extends base {

      /**
       * Implements standard custom elements getter to observes the attributes
       * listed in `properties`.
       */
      static get observedAttributes() {
        const props = this._properties;
        return props ? Object.keys(props).map(p => {
          return this.prototype._attributeNameForProperty(p);
        }) : [];
      }

      /**
       * Finalizes an element definition, including ensuring any super classes
       * are also finalized. This includes ensuring property
       * accessors exist on the element prototype. This method calls
       * `_finalizeClass` to finalize each constructor in the prototype chain.
       */
       static finalize() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
          const superCtor = superForClass(this);
          if (superCtor) {
            superCtor.finalize();
          }
          this.__finalized = true;
          this._finalizeClass();
        }
      }

      /**
       * Finalize an element class. This includes ensuring property
       * accessors exist on the element prototype. This method is called by
       * `finalize` and finalizes the class constructor.
       *
       * @protected
       */
      static _finalizeClass() {
        const props = ownProperties(this);
        if (props) {
          this.createProperties(props);
        }
      }

      /**
       * Returns a memoized version of all properties, including those inherited
       * from super classes. Properties not in object format are converted to
       * at lesat {type}.
       *
       * @return {Object} Object containing properties for this class
       * @protected
       */
      static get _properties() {
        if (!this.hasOwnProperty(
          JSCompiler_renameProperty('__properties', this))) {
          const superCtor = superForClass(this);
          this.__properties = Object.assign({},
            superCtor && superCtor._properties, ownProperties(this));
        }
        return this.__properties;
      }

      /**
       * Overrides PropertiesChanged implementation to provide caching.
       * @param {string} name Name of property
       * @return {string} Name of attribute
       */
      _propertyNameForAttribute(name) {
        const cache = propertyNameForAttributeMap(this.constructor);
        if (!cache[name]) {
          cache[name] = super._propertyNameForAttribute(name);
        }
        return cache[name];
      }

      /**
       * Overrides PropertiesChanged method to return type specified in the
       * static `properties` object for the given property.
       * @param {string} name Name of property
       * @return {*} Type to which to deserialize attribute
       *
       * @protected
       */
      _typeForProperty(name) {
        const info = this.constructor._properties[name];
        return info && info.type;
      }

      /**
       * Overrides default behavior and adds a call to `finalize` which lazily
       * configures the element's property accessors.
       * @override
       */
      _initializeProperties() {
        this.constructor.finalize();
        super._initializeProperties();
      }

      /**
       * Called when the element is added to a document.
       * Calls `_enableProperties` to turn on property system from
       * `PropertiesChanged`.
       */
      connectedCallback() {
        this._enableProperties();
      }

      /**
       * Called when the element is removed from a document
       */
      disconnectedCallback() {}

    }

    return PropertiesClass;

  });

})();

</script>
