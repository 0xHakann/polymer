<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../lib/style-properties.html">
<link rel="import" href="../lib/settings.html">
<link rel="import" href="../lib/style-defaults.html">
<link rel="import" href="../lib/style-cache.html">
<script>
  (function() {

    var attachedCallback = Polymer.Base.attachedCallback;
    var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;

    var propertyUtils = Polymer.StyleProperties;
    var styleTransformer = Polymer.StyleTransformer;
    var styleUtil = Polymer.StyleUtil;
    var styleDefaults = Polymer.StyleDefaults;

    var nativeShadow = Polymer.Settings.useNativeShadow;

    Polymer.Base._addFeature({

      _prepStyleProperties: function() {
        // determine if element contains x-scope styling
        var consumes;
        if (this._styles) {
          this._styles.forEach(function(s) {
            var rules = styleUtil.rulesForStyle(s);
            propertyUtils.decorateRules(rules);
            if (rules.propertyInfo.cssText) {
              consumes = true;
            }
          }, this);
        }
        this._useStyleProperties = consumes;
      },

      attachedCallback: function() {
        attachedCallback.call(this);
        // note: do this once automatically,
        // then requires calling `updateStyles`
        if (!this._scopeSelector && this._useStyleProperties) {
          this._updateStyleProperties();
        }
      },

      _updateStyleProperties: function(avoidCache) {
        var style, scope = this.domHost || styleDefaults;
        // install cache in host if it doesn't exist.
        if (!scope._styleCache) {
          scope._styleCache = new Polymer.StyleCache();
        }
        var scopeProps = propertyUtils
          .propertiesFromStyles(scope._styles, this);
        // look in scope cache
        if (!avoidCache) {
          style = scope._styleCache.retrieve(this.is, scopeProps, 
            this._styles);
        }
        // fast path: cache hit in scope cache, apply!
        if (style) {
          this._styleProperties = style._styleProperties;
        // cache miss, do work!
        } else {
          // compute style properties
          this._computeStyleProperties(scopeProps);
          // and look in 2ndary global cache
          style = styleCache.retrieve(this.is, 
            this._styleProperties, this._styles);
        }
        // now we have property styleProperties and a cached style if one 
        // is available.
        var notCached = !style;
        style = this._applyStyleProperties(style);
        // no cache so store in cache
        if (notCached) {
          scope._styleCache.store(this.is, style, this._scopeSelector,
            scopeProps, this._styles);
          styleCache.store(this.is, style, this._scopeSelector,
           this._styleProperties, this._styles);
        }
      },

      _computeStyleProperties: function(scopeProps) {
        // get scope and make sure it has properties
        var scope = this.domHost || styleDefaults;
        if (!scope._styleProperties) {
          scope._computeStyleProperties();
        }
        // start with scope style properties
        var props = Object.create(scope._styleProperties);
        // mixin properties matching this element in scope
        scopeProps = scopeProps || 
          propertyUtils.propertiesFromStyles(scope._styles, this);
        this.mixin(props, scopeProps);
        // finally mixin properties inherent to this element
        this.mixin(props, propertyUtils.rootPropertiesFromStyles(this._styles));
        // reify properties
        propertyUtils.reify(props);
        this._styleProperties = props;
      },

      _scopeCount: 0,

      _applyStyleProperties: function(style) {
        // update scope selector (needed for style transformation)
        var oldScopeSelector = this._scopeSelector;
        // note, the scope selector is incremented per class counter
        this._scopeSelector = style ? style._scope : 
          this.is + '-' + this.__proto__._scopeCount++;
        style = propertyUtils.applyElementStyle(this, 
          this._styleProperties, this._scopeSelector, style);
        // apply scope selector (iff we have some scoped css)
        if ((style || oldScopeSelector) && !nativeShadow) {
          propertyUtils.applyElementScopeSelector(this, this._scopeSelector, 
            oldScopeSelector, this._scopeCssViaAttr);
        }
        return style || {};
      },

      // override to ensure whenever classes are set, we need to shim them.
      serializeValueToAttribute: function(value, attribute, node) {
        if (attribute === 'class') {
          // host needed to scope styling.
          var host = node === this ?
            Polymer.dom(this).getOwnerRoot() || this.dataHost :
            this;
          if (host) {
            value = host._scopeElementClass(node, value);
          }
        }
        serializeValueToAttribute.call(this, value, attribute, node);
      },

      _scopeElementClass: function(element, selector) {
        if (!nativeShadow && !this._scopeCssViaAttr) {
          selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is +
            (element._scopeSelector ? ' ' +  XSCOPE_NAME + ' ' +
            element._scopeSelector : '');
        }
        return selector;
      },

      updateStyles: function() {
        if (this.isAttached) {
          // skip applying properties to self if not used
          if (this._useStyleProperties) {
            this._updateStyleProperties(true);
          }
          // always apply properties to root
          this._updateRootStyles();
        }
      },

      _updateRootStyles: function(root) {
        root = root || this.root;
        var c$ = Polymer.dom(root)._query(function(e) {
          return e.shadyRoot || e.shadowRoot;
        });
        for (var i=0, l= c$.length, c; (i<l) && (c=c$[i]); i++) {
          if (c.updateStyles) {
            c.updateStyles();
          }
        }
      }

    });

    /**
     * Force all custom elements using cross scope custom properties,
     * to update styling.
     */
    Polymer.updateStyles = function() {
      Polymer.Base._updateRootStyles(document);
    };

    var styleCache = new Polymer.StyleCache();
    Polymer.customStyleCache = styleCache;

    var SCOPE_NAME = styleTransformer.SCOPE_NAME;
    var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;

  })();
</script>
