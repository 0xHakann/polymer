<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/boot.html">
<link rel="import" href="distributor-v1.html">
<script>

  (function() {

    var DomApi = Polymer.DomApi;
    var TreeApi = Polymer.TreeApi;

    class ShadyDistributorV0 extends Polymer.ShadyDistributorV1 {
      
      constructor(root) {
        super(root)
        this.insertionPointTag = 'content';
      }

      resetChild(child) {
        if (child._destinationInsertionPoints) {
          child._destinationInsertionPoints = undefined;
        }
        if (this.isInsertionPoint(child)) {
          this.clearDistributedDestinationInsertionPoints(child);
        }
      }

      resetInsertionPoint(insertionPoint) {
        insertionPoint._distributedNodes = [];
      }

      clearDistributedDestinationInsertionPoints(content) {
        var e$ = content._distributedNodes;
        if (e$) {
          for (var i=0; i < e$.length; i++) {
            var d = e$[i]._destinationInsertionPoints;
            if (d) {
              // this is +1 because these insertion points are *not* in this scope
              d.splice(d.indexOf(content)+1, d.length);
            }
          }
        }
      }

      // Gather the pool of nodes that should be distributed. We will combine
      // these with the "content root" to arrive at the composed tree.
      collectPool() {
        var pool = [];
        var children = TreeApi.Logical.getChildNodes(this.root.host);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (this.isInsertionPoint(child)) {
            pool.push.apply(pool, child._distributedNodes);
          } else {
            pool.push(child);
          }
        }
        return pool;
      }

      distributeNodeInto(child, insertionPoint) {
        insertionPoint._distributedNodes.push(child);
        var points = child._destinationInsertionPoints;
        if (!points) {
          child._destinationInsertionPoints = [insertionPoint];
        } else {
          points.push(insertionPoint);
        }
      }

      setDistributedNodesOnInsertionPoint(insertionPoint) {}

      matchesInsertionPoint(node, insertionPoint) {
        var select = insertionPoint.getAttribute('select');
        // no selector matches all nodes (including text)
        if (!select) {
          return true;
        }
        select = select.trim();
        // same thing if it had only whitespace
        if (!select) {
          return true;
        }
        // selectors can only match Elements
        if (!(node instanceof Element)) {
          return false;
        }
        // only valid selectors can match:
        //   TypeSelector
        //   *
        //   ClassSelector
        //   IDSelector
        //   AttributeSelector
        //   negation
        var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
        if (!validSelectors.test(select)) {
          return false;
        }
        return DomApi.matchesSelector(select, node);
      }

      // TODO(sorvell): util?
      isFinalDestination(insertionPoint, node) {
        var points = node._destinationInsertionPoints;
        return points && points[points.length - 1] === insertionPoint;
      }

    }

    Polymer.ShadyDistributorV0 = ShadyDistributorV0;

  })();

</script>
