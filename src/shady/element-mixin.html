<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/utils.html">
<link rel="import" href="innerHTML.html">
<script>
(function() {
  'use strict';

  var Tree = Polymer.ShadyDom.Tree;
  var getInnerHTML = Polymer.ShadyDom.getInnerHTML;

  var nativeCloneNode = Element.prototype.cloneNode;
  var nativeImportNode = Document.prototype.importNode;
  var nativeSetAttribute = Element.prototype.setAttribute;
  var nativeRemoveAttribute = Element.prototype.removeAttribute;

  var mixinImpl = {

    // Try to add node. Record logical info, track insertion points, perform
    // distribution iff needed. Return true if the add is handled.
    addNode: function(container, node, ref_node) {
      var ownerRoot = this.ownerRootForNode(container);
      if (ownerRoot) {
        // note: we always need to see if an insertion point is added
        // since this saves logical tree info; however, invalidation state
        // needs
        var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);
        // invalidate insertion points IFF not already invalid!
        // TODO(sorvell): this flipped to opt out.
        if (!ownerRoot._invalidInsertionPoints) {
          ownerRoot._invalidInsertionPoints = ipAdded;
        }
        this._addNodeToHost(ownerRoot.host, node);
      }
      if (Tree.Logical.hasChildNodes(container)) {
        Tree.Logical.recordInsertBefore(node, container, ref_node);
      }
      // if not distributing and not adding to host, do a fast path addition
      var handled = this._maybeDistribute(node, container, ownerRoot) ||
        container.shadyRoot;
      // if shady is handling this node,
      // the actual dom may not be removed if the node or fragment contents
      // remain undistributed so we ensure removal here.
      // NOTE: we only remove from existing location iff shady dom is involved.
      // This is because a node fragment is passed to the native add method
      // which expects to see fragment children. Regular elements must also
      // use this check because not doing so causes separation of
      // attached/detached and breaks, for example,
      // dom-if's attached/detached checks.
      if (handled) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          while (node.firstChild) {
            Tree.Composed.removeChild(node, node.firstChild);
          }
        } else {
          var parent = Tree.Composed.getParentNode(node);
          if (parent) {
            Tree.Composed.removeChild(parent, node);
          }
        }
      }
      return handled;
    },

    // Try to remove node: update logical info and perform distribution iff
    // needed. Return true if the removal has been handled.
    // note that it's possible for both the node's host and its parent
    // to require distribution... both cases are handled here.
    removeNode: function(node) {
      // important that we want to do this only if the node has a logical parent
      var logicalParent = Tree.Logical.hasParentNode(node) &&
        Tree.Logical.getParentNode(node);
      var distributed;
      var ownerRoot = this.ownerRootForNode(node);
      if (logicalParent) {
        // distribute node's parent iff needed
        distributed = this.maybeDistributeParent(node);
        Tree.Logical.recordRemoveChild(node, logicalParent);
        // remove node from root and distribute it iff needed
        if (ownerRoot && this._removeDistributedChildren(ownerRoot, node)) {
          // TODO(sorvell): invalidation flipped
          ownerRoot._invalidInsertionPoints = true;
          ownerRoot.update();
        }
      }
      this._removeOwnerShadyRoot(node);
      if (ownerRoot) {
        this._removeNodeFromHost(ownerRoot.host, node);
      }
      return distributed;
    },

    removeNodeFromParent: function(node, parent) {
      if (parent) {
        // TODO(sorvell): notify
        // if (DomApi.hasApi(parent)) {
        //   dom(parent).notifyObserver();
        // }
        this.removeNode(node);
      } else {
        this._removeOwnerShadyRoot(node);
      }
    },

    _hasCachedOwnerRoot: function(node) {
      return Boolean(node._ownerShadyRoot !== undefined);
    },

    ownerRootForNode: function(node) {
      if (!node) {
        return;
      }
      var root = node._ownerShadyRoot;
      if (root === undefined) {
        if (node instanceof Polymer.ShadyDom.ShadyRoot) {
          root = node;
        } else {
          var parent = Tree.Logical.getParentNode(node);
          if (parent) {
            root = parent._isShadyRoot ? parent :
              this.ownerRootForNode(parent);
          } else {
           root = null;
          }
        }
        // memo-ize result for performance but only memo-ize a false-y
        // result if node is in the document. This avoids a problem where a root
        // can be cached while an element is inside a fragment.
        // If this happens and we cache the result, the value can become stale
        // because for perf we avoid processing the subtree of added fragments.
        if (root || document.documentElement.contains(node)) {
          node._ownerShadyRoot = root;
        }
      }
      return root;
    },

    _maybeDistribute: function(node, container, ownerRoot) {
      // TODO(sorvell): technically we should check non-fragment nodes for
      // <content> children but since this case is assumed to be exceedingly
      // rare, we avoid the cost and will address with some specific api
      // when the need arises.  For now, the user must call
      // distributeContent(true), which updates insertion points manually
      // and forces distribution.
      var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
      var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&
        !node.__noContent && 
        insertionPointTag && node.querySelector(insertionPointTag);
      var wrappedContent = fragContent &&
        (Tree.Logical.getParentNode(fragContent).nodeType !==
        Node.DOCUMENT_FRAGMENT_NODE);
      var hasContent = fragContent || (node.localName === insertionPointTag);
      // There are 2 possible cases where a distribution may need to occur:
      // 1. <content> being inserted (the host of the shady root where
      //    content is inserted needs distribution)
      // 2. children being inserted into parent with a shady root (parent
      //    needs distribution)
      if (hasContent) {
        if (ownerRoot) {
          // note, insertion point list update is handled after node
          // mutations are complete
          ownerRoot.update();
        }
      }
      var needsDist = this._nodeNeedsDistribution(container);
      if (needsDist) {
        container.shadyRoot.update();
      }
      // Return true when distribution will fully handle the composition
      // Note that if a content was being inserted that was wrapped by a node,
      // and the parent does not need distribution, return false to allow
      // the nodes to be added directly, after which children may be
      // distributed and composed into the wrapping node(s)
      return needsDist || (hasContent && !wrappedContent);
    },

    /* note: parent argument is required since node may have an out
    of date parent at this point; returns true if a <content> is being added */
    _maybeAddInsertionPoint: function(node, parent, root) {
      var added;
      var insertionPointTag = root.getInsertionPointTag();
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
        !node.__noContent) {
        var c$ = node.querySelectorAll(insertionPointTag);
        for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {
          np = Tree.Logical.getParentNode(n);
          // don't allow node's parent to be fragment itself
          if (np === node) {
            np = parent;
          }
          na = this._maybeAddInsertionPoint(n, np, root);
          added = added || na;
        }
      } else if (node.localName === insertionPointTag) {
        Tree.Logical.saveChildNodes(parent);
        Tree.Logical.saveChildNodes(node);
        added = true;
      }
      return added;
    },

    _nodeNeedsDistribution: function(node) {
      return node && node.shadyRoot &&
        node.shadyRoot.hasInsertionPoint();
    },

    // TODO(sorvell): probably should be push this to the lib
    // a node being added is always in this same host as node.
    _addNodeToHost: function(host, node) {
      if (host._elementAdd) {
        host._elementAdd(node);
      }
    },

    // TODO(sorvell): probably should be push this to the lib
    _removeNodeFromHost: function(host, node) {
      if (host._elementRemove) {
        host._elementRemove(node);
      }
    },

    _removeDistributedChildren: function(root, container) {
      var hostNeedsDist;
      var ip$ = root._insertionPoints;
      for (var i=0; i<ip$.length; i++) {
        var insertionPoint = ip$[i];
        if (this._contains(container, insertionPoint)) {
          var dc$ = insertionPoint.getDistributedNodes();
          for (var j=0; j<dc$.length; j++) {
            hostNeedsDist = true;
            var node = dc$[j];
            var parent = Tree.Composed.getParentNode(node);
            if (parent) {
              Tree.Composed.removeChild(parent, node);
            }
          }
        }
      }
      return hostNeedsDist;
    },

    _contains: function(container, node) {
      while (node) {
        if (node == container) {
          return true;
        }
        node = Tree.Logical.getParentNode(node);
      }
    },

    _removeOwnerShadyRoot: function(node) {
      // optimization: only reset the tree if node is actually in a root
      if (this._hasCachedOwnerRoot(node)) {
        var c$ = Tree.Logical.getChildNodes(node);
        for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {
          this._removeOwnerShadyRoot(n);
        }
      }
      node._ownerShadyRoot = undefined;
    },

    // TODO(sorvell): This will fail if distribution that affects this
    // question is pending; this is expected to be exceedingly rare, but if
    // the issue comes up, we can force a flush in this case.
    firstComposedNode: function(insertionPoint) {
      var n$ = insertionPoint.getDistributedNodes();
      var root = this.ownerRootForNode(insertionPoint);
      for (var i=0, l=n$.length, n, p$; (i<l) && (n=n$[i]); i++) {
        // means that we're composed to this spot.
        if (root.isFinalDestination(insertionPoint, n)) {
          return n;
        }
      }
    },

    clearNode: function(node) {
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
    },

    maybeDistributeParent: function(node) {
      var parent = Tree.Logical.getParentNode(node);
      if (this._nodeNeedsDistribution(parent)) {
        parent.shadyRoot.update();
        return true;
      }
    },

    _getComposedInnerHTML: function(node) {
      return getInnerHTML(node, true);
    },

    // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
    // but it's also generally useful to recurse through the element tree
    // and is used by Polymer's styling system. 
    query: function(node, matcher, halter) {
      var list = [];
      this._queryElements(Tree.Logical.getChildNodes(node), matcher, 
        halter, list);
      return list;
    },

    _queryElements: function(elements, matcher, halter, list) {
      for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && 
            this._queryElement(c, matcher, halter, list)) {
          return true;
        }
      }
    },

    _queryElement: function(node, matcher, halter, list) {
      var result = matcher(node);
      if (result) {
        list.push(node);
      }
      if (halter && halter(result)) {
        return result;
      }
      this._queryElements(Tree.Logical.getChildNodes(node), matcher, 
        halter, list);
    }

  };

  var ElementMixin = {

    appendChild: function(node) {
      return this.insertBefore(node);
    },

    // cases in which we may not be able to just do standard native call
    // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
    // has an insertion point)
    // 2. container is a shadyRoot (don't distribute, instead set
    // container to container.host.
    // 3. node is <content> (host of container needs distribution)
    insertBefore: function(node, ref_node) {
      if (ref_node && Tree.Logical.getParentNode(ref_node) !== this) {
        throw Error('The ref_node to be inserted before is not a child ' +
          'of this node');
      }
      // remove node from its current position iff it's in a tree.
      if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
        var parent = Tree.Logical.getParentNode(node);
        mixinImpl.removeNodeFromParent(node, parent);
      }
      if (!mixinImpl.addNode(this, node, ref_node)) {
        if (ref_node) {
          // if ref_node is an insertion point replace with first distributed node
          // TODO(sorvell): v0/v1!!
          var root = mixinImpl.ownerRootForNode(ref_node);
          if (root) {
            ref_node = ref_node.localName === root.getInsertionPointTag() ?
              mixinImpl.firstComposedNode(ref_node) : ref_node;
          }
        }
        // if adding to a shadyRoot, add to host instead
        var container = this instanceof Polymer.ShadyDom.ShadyRoot ? 
          this.host : this;
        if (ref_node) {
          Tree.Composed.insertBefore(container, node, ref_node);
        } else {
          Tree.Composed.appendChild(container, node);
        }
      }
      // TODO(sorvell): notify
      //this.notifyObserver();
      return node;
    },

    /**
      Removes the given `node` from the element's `lightChildren`.
      This method also performs dom composition.
    */
    removeChild: function(node) {
      if (Tree.Logical.getParentNode(node) !== this) {
        throw Error('The node to be removed is not a child of this node: ' +
          node);
      }
      if (!mixinImpl.removeNode(node)) {
        // if removing from a shadyRoot, remove form host instead
        var container = this instanceof Polymer.ShadyDom.ShadyRoot ?
          this.host : 
          this;
        // not guaranteed to physically be in container; e.g.
        // undistributed nodes.
        var parent = Tree.Composed.getParentNode(node);
        if (container === parent) {
          Tree.Composed.removeChild(container, node);
        }
      }
      // TODO(sorvell): notify
      //this.notifyObserver();
      return node;
    },

    replaceChild: function(node, ref_node) {
      this.insertBefore(node, ref_node);
      this.removeChild(ref_node);
      return node;
    },

    // TODO(sorvell): consider doing native QSA and filtering results.
    querySelector: function(selector) {
      // match selector and halt on first result.
      var result = mixinImpl.query(this, function(n) {
        return Polymer.ShadyDom.matchesSelector(n, selector);
      }, function(n) {
        return Boolean(n);
      })[0];
      return result || null;
    },

    querySelectorAll: function(selector) {
      return mixinImpl.query(this, function(n) {
        return Polymer.ShadyDom.matchesSelector(n, selector);
      });
    },

    getDestinationInsertionPoints: function() {
      return this._destinationInsertionPoints || [];
    },

    getDistributedNodes: function() {
      return this._distributedNodes || [];
    },

    getAssignedNodes: function() {
      return this._assignedNodes || [];
    },


    setAttribute: function(name, value) {
      nativeSetAttribute.call(this, name, value);
      mixinImpl.maybeDistributeParent(this);
    },

    removeAttribute: function(name) {
      nativeRemoveAttribute.call(this, name);
      mixinImpl.maybeDistributeParent(this);
    },

    cloneNode: function(deep) {
      var n = nativeCloneNode.call(this, false);
      if (deep) {
        var c$ = this.childNodes;
        for (var i=0, nc; i < c$.length; i++) {
          nc = c$[i].cloneNode(true);
          n.appendChild(nc);
        }
      }
      return n;
    },

    importNode: function(externalNode, deep) {
      // for convenience use this node's ownerDoc if the node isn't a document
      var doc = this instanceof Document ? this :
        this.ownerDocument;
      var n = nativeImportNode.call(doc, externalNode, false);
      if (deep) {
        var c$ = Tree.Logical.getChildNodes(externalNode);
        var d = dom(n);
        for (var i=0, nc; i < c$.length; i++) {
          nc = doc.importNode(c$[i], true);
          d.appendChild(nc);
        }
      }
      return n;
    }

  };

  // accessors...
  Object.defineProperties(ElementMixin, {

    activeElement: {
      get() {
        var active = document.activeElement;
        if (!active) {
          return null;
        }
        var isShadyRoot = !!(this instanceof Polymer.ShadyDom.ShadyRoot);
        if (this !== document) {
          // If this node isn't a document or shady root, then it doesn't have
          // an active element.
          if (!isShadyRoot) {
            return null;
          }
          // If this shady root's host is the active element or the active
          // element is not a descendant of the host (in the composed tree),
          // then it doesn't have an active element.
          if (this.host === active ||
              !this.host.contains(active)) {
            return null;
          }
        }
        // This node is either the document or a shady root of which the active
        // element is a (composed) descendant of its host; iterate upwards to
        // find the active element's most shallow host within it.
        var activeRoot = mixinImpl.ownerRootForNode(active);
        while (activeRoot && activeRoot !== this) {
          active = activeRoot.host;
          activeRoot = mixinImpl.ownerRootForNode(this);
        }
        if (this === document) {
          // This node is the document, so activeRoot should be null.
          return activeRoot ? null : active;
        } else {
          // This node is a non-document shady root, and it should be
          // activeRoot.
          return activeRoot === this ? active : null;
        }
      },
      configurable: true
    },

    shadowRoot: {
      get() { 
        return this.shadyRoot;
      }
    },

    childNodes: {
      get() {
        var c$ = Tree.Logical.getChildNodes(this);
        return Array.isArray(c$) ? c$ : Tree.arrayCopyChildNodes(this);
      },
      configurable: true
    },

    children: {
      get() {
        if (Tree.Logical.hasChildNodes(this)) {
          return Array.prototype.filter.call(this.childNodes, function(n) {
            return (n.nodeType === Node.ELEMENT_NODE);
          });
        } else {
          return Tree.arrayCopyChildren(this);
        }
      },
      configurable: true
    },

    parentElement: {
      get() {
        return Tree.Logical.getParentNode(this);
      },
      configurable: true
    },

    parentNode: {
      get() {
        return Tree.Logical.getParentNode(this);
      },
      configurable: true
    },

    firstChild: {
      get() {
        return Tree.Logical.getFirstChild(this);
      },
      configurable: true
    },

    lastChild: {
      get() {
        return Tree.Logical.getLastChild(this);
      },
      configurable: true
    },

    nextSibling: {
      get() {
        return Tree.Logical.getNextSibling(this);
      },
      configurable: true
    },

    previousSibling: {
      get() {
        return Tree.Logical.getPreviousSibling(this);
      },
      configurable: true
    },

    firstElementChild: {
      get() {
        return Tree.Logical.getFirstElementChild(this);
      },
      configurable: true
    },

    lastElementChild: {
      get() {
        return Tree.Logical.getLastElementChild(this);
      },
      configurable: true
    },

    nextElementSibling: {
      get() {
        return Tree.Logical.getNextElementSibling(this);
      },
      configurable: true
    },

    previousElementSibling: {
      get() {
        return Tree.Logical.getPreviousElementSibling(this);
      },
      configurable: true
    },

    // textContent / innerHTML
    // TODO(sorvell): how to do this?
    textContent: {
      get() {
        if (this.childNodes) {
          var tc = [];
          for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }
        return '';
      },
      set(text) {
        mixinImpl.clearNode(this);
        if (text) {
          this.appendChild(document.createTextNode(text));
        }
      },
      configurable: true
    },

    innerHTML: {
      get() {
        return getInnerHTML(this);
      },
      set(text) {
        mixinImpl.clearNode(this);
        var d = document.createElement('div');
        d.innerHTML = text;
        // here, appendChild may move nodes async so we cannot rely
        // on node position when copying
        var c$ = Tree.arrayCopyChildNodes(d);
        for (var i=0; i < c$.length; i++) {
          this.appendChild(c$[i]);
        }
      },
      configurable: true
    }

  });

  Polymer.ShadyDom.ElementMixin = ElementMixin;

})();
</script>
