<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="tree.html">
<link rel="import" href="element-mixin.html">
<script>

/**
 * Patches elements that interacts with ShadyDOM
 * such that tree traversal and mutation apis act like they would under
 * ShadowDOM.
 *
 * This import enables seemless interaction with ShadyDOM powered
 * custom elements, enabling better interoperation with 3rd party code,
 * libraries, and frameworks that use DOM tree manipulation apis.
 */

(function() {

  'use strict';

  var Tree = ShadyDom.Tree;
  var Mixins = ShadyDom.Mixins;

  ShadyDom.patchedCount = 0;

  ShadyDom.patch = function(node) {
    if (!ShadyDom.inUse) {
      return;
    }
    if (!node.__patched && patchImpl.canPatchNode(node)) {
      Tree.saveChildNodes(node);
      patchImpl.patch(node);
    }
  };

  ShadyDom.unpatch = function(node) {
    patchImpl.unpatch(node);
  };

  ShadyDom.isPatched = function(node) {
    return Boolean(node.__patched);
  }

  var log = false;

  var patchImpl = {

    canPatchNode: function(node) {
      switch (node) {
        case document.head:
        case document.documentElement:
          return false;
        default:
          return true;
      }
    },

    hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(
      Node.prototype, 'textContent')),

    protoCache: {},

    patch: function(node) {
      ShadyDom.patchedCount++;
      log && console.warn('patch node', node);
      Tree.Composed.saveComposedData(node);
      if (this.hasPrototypeDescriptors) {
        var proto = this.prototypeForObject(node);
        if (proto) {
          node.__proto__ = proto;
        }
      } else {
        console.warn('Patching instance rather than prototype', node);
        this.patchObject(node, this.mixinForNode(node));
      }
    },

    mixinForObject: function(obj) {
      switch (obj.nodeType) {
        case Node.ELEMENT_NODE:
          return Mixins.Element;
        case Node.DOCUMENT_FRAGMENT_NODE:
          return Mixins.Fragment;
        case Node.DOCUMENT_NODE:
          return Mixins.Document;
        case Node.TEXT_NODE:
        case Node.COMMENT_NODE:
          return Mixins.Node;
      }
      if (obj instanceof ShadyDom.origEvent) {
        return Mixins.Event;
      }
    },

    prototypeForObject: function(obj) {
      var proto = obj.__proto__;
      if (!proto.hasOwnProperty('__patchProto')) {
        var patchProto = null;
        var mixin = this.mixinForObject(obj);
        if (mixin) {
          patchProto = Object.create(proto);
          patchProto.__sourceProto = proto;
          this.patchObject(patchProto, mixin);
        }
        proto.__patchProto = patchProto;
      }
      return proto.__patchProto;
    },

    patchObject: function(object, patchProto) {
      ShadyDom.extend(object, patchProto);
      return object;
    },

    unpatch: function(obj) {
      if (obj.__sourceProto) {
        obj.__proto__ = obj.__sourceProto;
      }
    }

  };

  ShadyDom.patchImpl = patchImpl;

  var createRootAndEnsurePatched = function(node, useV0) {
    // TODO(sorvell): need to ensure ancestors are patched but this introduces
    // a timing problem with gathering composed children.
    // (1) currently the child list is crawled and patched when patching occurs
    // (this needs to change)
    // (2) we can only patch when an element has received its parsed children
    // because we cannot detect them when inserted by parser.
    // var ancestor = node;
    // while (ancestor) {
    //   ShadyDom.patch(ancestor);
    //   ancestor = ancestor.parentNode || ancestor.host;
    // }
    ShadyDom.patch(node);
    var root = new ShadyDom.ShadyRoot(node, useV0);
    ShadyDom.patch(root);
    return root;
  }

  function patchEvents() {
    Node.prototype.addEventListener = ShadyDom.addEventListener;
    Node.prototype.removeEventListener = ShadyDom.removeEventListener;
    window.Event = ShadyDom.PatchedEvent;
    window.CustomEvent = ShadyDom.PatchedCustomEvent;
    window.MouseEvent = ShadyDom.PatchedMouseEvent;
  }

  if (ShadyDom.force || !Element.prototype.createShadowRoot) {

    // NOTE: transparent at the cost of intrusiveness.
    Element.prototype.createShadowRoot = function() {
      return createRootAndEnsurePatched(this, true);
    }

    patchEvents();
  }

  if (ShadyDom.force || !Element.prototype.attachShadow) {

    Element.prototype.attachShadow = function() {
      return createRootAndEnsurePatched(this);
    }

    patchEvents();
  }

  // TODO(sorvell): super experimental auto patching of document fragment
  // via appendChild. This either needs to be expanded or contracted.
  // DocumentFragment.prototype.appendChild = function(node) {
  //   ShadyDom.patch(this);
  //   return this.appendChild(node);
  // }

})();

</script>
