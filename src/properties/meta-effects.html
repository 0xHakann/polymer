<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="batched-effects.html">

<script>
(function() {

  'use strict';

  Polymer.MetaEffects = Polymer.Utils.dedupingMixin(function(superClass) {

    return class MetaEffects extends Polymer.BatchedEffects(superClass) {

      _clearPropagateEffects() {
        this._propagateEffects = {};
      }

      _createPropertyFromInfo(name, info) {
        // computed forces readOnly...
        if (info.computed) {
          info.readOnly = true;
        }
        // readOnly, computed, reflect, notify only if not already doing so...
        if (info.readOnly && !this._hasReadOnlyEffect(name)) {
          this._createReadOnlyProperty(name, !info.computed);
        }
        if (info.computed && !this._hasComputedEffect(name)) {
          this._createComputedProperty(name, info.computed);
        }
        if (info.reflectToAttribute && !this._hasReflectEffect(name)) {
          this._createReflectedProperty(name);
        }
        if (info.notify && !this._hasNotifyEffect(name)) {
          this._createNotifyingProperty(name);
        }
        // always add observer
        if (info.observer) {
          this._createObservedProperty(name, info.observer);
        }
      }

      _setPropertyDefaults(properties) {
        if (!properties) {
          return;
        }
        var p, info;
        for (p in properties) {
          info = properties[p];
          if (('value' in info) && !this._isPropertyPending(p)) {
            var value = typeof info.value == 'function' ?
              info.value.call(this) :
              info.value;
            if (this._hasReadOnlyEffect(p)) {
              this._setProperty(p, value)
            } else {
              this[p] = value;
            }
          }
        }
      }

    }

  });

})();
</script>
