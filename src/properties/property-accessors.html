<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/case-map.html">

<script>
(function() {

  'use strict';

  class PropertyAccessors {

    createAccessor(model, property, readOnly) {
      model = this.getModel(model);
      var val;
      // model is normally a prototype; to support dynamically adding accessors
      // to instances which may already have values set on them, we read the
      // value first and set it into the accessor after creation
      if (model.hasOwnProperty(property)) {
        val = model[property];
      }
      var lib = this;
      Object.defineProperty(model, property, {
        get: function() {
          return this.__data && this.__data[property];
        },
        set: readOnly ? function() { } : function(value) {
          lib.setProperty(this, property, value);
        }
      });
      if (val !== undefined) {
        model[property] = val;
      }
    }

    getModel(model) {
      return typeof model == 'function' ? model.prototype : model;
    }

    createAcessorsForAttributes(model, attrs) {
      var attrs = attrs || model.observedAttributes;
      if (attrs) {
        for (var i=0; i<attrs.length; i++) {
          var property = Polymer.CaseMap.dashToCamelCase(attrs[i]);
          this.createAccessor(model, property);
        }
      }
    }

    setProperty(inst, property, value) {
      if (this.setPendingProperty(inst, property, value)) {
        this.invalidate(inst);
      }
    }

    setPendingProperty(inst, property, value) {
      if (!inst.__data) {
        inst.__data = {};
        inst.__dataPending = {};
        inst.__dataOld = {};
      }
      var old = inst.__data[property];
      if (this.shouldPropChange(value, old)) {
        // Ensure old is captured from the last turn
        if (!(property in inst.__dataPending)) {
          inst.__dataOld[property] = old;
        }
        inst.__data[property] = value;
        inst.__dataPending[property] = value;
        return true;
      }
    }

    invalidate(inst) {
      if (!inst.__dataInvalid) {
        inst.__dataInvalid = true;
        Promise.resolve().then(() => {
          if (inst.__dataInvalid) {
            inst.__dataInvalid = false;
            this.flush(inst)
          }
        });
      }
    }

    flush(inst) {
      var oldProps = inst.__dataOld;
      var changedProps = inst.__dataPending;
      inst.__dataPending = {};
      inst.__dataOld = {};
      if (inst.validate) {
        inst.validate(inst.__data, oldProps, changedProps);
      } else {
        this.validate(inst, inst.__data, oldProps, changedProps);
      }
    }

    validate(inst, props, oldProps, changedProps) {
    }

    shouldPropChange(value, old) {
      return ((old !== value && (old === old || value === value)) ||
        (typeof value == 'object'));
    }

  }

  // export
  Polymer.PropertyAccessors = PropertyAccessors;

})();
</script>
