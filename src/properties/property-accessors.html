<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>
(function() {

  'use strict';
  class PropertyAccessors {

    createAccessor(model, property, readOnly) {
      model = this.getModel(model);
      this._ensureEffects(model, '_propertyEffects');
      var effects = model._propertyEffects[property];
      if (!effects || readOnly) {
        effects = effects || (model._propertyEffects[property] = []);
        this._createAccessor(model, property, readOnly);
      }
      return effects;
    }

    addPropertyEffect(model, property, effect) {
      var root = this._rootForPath(property);
      effect.path = property;
      this.createAccessor(model, root).push(effect);
    }

    getModel(model) {
      return typeof model == 'function' ? model.prototype : model;
    }

    _ensureEffects(model, name) {
      var effects = model[name];
      if (!effects) {
        effects = model[name] = {};
      } else if (!model.hasOwnProperty(name)) {
        effects = model[name] = Object.create(model[name]);
        for (var p in effects) {
          // TODO(kschaaf): replace with fast array copy #!%&$!
          effects[p] = effects[p].slice();
        }
      }
      return effects;
    }

    _createAccessor(model, property, readOnly) {
      // TODO(sorvell): kosher to bail here if an accessor already exists?
      if (!readOnly && model.hasOwnProperty(property)) {
        console.warn('Accessor already exists for', property, 'on', model);
        return;
      }
      var self = this;
      var defun = {
        get: function() {
          // TODO(sjmiles): elide delegation for performance, good ROI?
          return this.__data__ && this.__data__[property];
        }
      };
      var setter = function(value) {
        self._propertySetter(this, property, value);
      };
      if (readOnly) {
        model['_set' + this._upper(property)] = setter;
      } else {
        defun.set = setter;
      }
      Object.defineProperty(model, property, defun);
    }

    _upper(name) {
      return name[0].toUpperCase() + name.substring(1);
    }

    _propertySetter(inst, property, value) {
      if (!inst.__data__) {
        inst.__data__ = {};
      }
      var old = inst.__data__[property];
      if (this.isPropertyDirty(value, old)) {
        inst.__data__[property] = value;
        var rootProperty = this._rootForPath(property);
        var effects = inst._propertyEffects[rootProperty];
        if (effects) {
          this._runEffects(inst, property, value, old, effects);
        }
      }
      return old;
    }

    _runEffects(inst, property, value, old, effects) {
      for (var i=0, l=effects.length, fx; (i<l) && (fx=effects[i]); i++) {
        if (this._pathMatchesEffect(property, fx)) {
          fx.fn.call(inst, property, value, old, fx.info);
        }
      }
    }

    _pathMatchesEffect(path, effect) {
      var effectArg = effect.path;
      return (effectArg == path) ||
        (effectArg.indexOf(path + '.') === 0) ||
        (/* effect.trigger.wildcard && */ path.indexOf(effectArg) === 0);
    }

    _rootForPath(path) {
      var dot = path.indexOf('.');
      return (dot < 0) ? path : path.slice(0, dot);
    }

    isPropertyDirty(value, old) {
      return ((old !== value && (old === old || value === value)) ||
        (typeof value == 'object'));
    }

  };

  // export
  Polymer.PropertyAccessors = PropertyAccessors;

})();
</script>
