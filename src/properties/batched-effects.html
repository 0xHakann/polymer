<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="property-effects.html">

<script>
(function() {

  'use strict';

  class BatchedEffects extends Polymer.PropertyEffects {

    constructor(templateStamp, attributes, annotations) {
      super(attributes, annotations);
      this._currentEffects = null;
      // Not a correct assign polyfill-- only use where proto's don't matter!
      // _mixin: Object.assign ? Object.assign : Polymer.Utils.mixin,
      this._mixin = Polymer.Utils.mixin;
      this._effectUid = 0;
      this.templateStamp = templateStamp ||
        (Polymer.TemplateStamp && new Polymer.TemplateStamp());
      // arguments are required
      if (!this.templateStamp) {
        throw 'PropertyEffects constructor requires `templateStamp` delegate.';
      }
    }

    addPropertyEffect(model, property, effect) {
      model = this.getModel(model);
      if (!model.setProperties) {
        var lib = this;
        model.setProperties = function(props, fromAbove) {
          lib.setProperties(this, props, fromAbove);
        };
        model.set = model.notifyPath = function(prop, value) {
          lib.set(this, prop, value);
        };
      }
      super.addPropertyEffect.apply(this, arguments);
      if (this._currentEffects) {
        var effects = this._currentEffects[property] ||
          (this._currentEffects[property] = []);
        effects.push(effect);
      }
    }

    _accumulateEffects(model, name, fn, args) {
      model = this.getModel(model);
      this._currentEffects = this._ensureEffects(model, name);
      fn.apply(this, args);
      this._currentEffects = null;
    }

    // -- read only ----------------------------------------------

    createReadOnlyProperty(model, property) {
      model = this.getModel(model);
      super.createReadOnlyProperty.apply(this, arguments);
      this._ensureEffects(model, '_isReadOnly')[property] = true;
    }

    // -- observer ----------------------------------------------

    createObserver(model) {
      this._accumulateEffects(model, '_observerEffects',
        super.createObserver, arguments);
    }

    // -- notify ----------------------------------------------

    createNotifyingProperty(model) {
      this._accumulateEffects(model, '_notifyEffects',
        super.createNotifyingProperty, arguments);
    }

    // -- reflect ----------------------------------------------

    createReflectedProperty(model) {
      this._accumulateEffects(model, '_annotationEffects',
        super.createReflectedProperty, arguments);
    }

    // -- complexObserver ----------------------------------------------

    createMultiObserver(model) {
      this._accumulateEffects(model, '_observerEffects',
        super.createMultiObserver, arguments);
    }

    // -- computed ----------------------------------------------

    createComputedProperty(model) {
      this._accumulateEffects(model, '_computedEffects',
        super.createComputedProperty, arguments);
    }

    // -- annotation ----------------------------------------------

    bindTemplate(model, template) {
      this._accumulateEffects(model, '_annotationEffects',
        super.bindTemplate, [model, template]);
    }

    // -- set properties machinery

    setProperties(inst, props, fromAbove) {
      // Dirty check / filter props with effects
      this._setPendingProperties(inst, props);
      if (inst._propertyEffectsActive) {
        this._processPendingProperties(inst, fromAbove);
      }
    }

    _propertySetter(inst, prop, value) {
      this._setPendingProperty(inst, prop, value);
      if (inst._propertyEffectsActive) {
        this._processPendingProperties(inst, false);
      }
    }

    _setPendingProperties(inst, props) {
      for (var prop in props) {
        this._setPendingProperty(inst, prop, props[prop]);
      }
    }

    _setPendingProperty(inst, prop, value, host) {
      var rootProperty = this._rootForPath(prop);
      if (!inst._propertyEffects[rootProperty]) {
        this._set(inst, prop, value);
      } else if (this.isPropertyDirty(inst[prop], value)) {
        if (rootProperty !== prop) {
          //TODO(kschaaf): ideally this only happens once on entry
          this._set(inst, prop, value);
        }
        inst.__pendingData = inst.__pendingData || {};
        inst.__pendingData[prop] = value;
        inst.__data = inst.__data || {};
        inst.__data[prop] = value;
        if (host) {
          host.__pendingClients.set(inst, true);
        }
      }
    }

    _processPendingProperties(inst, fromAbove) {
      var runId = (inst._runId = ((inst._runId || 0) + 1));
      var props = inst.__pendingData;
      if (props || inst.__interimData) {
        // Setup client property queueing
        inst.__pendingClients = inst.__pendingClients || new Map();
        inst.__pendingData = {};
        // Run computed effects
        var inputProps = props;
        var computedProps;
        while (this._runEffects(inst, inst._computedEffects, inputProps)) {
          this._mixin(props, inst.__pendingData);
          computedProps = this._mixin(computedProps || {}, inst.__pendingData);
          inputProps = inst.__pendingData;
          inst.__pendingData = {};
        }
        // Notify
        inst.__interimData = inst.__interimData ?
          this._mixin(inst.__interimData, props) : props;
        // avoid notifications unless active
        if (inst._propertyEffectsActive) {
          this.notifyProperties(inst, fromAbove ? computedProps : props);
        }
        // Re-entry protection; only run the last time through
        if (runId == inst._runId) {
          props = inst.__interimData;
          // Run annotation effects
          this._runEffects(inst, inst._annotationEffects, props);
          // Recurse to clients
          this._flushPropClients(inst);
          // avoid observers unless active
          if (inst._propertyEffectsActive) {
            inst.__interimData = null;
            // Run observer effects
            this._runEffects(inst, inst._observerEffects, props);
          }
        }
      }
      return props;
    }

    _flushPropClients(inst) {
      var lib = this;
      inst.__pendingClients.forEach(function(v, client) {
        if (client._propertyEffectsActive) {
          lib._processPendingProperties(client, true);
        }
      });
      inst.__pendingClients = null;
    }

    set(inst, path, value) {
      path = Array.isArray(path) ? path.join('.') : path;
      this._propertySetter(inst, path, value);
    }

    notifyProperties(inst, props) {
      if (props) {
        var host = inst.dataHost;
        if (host && host.setProperties) {
          this._setNotifyProperties(inst, host, props);
        } else {
          this._dispatchNotifyProperties(inst, props);
        }
      }
    }

    _dispatchNotifyProperties(inst, props) {
      var fx = inst._notifyEffects;
      for (var prop in props) {
        if ((fx && fx[prop]) || this._rootForPath(prop) !== prop) {
          inst.dispatchEvent(
            new CustomEvent(prop + '-changed', {value: props[prop]}));
        }
      }
    }

    _setNotifyProperties(inst, host, props) {
      var fx = inst._notifyEffects;
      var hostProps = {};
      for (var prop in props) {
        var val = props[prop];
        var rootProperty = this._rootForPath(prop);
        var hostPath = inst._hostBindings && inst._hostBindings[rootProperty];
        if (hostPath && ((fx && fx[rootProperty]) || rootProperty !== prop)) {
          prop = this._fixPath(hostPath, rootProperty, prop);
          hostProps[prop] = val;
        }
      }
      this.setProperties(host, hostProps);
    }

    _addNotifyListener(node, inst, info) {
      if (!node.setProperties) {
        super._addNotifyListener.apply(this, arguments);
      } else {
        node._hostBindings = node._hostBindings || {};
        node._hostBindings[info.property] = info.path;
      }
    }

    _setPropertyToNode(model, node, prop, value) {
      if (node.setProperties) {
        this._setPendingProperty(node, prop, value, model);
      } else {
        node[prop] = value;
      }
    }

    _runEffects(inst, effects, props) {
      var ran;
      if (effects) {
        var id = this._effectUid++;
        for (var prop in props) {
          var val = props[prop];
          var rootProperty = this._rootForPath(prop);
          var fxs = effects[rootProperty];
          if (fxs) {
            for (var i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
              if (this._pathMatchesEffect(prop, fx) &&
                (!fx.info || fx.info.lastRun !== id)) {
                fx.fn.call(inst, prop, val, undefined, fx.info);
                fx.info.lastRun = id;
                ran = true;
              }
            }
          }
        }
      }
      return ran;
    }

    // TODO(sorvell): lazy property support
    // note: had this in enablePropertyEffects, but templatizer.
    recordInstanceProperties(inst) {
      for (var p in inst._propertyEffects) {
        if (inst.hasOwnProperty(p)) {
          var value = inst[p];
          delete inst[p];
          inst[p] = value;
        }
      }
    }

    enablePropertyEffects(inst) {
      inst._propertyEffectsActive = true;
      // TODO(sorvell): this cannot be fromAbove true, becuase notifications of
      // default values will not be seen.
      //this._processPendingProperties(inst, true);
      this._processPendingProperties(inst);
    }

    stamp(template, inst) {
      if (!this.templateStamp) {
        console.warn(`In order to call \`stamp\` a template stamping delegate is
          required`);
        return;
      }
      inst.__pendingClients = new Map();
      var dom = this.templateStamp.stamp(template, inst);
      this.setupBindings(inst, dom, template.content._notes);
      // NOTE: We must propagate data down to clients right after 
      // stamping and before `enablePropertyEffects` is called.
      this._processPendingProperties(inst, true);
      return dom;
    }

    // overridden from propertyEffects
    _runComputedEffect(property, value, old, info) {
      var result = info.lib._runMethodEffect(this, property, value, old, info);
      var computedProp = info.methodInfo;
      info.lib._setPendingProperty(this, computedProp, result);
    }

  }

  // export
  Polymer.BatchedEffects = BatchedEffects;

})();
</script>
