<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="property-effects.html">

<script>
(function() {

  'use strict';

  class BatchedEffects extends Polymer.PropertyEffects {

    constructor(templateStamp, attributes, annotations) {
      super(attributes, annotations);
      this._mixin = Polymer.Utils.mixin;
      this._effectUid = 0;
      this.templateStamp = templateStamp ||
        (Polymer.TemplateStamp && new Polymer.TemplateStamp());
      // arguments are required
      if (!this.templateStamp) {
        throw 'PropertyEffects constructor requires `templateStamp` delegate.';
      }
    }

    addPropertyEffect(model, property, effect) {
      model = this.getModel(model);
      if (!model.setProperties) {
        var lib = this;
        model.setProperties = function(props, fromAbove) {
          lib.setProperties(this, props, fromAbove);
        };
        model.set = model.notifyPath = function(path, value) {
          lib.set(this, path, value);
        };
        model.get = function(path) {
          lib.get(this, path)
        }
      }
      super.addPropertyEffect.apply(this, arguments);
    }

    // -- set properties machinery

    setProperties(inst, props) {
      for (var prop in props) {
        if (!inst._readOnly || !inst._readOnly[prop]) {
          this.setPendingProperty(inst, prop, props[prop]);
        }
      }
      if (inst.__dataInitialized) {
        if (inst.asyncEffects) {
          this.invalidate(inst);
        } else {
          this.flush(inst);
        }
      }
    }

    setProperty(inst, prop, value) {
      this.setPendingProperty(inst, prop, value);
      if (inst.__dataInitialized) {
        if (inst.asyncEffects) {
          this.invalidate(inst);
        } else {
          this.flush(inst);
        }
      }
    }

    setPendingProperty(inst, prop, value) {
      var rootProperty = this._rootForPath(prop);
      if (!inst._propertyEffects[rootProperty]) {
        this._set(inst, prop, value);
      } else if (rootProperty !== prop) {
        this._set(inst, prop, value);
      }
      return super.setPendingProperty(inst, prop, value);
    }

    flush(inst, fromAbove) {
      if (!inst.__dataInitialized) {
        inst.__dataInitialized = true;
        if (inst.__dataCallback) {
          inst.__dataCallback();
        }
      }
      if (inst.__dataPending || inst.__dataPendingClients) {
        inst.__dataFromAbove = inst.__dataFromAbove || fromAbove;
        super.flush(inst);
        inst.__dataFromAbove = false;
      }
    }

    validate(inst, currentProps, oldProps, changedProps) {
      // Compute
      var computedProps = this._runComputedEffects(inst, changedProps, oldProps);
      // Notify
      var props = this._notifyProperties(inst, changedProps, computedProps, oldProps);
      if (props) {
        oldProps = props.oldProps;
        changedProps = props.changedProps;
        // Propagate
        this._runPropagationEffects(inst, changedProps);
        // Observe
        this._runEffects(inst, Types.OBSERVE, changedProps, oldProps);
      }
    }

    _runComputedEffects(inst, changedProps, oldProps) {
      if (inst[Types.COMPUTE]) {
        var inputProps = changedProps;
        var computedProps;
        while (this._runEffects(inst, Types.COMPUTE, inputProps)) {
          this._mixin(oldProps, inst.__dataOld);
          this._mixin(changedProps, inst.__dataPending);
          computedProps = this._mixin(computedProps || {}, inst.__dataPending);
          inputProps = inst.__dataPending;
          inst.__dataPending = null;
        }
        return computedProps;
      }
    }

    _runPropagationEffects(inst, changedProps) {
      inst.__dataPendingClients = inst.__dataPendingClients || new Map();
      // Propagate pending changes to clients
      this._runEffects(inst, Types.PROPAGATE, changedProps);
      // Flush all clients
      var self = this;
      inst.__dataPendingClients.forEach(function(v, client) {
        self.flush(client, true);
      });
      inst.__dataPendingClients = null;
    }

    // Cannot name class method `set` or `get` in class due to Safari ES6 implementation
    // Patched into the prototype as after this class definition
    __set(inst, path, value) {
      path = Array.isArray(path) ? path.join('.') : path;
      this.setProperty(inst, path, value);
    }

    __get(inst, path) {
      path = Array.isArray(path) ? path.join('.') : path;
      this._get(inst, path);
    }

    _notifyProperties(inst, changedProps, computedProps, oldProps) {
      var props = inst.__dataFromAbove ? computedProps : changedProps;
      var runId = (inst._runId = ((inst._runId || 0) + 1));
      inst.__dataInterim = inst.__dataInterim ?
        this._mixin(inst.__dataInterim, changedProps) : changedProps;
      inst.__dataInterimOld = inst.__dataInterimOld ?
        this._mixin(inst.__dataInterimOld, oldProps) : oldProps;
      var host = inst.dataHost;
      if (host && host.setProperties) {
        this._setNotifyProperties(inst, host, props);
      } else {
        this._dispatchNotifyProperties(inst, props);
      }
      if (runId == inst._runId) {
        changedProps = inst.__dataInterim;
        oldProps = inst.__dataInterimOld;
        inst.__dataInterim = null;
        inst.__dataInterimOld = null;
        return {changedProps: changedProps, oldProps: oldProps};
      }
    }

    _dispatchNotifyProperties(inst, props) {
      var fx = inst._notifyEffects;
      for (var prop in props) {
        var rootProperty = this._rootForPath(prop);
        var info = fx && fx[rootProperty] && fx[rootProperty][0].info;
        if (info || rootProperty !== prop) {
          this._dispatchNotification(inst, info, prop, props[prop]);
        }
      }
    }

    _dispatchNotification(inst, info, prop, value) {
      var event = (info && info.eventName) ||
        Polymer.CaseMap.camelToDashCase(prop) + '-changed';
      inst.dispatchEvent(new CustomEvent(event, {
        bubbles: false,
        detail: { value: value }
      }));
    }

    _setNotifyProperties(inst, host, props) {
      var fx = inst._notifyEffects;
      var hostProps;
      for (var prop in props) {
        var val = props[prop];
        var rootProperty = this._rootForPath(prop);
        var info = fx && fx[rootProperty] && fx[rootProperty][0].info;
        if (info || rootProperty !== prop) {
          var hostBinding = inst._hostBindings && inst._hostBindings[rootProperty];
          if (hostBinding) {
            prop = this._fixPath(hostBinding.path, rootProperty, prop);
            hostProps = hostProps || {};
            hostProps[prop] = hostBinding.negate ? !val : val;
          } else {
            this._dispatchNotification(inst, info, prop, val);
          }
        }
      }
      if (hostProps) {
        this.setProperties(host, hostProps);
      }
    }

    _addNotifyListener(node, inst, info) {
      if (!node.setProperties) {
        super._addNotifyListener.apply(this, arguments);
      }
      node._hostBindings = node._hostBindings || {};
      node._hostBindings[info.property] = info;
    }

    _setPropertyToNode(model, node, prop, value) {
      if (node.setProperties) {
        if (this.setPendingProperty(node, prop, value)) {
          model.__dataPendingClients.set(node, true);
        }
      } else {
        node[prop] = value;
      }
    }

    _runEffects(inst, type, props, oldProps) {
      var ran;
      var effects = inst[type];
      if (effects) {
        var id = this._effectUid++;
        for (var prop in props) {
          var val = props[prop];
          var rootProperty = this._rootForPath(prop);
          var fxs = effects[rootProperty];
          if (fxs) {
            for (var i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
              if (this._pathMatchesEffect(prop, fx) &&
                (!fx.info || fx.info.lastRun !== id)) {
                fx.fn.call(inst, prop, val, oldProps && oldProps[prop], fx.info, inst.__dataFromAbove);
                if (fx.info) {
                  fx.info.lastRun = id;
                }
                ran = true;
              }
            }
          }
        }
      }
      return ran;
    }

    prepare(inst, callback) {
      inst.__dataCallback = callback;
      if (inst.__dataProto) {
        inst.__data = Object.create(inst.__dataProto);
        inst.__dataPending = Object.create(inst.__dataProto);
        inst.__dataOld = {};
      }
      this.recordInstanceProperties(inst);
      // ensure element enables & flushes even if disconnected
      // this.enqueueFlush(inst);
    }

    enqueueFlush(inst) {
      if (!this.flushQueue) {
        this.flushQueue = [inst];
        var self = this;
        Promise.resolve().then(function() {
          self.flushFlushQueue();
        });
      } else {
        this.flushQueue.push(inst);
      }
    }

    flushFlushQueue() {
      var q = this.flushQueue;
      this.flushQueue = null;
      for (var i=0; i<q.length; i++) {
        this.flush(q[i]);
      }
    }

    recordInstanceProperties(inst) {
      for (var p in inst._propertyEffects) {
        if (inst.hasOwnProperty(p)) {
          var value = inst[p];
          delete inst[p];
          inst[p] = value;
        }
      }
    }

    stamp(inst, template) {
      var dom = this.templateStamp.stamp(inst, template);
      var notes = (template._content || template.content)._notes;
      this.setupBindings(inst, dom, notes);
      inst.__dataPendingClients = new Map();
      if (inst._nodes) {
        for (var i=0; i<inst._nodes.length; i++) {
          inst.__dataPendingClients.set(inst._nodes[i], true);
        }
      }
      return dom;
    }

    // overridden from propertyEffects
    _runComputedEffect(property, value, old, info) {
      var result = info.lib._runMethodEffect(this, property, value, old, info);
      var computedProp = info.methodInfo;
      info.lib.setPendingProperty(this, computedProp, result);
    }

  }

  var Types = BatchedEffects.Types;

  // NOTE: Safari can't deal with an ES6 style function named `set` or `get`
  BatchedEffects.prototype.set = BatchedEffects.prototype.__set;
  BatchedEffects.prototype.get = BatchedEffects.prototype.__get;

  // export
  Polymer.BatchedEffects = BatchedEffects;

})();
</script>
