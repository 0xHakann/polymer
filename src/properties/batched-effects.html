<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/path.html">
<link rel="import" href="property-effects.html">

<script>
(function() {

  'use strict';

  class BatchedEffects extends Polymer.PropertyEffects {

    constructor(templateStamp, attributes, annotations) {
      super(attributes, annotations);
      this._mixin = Polymer.Utils.mixin;
      this._effectUid = 0;
      this.templateStamp = templateStamp ||
        (Polymer.TemplateStamp && new Polymer.TemplateStamp());
      // arguments are required
      if (!this.templateStamp) {
        throw 'PropertyEffects constructor requires `templateStamp` delegate.';
      }
    }

    // -- set properties machinery

    propertiesChanged(inst, currentProps, oldProps, changedProps) {
      // if (window.debug) {
      //   var c = Object.getOwnPropertyNames(changedProps);
      //   console.group(inst.localName + '#' + inst.id + ': ' + c);
      //   debugger;
      // }
      // Compute
      var computedProps = this._runComputedEffects(inst, changedProps, oldProps);
      // Compute linked paths
      this._computeLinkedPaths(inst, changedProps, computedProps);
      // Notify
      var props = this._notifyProperties(inst, changedProps, computedProps, oldProps);
      if (props) {
        oldProps = props.oldProps;
        changedProps = props.changedProps;
        // Propagate
        this._runEffects(inst, Types.PROPAGATE, changedProps);
        // Flush clients
        this.flushClients(inst);
        // Reflect
        this._runEffects(inst, Types.REFLECT, changedProps, oldProps);
        // Observe
        this._runEffects(inst, Types.OBSERVE, changedProps, oldProps);
      }
      // if (window.debug) {
      //   console.groupEnd(inst.localName + '#' + inst.id + ': ' + c);
      // }
    }

    _runComputedEffects(inst, changedProps, oldProps) {
      if (inst[Types.COMPUTE]) {
        var inputProps = changedProps;
        var computedProps;
        while (this._runEffects(inst, Types.COMPUTE, inputProps)) {
          this._mixin(oldProps, inst.__dataOld);
          this._mixin(changedProps, inst.__dataPending);
          computedProps = this._mixin(computedProps || {}, inst.__dataPending);
          inputProps = inst.__dataPending;
          inst.__dataPending = null;
        }
        return computedProps;
      }
    }

    _computeLinkedPaths(inst, changedProps, computedProps) {
      if (inst.__dataLinkedPaths) {
        var link;
        for (var a in inst.__dataLinkedPaths) {
          var b = inst.__dataLinkedPaths[a];
          for (var path in changedProps) {
            if (Polymer.Path.isDescendant(a, path)) {
              link = Polymer.Path.translate(a, b, path);
              changedProps[link] = computedProps[link] =
                inst.__data[link] = changedProps[path];
            } else if (Polymer.Path.isDescendant(b, path)) {
              link = Polymer.Path.translate(b, a, path);
              changedProps[link] = computedProps[link] =
                inst.__data[link] = changedProps[path];
            }
          }
        }
      }
    }

    _notifyProperties(inst, changedProps, computedProps, oldProps) {
      // Determine which props to notify
      var props = inst.__dataFromAbove ? computedProps : changedProps;
      // Save interim data for potential re-entry
      var runId = (inst._runId = ((inst._runId || 0) + 1));
      inst.__dataInterim = inst.__dataInterim ?
        this._mixin(inst.__dataInterim, changedProps) : changedProps;
      inst.__dataInterimOld = inst.__dataInterimOld ?
        this._mixin(inst.__dataInterimOld, oldProps) : oldProps;
      // Notify
      var host = inst.dataHost;
      this._runEffects(inst, Types.NOTIFY, props);
      // Flush host
      if (host && host.__dataLib instanceof BatchedEffects && host.__dataPending) {
        this.flush(host);
      }
      // Combine & return interim data only for last entry
      if (runId == inst._runId) {
        changedProps = inst.__dataInterim;
        oldProps = inst.__dataInterimOld;
        inst.__dataInterim = null;
        inst.__dataInterimOld = null;
        return {changedProps: changedProps, oldProps: oldProps};
      }
    }

    _setPropertyToNode(host, node, prop, value) {
      if (node.__dataLib instanceof BatchedEffects) {
        if (!this.hasReadOnlyEffect(node, prop)) {
          if (this.setPendingProperty(node, prop, value)) {
            this.enqueueClient(host, node);
          }
        }
      } else {
        super._setPropertyToNode(host, node, prop, value);
      }
    }

    _notifyPropertyToHost(host, path, value, event) {
      if (event.target.__dataLib instanceof BatchedEffects) {
        if (!this.hasReadOnlyEffect(host, path)) {
          if (path = this.updatePath(host, path, value)) {
            this.setPendingProperty(host, path, value);
          }
        }
      } else {
        super._notifyPropertyToHost(host, path, value, event);
      }
    }

    _runEffects(inst, type, props, oldProps) {
      var ran;
      var effects = inst[type];
      if (effects) {
        var id = this._effectUid++;
        for (var prop in props) {
          var rootProperty = Polymer.Path.root(prop);
          var fxs = effects[rootProperty];
          if (fxs) {
            for (var i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
              if (Polymer.Path.matches(fx.path, prop) &&
                (!fx.info || fx.info.lastRun !== id)) {
                fx.fn.call(inst, prop, inst.__data[prop], oldProps && oldProps[prop], fx.info, inst.__dataFromAbove);
                if (fx.info) {
                  fx.info.lastRun = id;
                }
                ran = true;
              }
            }
          }
        }
      }
      return ran;
    }

    // overridden from propertyEffects
    _runComputedEffect(property, value, old, info) {
      var result = info.lib._runMethodEffect(this, property, value, old, info);
      var computedProp = info.methodInfo;
      info.lib.setPendingProperty(this, computedProp, result);
    }

    enqueueClient(inst, client) {
      inst.__dataPendingClients = inst.__dataPendingClients || new Map();
      if (client !== inst) {
        inst.__dataPendingClients.set(client, true);
      }
    }

    flushClients(inst) {
      // Flush all clients
      var clients = inst.__dataPendingClients;
      if (clients) {
        var self = this;
        clients.forEach(function(v, client) {
          if (client.__data) {
            self.flush(client, true);
          }
        });
        inst.__dataPendingClients = null;
      }
    }

    extendWithAPI(superClass) {
      return class extends super.extendWithAPI(superClass) {
        setProperties(props) {
          let data = this.constructor.data;
          for (let path in props) {
            if (!data.hasReadOnlyEffect(this, path)) {
              let value = props[path];
              if (path = data.updatePath(this, path, value)) {
                data.setPendingProperty(this, path, value);
              }
            }
          }
          if (this.__dataInitialized) {
            // TODO(kschaaf): make asyncEffects a public API? remove?
            if (this.asyncEffects) {
              data.invalidate(this);
            } else {
              data.flush(this);
            }
          }
        }
      }
    }

  }

  var Types = BatchedEffects.Types;

  // export
  Polymer.BatchedEffects = BatchedEffects;

})();
</script>
