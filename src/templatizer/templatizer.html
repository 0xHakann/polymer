<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../../src/properties/batched-effects.html">
<link rel="import" href="../../src/attributes/attribute-to-from-property.html">
<link rel="import" href="../../src/template/template-stamp.html">
<link rel="import" href="../../src/events/gesture-event-listeners.html">

<script>
  (function() {
    'use strict';

    class Templatizer {

      static enqueueDebouncer(debouncer) {
        this._debouncerQueue = this._debouncerQueue || [];
        this._debouncerQueue.push(debouncer);
      }

      static flushDebouncers() {
        if (this._debouncerQueue) {
          while (this._debouncerQueue.length) {
            this._debouncerQueue.shift().flush();
          }
        }
      }

      constructor(data) {
        var self = this;
        this.data = data || new Polymer.BatchedEffects();
        // arguments are required
        if (!this.data) {
          throw 'PropertyEffects constructor requires `data` delegate.';
        }
      }

      templatize(template, options) {
        if (!template._content) {
          template._content = template.content;
        }
        var ctor = template._content._ctor;
        if (!ctor) {
          // Lazily generate memoized constructor
          ctor = template._content._ctor =
            this._createConstructor(template, options);
        }
        // Host property forwarding must be installed onto template instance
        this._prepHostProperties(ctor, template, options);
        // Extend memoized constructor and provide reference to the host template
        ctor = class TemplateInstance extends ctor {};
        ctor.prototype.template = template;
        ctor.instCount = 0;
        return ctor;
      }

      _createConstructor(template, options) {
        // Anonymous class created by the templatizer
        var data = this.data;
        var ctor = class extends data.extendWithAPI(class {}) {
          //TODO(kschaaf): for debugging; remove?
          get localName() { return 'template#' + this.template.id + '/TemplateInstance' }
          constructor(host, props) {
            super();
            //TODO(kschaaf): for debugging; remove?
            this.id = this.constructor.instCount;
            this.constructor.instCount++;
            this.dataHost = this.template;
            if (host) {
              this._rootDataHost = host.dataHost ?
                host.dataHost._rootDataHost || host.dataHost : host;
            }
            this._hostProps = template._content._hostProps;
            this._configureProperties(props);
            //TODO(kschaaf): id marshalling unnecessary
            this.root = data.stamp(this, template);
            // Save list of stamped children
            var children = this.children = [];
            for (var n = this.root.firstChild; n; n=n.nextSibling) {
              children.push(n);
              n._templateInstance = this;
            }
            data.flush(this, true);
          }
          _showHideChildren(hide) {
            var c = this.children;
            for (var i=0; i<c.length; i++) {
              var n = c[i];
              // Ignore non-changes
              if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
                if (n.nodeType === Node.TEXT_NODE) {
                  if (hide) {
                    n.__polymerTextContent__ = n.textContent;
                    n.textContent = '';
                  } else {
                    n.textContent = n.__polymerTextContent__;
                  }
                } else if (n.style) {
                  if (hide) {
                    n.__polymerDisplay__ = n.style.display;
                    n.style.display = 'none';
                  } else {
                    n.style.display = n.__polymerDisplay__;
                  }
                }
              }
              n.__hideTemplateChildren__ = hide;
              if (n._showHideChildren) {
                n._showHideChildren(hide);
              }
            }
          }
          _configureProperties(props) {
            if (props) {
              for (var iprop in options.instanceProps) {
                if (iprop in props) {
                  this[iprop] = props[iprop];
                }
              }
            }
            for (var hprop in this._hostProps) {
              this[hprop] = this.template['_host_' + hprop];
            }
          }
          forwardProperty(prop, value, host) {
            data.setPendingProperty(this, prop, value);
            if (host) {
              data.enqueueClient(host, this);
            }
          }
          flush() {
            data.flush(this, true);
          }
          dispatchEvent() { }
        }
        ctor.options = options;
        // TODO(kschaaf): event listeners created need to be decorated with e.model
        this.data.bindTemplate(ctor, template);
        this._prepInstanceProperties(ctor, template, options);
        return ctor;
      }

      _prepHostProperties(ctor, template, options) {
        if (options.fwdHostPropToInstance) {
          var hostProps = template._content._hostProps;
          for (var prop in hostProps) {
            this.data.addPropertyEffect(template, '_host_' + prop,
              Polymer.BatchedEffects.Types.PROPAGATE,
              {fn: this._createHP2IEffector(prop, options)});
            this.data.createNotifyingProperty(template, '_host_' + prop);
          }
          if (template.__dataProto) {
            template.__data = template.__dataProto;
          }
        }
      }

      _createHP2IEffector(hostProp, options) {
        return function(prop, value) {
          options.fwdHostPropToInstance.call(this, this,
            prop.substring('_host_'.length), value);
        }
      }

      _prepInstanceProperties(ctor, template, options) {
        var hostProps = template._content._hostProps || {};
        for (var iprop in options.instanceProps) {
          delete hostProps[iprop];
          if (options.fwdInstancePropToHost) {
            this.data.addPropertyEffect(ctor, iprop,
              Polymer.BatchedEffects.Types.NOTIFY,
              {fn: this._createIP2HEffector(iprop, options)});
          }
        }
        if (options.fwdHostPropToInstance && template.dataHost) {
          for (var hprop in hostProps) {
            this.data.addPropertyEffect(ctor, hprop,
              Polymer.BatchedEffects.Types.NOTIFY,
              {fn: this._createHP2HEffector(template)})
          }
        }
      }

      _createIP2HEffector(instProp, options) {
        return function fwdInstPropToHost(prop, value, old, info, fromAbove) {
          if (!fromAbove) {
            options.fwdInstancePropToHost.call(this, this, prop, value);
          }
        }
      }

      _createHP2HEffector(template) {
        var lib = this;
        return function fwdHostPropToHost(prop, value, old, info, fromAbove) {
          if (!fromAbove) {
            // TODO(kschaaf) This does not take advantage of the efficient
            // upward flow in batched effects
            lib.data.setProperty(template, '_host_' + prop, value);
          }
        }
      }

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   var model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @method modelForElement
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {Object<Polymer.Base>} Model representing the binding scope for
       *   the element.
       */
      modelForElement(host, el) {
        var model;
        while (el) {
          // An element with a _templateInstance marks the top boundary
          // of a scope; walk up until we find one, and then ensure that
          // its dataHost matches `this`, meaning this dom-repeat stamped it
          if ((model = el._templateInstance)) {
            // Found an element stamped by another template; keep walking up
            // from its dataHost
            if (model.dataHost != host) {
              el = model.dataHost;
            } else {
              return model;
            }
          } else {
            // Still in a template scope, keep going up until
            // a _templateInstance is found
            el = el.parentNode;
          }
        }
      }
    }

    Polymer.Templatizer = Templatizer;

  })();

</script>
