<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../../src/properties/batched-effects.html">
<link rel="import" href="../../src/attributes/attribute-to-from-property.html">
<link rel="import" href="../../src/template/template-stamp.html">
<link rel="import" href="../../src/events/gesture-event-listeners.html">

<script>

  (function() {

    class Templatizer {

      constructor(batchedEffects) {
        var self = this;
        this.batchedEffects = batchedEffects || new Polymer.BatchedEffects();
        // arguments are required
        if (!this.batchedEffects) {
          throw 'PropertyEffects constructor requires `batchedEffects` delegate.';
        }
      }

      templatize(template, options) {
        var ctor;
        if (!template._content) {
          template._content = template.content;
        }
        if (template._content._ctor) {
          // Use cached constructor for template when available
          ctor = template._content._ctor;
          // Host property forwarding must be installed onto template instance
          this._prepHostProperties(ctor, template, options);
        } else {
          ctor = template._content._ctor =
            this._createConstructor(template, options);
        }
        return ctor;
      }

      _createConstructor(template, options) {
        // Anonymous class created by the templatizer
        var batchedEffects = this.batchedEffects;
        var ctor = class TemplateInstance {
          constructor(host, props) {
            this.dataHost = host;
            if (host) {
              this._rootDataHost = host.dataHost ?
                host.dataHost._rootDataHost || host.dataHost : host;
            }
            this._hostProps = template._content._hostProps;
            this._configureProperties(props);
            //TODO(kschaaf): id marshalling unnecessary
            this.root = batchedEffects.stamp(this, template);
            // Save list of stamped children
            var children = this.children = [];
            for (var n = this.root.firstChild; n; n=n.nextSibling) {
              children.push(n);
              n._templateInstance = this;
            }
            batchedEffects.flush(this, true);
          }
          _showHideChildren(hide) {
            var c = this.children;
            for (var i=0; i<c.length; i++) {
              var n = c[i];
              // Ignore non-changes
              if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
                if (n.nodeType === Node.TEXT_NODE) {
                  if (hide) {
                    n.__polymerTextContent__ = n.textContent;
                    n.textContent = '';
                  } else {
                    n.textContent = n.__polymerTextContent__;
                  }
                } else if (n.style) {
                  if (hide) {
                    n.__polymerDisplay__ = n.style.display;
                    n.style.display = 'none';
                  } else {
                    n.style.display = n.__polymerDisplay__;
                  }
                }
              }
              n.__hideTemplateChildren__ = hide;
            }
          }
          _configureProperties(props) {
            for (var iprop in options.instanceProps) {
              if (iprop in props) {
                this[iprop] = props[iprop];
              }
            }
            for (var hprop in this._hostProps) {
              this[hprop] = this._rootDataHost[hprop];
            }
          }
          forwardProperty(prop, value) {
            batchedEffects.setPendingProperty(this, prop, value);
            if (this.dataHost.__dataPendingClients) {
              this.dataHost.__dataPendingClients.set(this, true);
            }
          }
          flush() {
            batchedEffects.flush(this, true);
          }
          dispatchEvent() { }
        }
        ctor.options = options;
        // TODO(kschaaf): event listeners created need to be decorated with e.model
        this.batchedEffects.bindTemplate(ctor, template);
        this._prepInstanceProperties(ctor, template, options);
        this._prepHostProperties(ctor, template, options);
        return ctor;
      }

      _prepHostProperties(ctor, template, options) {
        if (options.fwdHostPropToInstance) {
          var hostProps = template._content._hostProps;
          for (var prop in hostProps) {
            this.batchedEffects.addPropertyEffect(template,'_host_' + prop,
              Polymer.BatchedEffects.Types.PROPAGATE,
              {fn: this._createHP2IEffector(prop, options)});
            this.batchedEffects.createNotifyingProperty(template, '_host_' + prop);
          }
          if (template.__dataProto) {
           template.setProperties(template.__dataProto);
          }
        }
      }

      _createHP2IEffector(hostProp, options) {
        return function(prop, value) {
          options.fwdHostPropToInstance.call(this, hostProp, value);
        }
      }

      _prepInstanceProperties(ctor, template, options) {
        var hostProps = template._content._hostProps || {};
        for (var iprop in options.instanceProps) {
          delete hostProps[iprop];
          if (options.fwdInstancePropToHost) {
            this.batchedEffects.addPropertyEffect(ctor, iprop,
              Polymer.BatchedEffects.Types.OBSERVE,
              {fn: this._createIP2HEffector(iprop, options)});
          }
        }
        if (options.fwdHostPropToInstance && template.dataHost) {
          for (var hprop in hostProps) {
            this.batchedEffects.addPropertyEffect(ctor, hprop,
              Polymer.BatchedEffects.Types.OBSERVE,
              {fn: this._fwdHostPropToHost})
          }
        }
      }

      _createIP2HEffector(instProp, options) {
        return function(prop, value, old, info, fromAbove) {
          if (!fromAbove) {
            options.fwdInstancePropToHost.call(this, this, prop, value);
          }
        }
      }

      _fwdHostPropToHost(prop, value, old, info, fromAbove) {
        if (!fromAbove) {
          // TODO(kschaaf) This does not take advantage of the efficient
          // upward flow in batched effects
          this.dataHost[prop] = value;
        }
      }

    }

    Polymer.Templatizer = Templatizer;

  })();

</script>
