<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../../src/properties/batched-effects.html">
<link rel="import" href="../../src/attributes/attribute-to-from-property.html">
<link rel="import" href="../../src/template/template-stamp.html">
<link rel="import" href="../../src/events/gesture-event-listeners.html">

<script>

  (function() {

    var data = new Polymer.BatchedEffects();

    class DomBind extends HTMLElement {

      connectedCallback() {
        this.attachedCallback();
      }

      attachedCallback() {
        var self = this;
        var go = function() {
          requestAnimationFrame(function() {
            self.render();
          })
        };
        if (window.HTMLImports) {
          HTMLImports.whenReady(go)
        } else {
          go();
        }
      }

      disconnectedCallback() {
        this.detachedCallback();
      }

      detachedCallback() {
        this._removeChildren();
      }

      _insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }

      _removeChildren() {
        if (this._children) {
          for (var i=0; i<this._children.length; i++) {
            this.root.appendChild(this._children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */
      render() {
        if (!this._children) {
          var template = this.querySelector(template);
          data.bindTemplate(this, template);
          this.root = data.stamp(this, this);
          this._children = [];
          for (var n=this.root.firstChild; n; n=n.nextSibling) {
            this._children[this._children.length] = n;
          }
          data.flush(this);
        }
        this._insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change'));
      }

    }

    if (window.customElements) {
      customElements.define('dom-bind', DomBind);
    } else {
      DomBind = document.registerElement('dom-bind', DomBind);
    }

  })();

</script>
