<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../../src/properties/batched-effects.html">
<link rel="import" href="../../src/attributes/attribute-to-from-property.html">
<link rel="import" href="../../src/template/template-stamp.html">
<link rel="import" href="../../src/events/gesture-event-listeners.html">

<script>

  (function() {

    var data = new Polymer.BatchedEffects();

    class DomBind extends HTMLTemplateElement {

      attachedCallback() {
        this.render();
      }

      detachedCallback() {
        this._removeChildren();
      }

      _insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }

      _removeChildren() {
        if (this._children) {
          for (var i=0; i<this._children.length; i++) {
            this.root.appendChild(this._children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */
      render() {
        if (!this._children) {
          data.bindTemplate(this, this);
          data.init(this, this);
          this.root = data.ensureStamped(this);
          this._children = [];
          for (var n=this.root.firstChild; n; n=n.nextSibling) {
            this._children[this._children.length] = n;
          }
        }
        this._insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change'));
      }

    }

    DomBind.extends = 'template';

    document.registerElement('dom-bind', DomBind);

  })();

// <script>

//   Polymer({

//     /**
//      * Fired whenever DOM is stamped by this template (rendering
//      * will be deferred until all HTML imports have resolved).
//      *
//      * @event dom-change
//      */

//     is: 'dom-bind',

//     extends: 'template',
//     _template: null,

//     created() {
//       // Ensure dom-bind doesn't stamp until all possible dependencies
//       // have resolved
//       var self = this;
//       Polymer.RenderStatus.whenReady(function() {
//         if (document.readyState == 'loading') {
//           document.addEventListener('DOMContentLoaded', function() {
//             self._markImportsReady();
//           });
//         } else {
//           self._markImportsReady();
//         }
//       });
//     },

//     _ensureReady() {
//       if (!this._readied) {
//         this._readySelf();
//       }
//     },

//     _markImportsReady() {
//       this._importsReady = true;
//       this._ensureReady();
//     },

//     _registerFeatures() {
//       this._prepConstructor();
//     },

//     _insertChildren() {
//       var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
//       parentDom.insertBefore(this.root, this);
//     },

//     _removeChildren() {
//       if (this._children) {
//         for (var i=0; i<this._children.length; i++) {
//           this.root.appendChild(this._children[i]);
//         }
//       }
//     },

//     _initFeatures() {
//       // defer _initFeatures and stamping until after attached, to support
//       // document.createElement('template', 'dom-bind') use case,
//       // where template content is filled in after creation
//     },

//     // avoid scoping elements as we expect dom-bind output to be in the main
//     // document
//     _scopeElementClass(element, selector) {
//       if (this.dataHost) {
//         return this.dataHost._scopeElementClass(element, selector);
//       } else {
//         return selector;
//       }
//     },

//     _prepConfigure() {
//       var config = {};
//       for (var prop in this._propertyEffects) {
//         config[prop] = this[prop];
//       }
//       // Pass values set before attached as initialConfig to _setupConfigure
//       var setupConfigure = this._setupConfigure;
//       this._setupConfigure = function() {
//         setupConfigure.call(this, config);
//       };
//     },

//     attached() {
//       if (this._importsReady) {
//         this.render();
//       }
//     },

//     detached() {
//       this._removeChildren();
//     },

//     /**
//      * Forces the element to render its content. This is typically only
//      * necessary to call if HTMLImports with the async attribute are used.
//      */
//     render() {
//       this._ensureReady();
//       if (!this._children) {
//         this._template = this;
//         this._prepAnnotations();
//         this._prepEffects();
//         this._prepBehaviors();
//         this._prepConfigure();
//         this._prepBindings();
//         this._prepPropertyInfo();
//         Polymer.Base._initFeatures.call(this);
//         this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
//       }
//       this._insertChildren();
//       this.fire('dom-change');
//     }


</script>
