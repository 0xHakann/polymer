<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="debounce.html">

<script>
(function() {
  'use strict';

  class Collection {
    static for(obj) {
      var c;
      return this._collections.get(obj) ||
        (c = this.classFor(obj)) && new c(obj);
    }
    static forTracked(obj) {
      return this._collections.get(obj);
    }
    static classFor(obj) {
      for (var i=this.types.length; i>=0; i--) {
        var type = this.types[i](userArray);
        if (type) {
          return type;
        }
      }
    }
    constructor(obj, keyProperty) {
      this.objToKey = new WeakMap();
    }

    removeKey(key) { // abstract
      this.objToKey.delete(item);
    }
    getKey(key) {
      return key;
    }
    getItem(key) { // abstract
      if ((key = Collection.parseKey(key))) {
        return this.keyToObj[key];
      }
    }
    getItems() {
      var items = [], store = this.keyToObj;
      for (var key in store) {
        items.push(store[key]);
      }
      return items;
    }

  }

  Collection._collections = new WeakMap();

  Collection.types = [
    function(obj) {
      if (Array.isArray(obj)) {
        return ArrayCollection;
      // } else if (obj instanceof Map) {
      //   return MapCollection;
      // } else if (obj instanceof Set) {
      //   return SetCollection
      // } else {
      //   return ObjectCollection;
      }
    }
  ];

  class ArrayCollection extends Collection {

    static isKey(key) {
      return key && key[0] == '#';
    }
    static parseKey(key) {
      if (this.isKey(key)) {
        return key.slice(1);
      }
    }

    constructor(obj, keyProperty) {
      this.userArray = obj;
      this.keyProperty = keyProperty;
      if (!keyProperty) {
        this.keyToObj = userArray.slice();
      } else {
        this.keyToObj = {};
      }
      var s = this.keyToObj;
      for (var i=0; i<s.length; i++) {
        var item = s[i];
        var key = keyProperty ? item[keyProperty] : i;
        this.objToKey.set(item, key);
        if (keyProperty) {
          this.keyToObj[key] = item;
        }
      }
    }

    setItem(key, item) {
      var idx = key;
      if (key = Collection.parseKey(key)) {
        var old = this.objToKey[key];
        idx = this.userArray.indexOf(old);
      } else {
        key = this.objToKey.get(this.userArray[idx]);
      }
      this.userArray[idx] = item;
      this.objToKey[key] = item;

    }

    getItem(key) {
      if (parseInt(key, 10) == key) {
        return this.userArray[key];
      } else {
        return super.getItem(key);
      }
    }

    removeKey(key) {
      if ((key = Collection.parseKey(key))) {
        delete this.keyToObj[key];
        super.removeKey(key);
      }
    }


    // Accepts an array of standard splice records (index, addedCount, removed
    // array), and performs two key actions:
    // 1. Applies the splice to the collection: adds newly added items to the
    //    store which generates a unique key for it, and removes removed items
    //    (and their key) from the store
    // 2. Generates a "keySplices" record (in contrast to the input
    //    "indexSplices"), which contains an array of added and removed keys
    //    corresponding to the added/removed items
    applySplices(splices) {
      // Dedupe added and removed keys to a final added/removed map
      var keyMap = {}, key;
      for (var i=0, s; (i<splices.length) && (s=splices[i]); i++) {
        s.addedKeys = [];
        for (var j=0; j<s.removed.length; j++) {
          key = this.getKey(s.removed[j]);
          keyMap[key] = keyMap[key] ? null : -1;
        }
        for (j=0; j<s.addedCount; j++) {
          var item = this.userArray[s.index + j];
          key = this.getKey(item);
          key = (key === undefined) ? this.add(item) : key;
          keyMap[key] = keyMap[key] ? null : 1;
          // Add an "addedKeys" array to indexSplices to capture keys associated
          // with added items, since references to added items can be lost by
          // further changes to the array by the time the splice is consumed
          s.addedKeys.push(key);
        }
      }
      // Convert added/removed key map to added/removed arrays
      var removed = [];
      var added = [];
      for (key in keyMap) {
        if (keyMap[key] < 0) {
          this.removeKey(key);
          removed.push(key);
        }
        if (keyMap[key] > 0) {
          added.push(key);
        }
      }
      return [{
        removed: removed,
        added: added
      }];
    }

    static applySplices(userArray, splices) {
      // Only apply splices & generate keySplices if the array already has a
      // backing Collection, meaning there is an element monitoring its keys;
      // Splices that happen before the collection has been created must be
      // discarded to avoid double-entries
      var coll = this.forTracked(userArray);
      return coll ? coll.applySplices(splices) : null;
    };
  }

})();

</script>
