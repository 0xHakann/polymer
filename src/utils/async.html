<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">

<script>
{
  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
  let AsyncInterface; // eslint-disable-line no-unused-vars

  // Microtask implemented using Mutation Observer
  let microtaskCurrHandle = 0;
  let microtaskLastHandle = 0;
  let microtaskCallbacks = [];
  let microtaskNodeContent = 0;
  let microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});

  function microtaskFlush() {
    const len = microtaskCallbacks.length;
    for (let i = 0; i < len; i++) {
      let cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(() => { throw e });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * TODOC
   *
   * @namespace
   * @memberof Polymer
   */
  Polymer.Async = {

    /**
     * A timer with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    timeOut: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time to wait before calling callbacks in ms
       * @return {AsyncInterface} An async timeout interface
       */
      after(delay) {
        return  {
          run(fn) { return setTimeout(fn, delay) },
          cancel: window.clearTimeout.bind(window)
        }
      },
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run: window.setTimeout.bind(window),
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel: window.clearTimeout.bind(window)
    },

    /**
     * requestAnimationFrame with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    animationFrame: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * requestIdleCallback with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    idlePeriod: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run(fn) {
        return window.requestIdleCallback ?
          window.requestIdleCallback(fn) :
          window.setTimeout(fn, 16);
      },
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel(timer) {
        return window.cancelIdleCallback ?
          window.cancelIdleCallback(timer) :
          window.clearTimeout(timer);
      }
    },

    /**
     * Micro task with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    microTask: {

      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },

      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel(handle) {
        const idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }

    }
  };

}
</script>
