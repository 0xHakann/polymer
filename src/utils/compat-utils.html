<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="async.html">
<link rel="import" href="debounce.html">
<script>
(function() {

  function nyi() {
    console.warn('Not yet implemented:', arguments.callee.caller.name);
  }

  // sad but faster than slice...
  var $Array = Polymer.ArrayUtils = {
    copyChildNodes: function(parent) {
      var copy=[], i=0;
      for (var n=parent.firstChild; n; n=n.nextSibling) {
        copy[i++] = n;
      }
      return copy;
    },

    copyChildren: function(parent) {
      var copy=[], i=0;
      for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {
        copy[i++] = n;
      }
      return copy;
    },

    copy: function(a$) {
      var l = a$.length;
      var copy = new Array(l);
      for (var i=0; i < l; i++) {
        copy[i] = a$[i];
      }
      return copy;
    }
  };

  Polymer.CompatUtils = {

    Mixin: {

      // scoping
      customStyle: null,

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @method $$
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */
      $$: function(slctr) {
        return $Array.copy(this.root.querySelector(slctr));
      },

      domHost: function() {
        return nyi();
      },

      distributeContent: function(updateInsertionPoints) {
        return nyi();
      },
      
      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       *
       * @method getEffectiveChildNodes
       * @return {Array<Node>} List of effctive child nodes.
       */
      getEffectiveChildNodes: function() {
        var list = [];
        var c$ = this.childNodes;
        for (var i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
          if (c.localName === 'content') {
            var d$ = c.getDistributedNodes();
            for (var j=0; j < d$.length; j++) {
              list.push(d$[j]);
            }
          } else {
            list.push(c);
          }
        }
        return list;
      },

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @method getEffectiveChildren
       * @return {Array<Node>} List of effctive children.
       */
      getEffectiveChildren: function() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      },

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @method getEffectiveTextContent
       * @return {Array<Node>} List of effctive children.
       */
      getEffectiveTextContent: function() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i=0, c; (c = cn[i]); i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      },

      queryEffectiveChildren: function(slctr) {
        var e$ = this.queryDistributedElements(slctr);
        return e$ && e$[0];
      },

      queryAllEffectiveChildren: function(slctr) {
        return this.queryDistributedElements(slctr);
      },

      /**
       * Returns a list of nodes distributed to this element's `<content>`.
       *
       * If this element contains more than one `<content>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<content>`.
       */
      getContentChildNodes: function(slctr) {
        var content = this.root.querySelector(slctr || 'content');
        return content ? content.getDistributedNodes() : [];
      },

      /**
       * Returns a list of element children distributed to this element's
       * `<content>`.
       *
       * If this element contains more than one `<content>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<content>`.
       */
      getContentChildren: function(slctr) {
        return this.getContentChildNodes(slctr).filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      },

      isLightDescendant: function(node) {
        return nyi();
      },

      isLocalDescendant: function(node) {
        return nyi();
      },

      scopeSubtree: function(container, shouldObserve) {
        return nyi();
      },

      getComputedStyleValue: function(property) {
        return nyi();
      },

      updateStyles: function(properties) {
        return nyi();
      },

      // data

      get: function(path, root) {
        return nyi();
      },

      set: function(path, value, root) {
        return nyi();
      },

      push: function(path) {
        return nyi();
      },

      pop: function(path) {
        return nyi();
      },

      shift: function(path) {
        return nyi();
      },

      unshift: function(path) {
        return nyi();
      },

      splice: function(path, start) {
        return nyi();
      },

      arrayDelete: function(path, item) {
        return nyi();
      },

      linkPaths: function(to, from) {
        return nyi();
      },

      unlinkPaths: function(path) {
        return nyi();
      },

      notifyPath: function(path, value, fromAbove) {
        return nyi();
      },

      notifySplices: function(path, splices) {
        return nyi();
      },

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction: function(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       }, 100);
       *     }
       *
       * @method debounce
       * @param {String} jobName String to indentify the debounce job.
       * @param {Function} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       */
      debounce: function(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = Polymer.Debouncer.debounce(
          this._debouncers[jobName], callback, wait, this);
      },

      /**
       * Returns whether a named debouncer is active.
       *
       * @method isDebouncerActive
       * @param {String} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */
      isDebouncerActive: function(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      },

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @method flushDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      flushDebouncer: function(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      },

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @method cancelDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      cancelDebouncer: function(jobName) {
        this._debouncers = this._debouncers || {}
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      },

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @method async
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */
      async: function(callback, waitTime) {
        var self = this;
        return Polymer.Async.run(function() {
          callback.call(self);
        }, waitTime);
      },

      /**
       * Cancels an async operation started with `async`.
       *
       * @method cancelAsync
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */
      cancelAsync: function(handle) {
        Polymer.Async.cancel(handle);
      },

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @method create
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */
      create: function(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      },
      
      getNativePrototype: function(tag) {
        return nyi();
      },

      getPropertyInfo: function(property) {
        return nyi();
      },

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @method importHref
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */
      importHref: function(href, onload, onerror, optAsync) {
        var l = document.createElement('link');
        l.rel = 'import';
        l.href = href;

        optAsync = Boolean(optAsync);
        if (optAsync) {
          l.setAttribute('async', '');
        }

        var self = this;
        if (onload) {
          l.onload = function(e) {
            return onload.call(self, e);
          }
        }
        if (onerror) {
          l.onerror = function(e) {
            return onerror.call(self, e);
          }
        }
        document.head.appendChild(l);
        return l;
      },

      elementMatches: function(selector, node) {
        return nyi();
      },

      /**
       * Removes an HTML attribute from one node, and adds it to another.
       *
       * @method attributeFollows
       * @param {String} name HTML attribute name
       * @param {HTMLElement} toElement New element to add the attribute to.
       * @param {HTMLElement} fromElement Old element to remove the attribute from.
       */
      attributeFollows: function(name, toElement, fromElement) {
        if (fromElement) {
          Polymer.dom(fromElement).removeAttribute(name);
        }
        if (toElement) {
          Polymer.dom(toElement).setAttribute(name, '');
        }
      },

      /**
       * Removes a class from one node, and adds it to another.
       *
       * @method classFollows
       * @param {String} name CSS class name
       * @param {HTMLElement} toElement New element to add the class to.
       * @param {HTMLElement} fromElement Old element to remove the class from.
       */
      classFollows: function(name, toElement, fromElement) {
        if (fromElement) {
          Polymer.dom(fromElement).classList.remove(name);
        }
        if (toElement) {
          Polymer.dom(toElement).classList.add(name);
        }
      },

      /**
       * Toggles an HTML attribute on or off.
       *
       * @method toggleAttribute
       * @param {String} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleAttribute: function(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      },


      /**
       * Toggles a CSS class on or off.
       *
       * @method toggleClass
       * @param {String} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleClass: function(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      },

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @method transform
       * @param {String} transform Transform setting.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`
       */
      transform: function(transform, node) {
        node = node || this;
        node.style.webkitTransform = transform;
        node.style.transform = transform;
      },

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @method translate3d
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`.
       */
      translate3d: function(x, y, z, node) {
        node = node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

    }

  };

  // TODO(sorvell): figure out Polymer.dom compat...
  function decorate(e) {
    e.observeNodes = function() {};
    e.queryDistributedElements = function(selector) { 
      var n$ = e.querySelectorAll(selector);
      return Array.prototype.slice.call(n$);
    };
  }

  Polymer.dom = function(element) {
    var e = element.shadowRoot || element;
    decorate(e);
    return e;
  };

  Polymer.Settings = {
    useShadow: true
  }

})();
</script>
