<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/utils.html">
<link rel="import" href="style-transformer.html">
<link rel="import" href="style-util.html">
<link rel="import" href="style-properties.html">
<link rel="import" href="apply-shim.html">
<script>
(function() {
  'use strict';

  class StyleLib {
    constructor(nativeShadow, nativeCss) {
      this.nativeShadow = nativeShadow;
      this.nativeCss = nativeCss;
      this.scopeCounter = {};
    }
    _generateScopeSelector(name) {
      let id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;
      return name + '-' + id;
    }
    _prepareTemplate(template, tagname) {
      let cssText = '';
      let styles = template.content.querySelectorAll('style');
      for (let i = 0; i < styles.length; i++) {
        let s = styles[i];
        cssText += s.textContent;
        s.parentNode.removeChild(s);
      }
      if (!this.nativeShadow) {
        template._placeholder = Polymer.StyleUtil.applyStylePlaceHolder(tagname);
        Polymer.StyleTransformer.dom(template.content, tagname);
      }
      let ast = Polymer.CssParse.parse(cssText);
      if (this.nativeCss) {
        Polymer.StyleUtil.forEachRule(ast, rule => Polymer.ApplyShim.transformRule(rule));
      }
      template._styleAst = ast;
    }
    prepareHost(host, template) {
      let ownPropertyNames;
      if (!template._prepared) {
        this._prepareTemplate(template, host.localName);
        if (this.nativeCss) {
          ownPropertyNames = [];
        } else {
          ownPropertyNames = Polymer.StyleProperties.decorateStyles([{__cssRules: template._styleAst}], host, this.nativeShadow);
        }
        if (!ownPropertyNames.length) {
          let cssText = Polymer.StyleTransformer.elementStyles(host, {__cssRules: template._styleAst}, this.nativeShadow);
          Polymer.StyleUtil.applyCss(cssText, host.localName, this.nativeShadow ? template.content : null, template._placeholder)
        }
        template._ownPropertyNames = ownPropertyNames;
        template._prepared = true;
      }
      if (!this.nativeShadow) {
        Polymer.StyleTransformer.element(host, host.localName);
      }
      let style = document.createElement('style');
      style.__cssRules = template._styleAst;
      host.__style = style;
      host.__placeholder = template._placeholder;
      if (!this.nativeCss) {
        host.__styleProperties = null;
        host.__ownStyleProperties = null;
        host.__scopeSelector = null;
        host.__ownStylePropertyNames = template._ownPropertyNames;
      }
    }
    applyStyle(host, overrideProps) {
      if (this.nativeCss) {
        Polymer.StyleProperties.updateNativeStyleProperties(host, overrideProps);
      } else {
        this._updateProperties(host, overrideProps);
        if (host.__ownStylePropertyNames.length) {
          // TODO: use caching
          this._applyStyleProperties(host);
        }
      }
    }
    _applyStyleProperties(host) {
      let style = host.__style;
      let oldScopeSelector = host.__scopeSelector;
      host.__scopeSelector = this._generateScopeSelector(host.localName);
      style = Polymer.StyleProperties.applyElementStyle(host, host.__styleProperties, host.__scopeSelector, null, this.nativeShadow);
      if (!this.nativeShadow) {
        Polymer.StyleProperties.applyElementScopeSelector(host, host.__scopeSelector, oldScopeSelector);
      }
      return style;
    }
    _updateProperties(host, overrideProps) {
      let ownerRoot = Polymer.Utils.ownerRootForNode(host);
      let owner = ownerRoot && ownerRoot.host || document;
      let ownerProperties = owner.__styleProperties;
      let props = Object.create(ownerProperties || null);
      let hostAndRootProps = Polymer.StyleProperties.hostAndRootPropertiesForScope(host, [host.__style], this.nativeShadow);
      Object.assign(props, hostAndRootProps.hostProps);
      let propertiesMatchingHost = Polymer.StyleProperties.propertyDataFromStyles([owner.__style], host).properties;
      Object.assign(props, propertiesMatchingHost);
      Object.assign(props, hostAndRootProps.rootProps);
      Object.assign(props, overrideProps);
      Polymer.StyleProperties.reify(props);
      host.__styleProperties = props;
      let ownProps = {};
      for (let i = 0; i < host.__ownStylePropertyNames.length; i++) {
        let n = host.__ownStylePropertyNames[i];
        ownProps[n] = props[n];
      }
      host.__ownStyleProperties = ownProps;
    }
  }

  Polymer.StyleLib = new StyleLib(!Boolean(Polymer.ShadyDom), true);
})();
</script>
