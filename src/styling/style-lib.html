<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="style-settings.html">
<link rel="import" href="style-gather.html">
<link rel="import" href="style-transformer.html">
<link rel="import" href="style-util.html">
<link rel="import" href="style-properties.html">
<link rel="import" href="apply-shim.html">
<script>
(function() {
  'use strict';

  var StyleLib = {
    scopeCounter: {},
    nativeShadow: Polymer.StyleSettings.nativeShadow,
    nativeCss: Polymer.StyleSettings.nativeCssVariables,
    nativeCssApply: Polymer.StyleSettings.nativeCssApply,
    _documentOwner: document.documentElement,
    _generateScopeSelector(name) {
      var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;
      return name + '-' + id;
    },
    applyStylePlaceHolder(name) {
      return Polymer.StyleUtil.applyStylePlaceHolder(name);
    },
    prepareTemplate(host, template) {
      if (template._prepared) {
        return;
      }
      template._prepared = true;
      var cssText = Polymer.StyleGather.cssFromElement(template);
      if (!this.nativeShadow) {
        Polymer.StyleTransformer.dom(template.content, host.is);
      }
      var ast = Polymer.CssParse.parse(cssText);
      if (this.nativeCss && !this.nativeCssApply) {
        Polymer.ApplyShim.transformRules(ast);
      }
      template._styleAst = ast;

      var ownPropertyNames = [];
      if (!this.nativeCss) {
        ownPropertyNames = Polymer.StyleProperties.decorateStyles(template._styleAst, host);
      }
      if (!ownPropertyNames.length || this.nativeCss) {
        cssText = Polymer.StyleTransformer.elementStyles(host, template._styleAst);
        if (cssText.length) {
          var target = this.nativeShadow ? template.content : null;
          Polymer.StyleUtil.applyCss(cssText, host.is, target, host.__placeholder);
        }
      }
      template._ownPropertyNames = ownPropertyNames;
      template._prepared = true;
    },
    prepareHost(host, template) {
      if (template) {
        host.__styleRules = template._styleAst;
      }
      host.__placeholder = host.constructor.__placeholder;
      host.__overrideStyleProperties = {};
      if (!this.nativeCss) {
        host.__styleProperties = null;
        host.__ownStyleProperties = null;
        host.__scopeSelector = null;
        if (template) {
          host.__ownStylePropertyNames = template._ownPropertyNames;
        }
      }
    },
    applyStyle(host, overrideProps) {
      this._ensureDocumentApplied();
      Polymer.Utils.mixin(host.__overrideStyleProperties, overrideProps);
      if (this.nativeCss) {
        this._updateNativeProperties(host, host.__overrideStyleProperties);
      } else {
        this._updateProperties(host, host.__overrideStyleProperties);
        if (host.__ownStylePropertyNames && host.__ownStylePropertyNames.length) {
          // TODO: use caching
          this._applyStyleProperties(host);
        }
        var root = this._isRootOwner(host) ? host : host.shadowRoot;
        // note: some elements may not have a root!
        if (root) {
          this._applyToDescendants(root);
        }
      }
    },
    // marks document styles dirty which means that next time any styling
    // is applied via `applyStyle`, document styles will be applied.
    markDocumentDirty() {
      this._documentOwner.__clean = false;
    },
    // Returns true if document styles are dirty. Can be used to determine
    // if it's necessary to flush styling (Polymer.updateStyles)
    // at a given time.
    isDocumentDirty() {
      return !this._documentOwner.__clean;
    },
    // ensures that document styles (custom-style) have their
    // custom properties applied
    _ensureDocumentApplied() {
      var owner = this._documentOwner;
      if (!owner.__clean) {
        if (!owner.__overrideStyleProperties) {
          owner.__overrideStyleProperties = {};
        }
        if (!this.nativeCss) {
          this._updateProperties(owner);
          var s$ = owner.__documentStyles;
          if (s$) {
            for (var i=0; i < s$.length; i++) {
              var style = s$[i];
              style.removeAttribute('type');
              Polymer.StyleProperties.applyCustomStyle(style,
                owner.__styleProperties);
            }
          }
        }
        owner.__clean = true;
      }
    },
    _applyToDescendants(root) {
      var c$ = root.children;
      for (var i = 0, c; i < c$.length; i++) {
        c = c$[i];
        if (c.shadowRoot) {
          this.applyStyle(c);
        }
        this._applyToDescendants(c);
      }
    },
    _styleOwnerForNode(node) {
      var root = Polymer.Utils.getRootNode(node);
      var host = root.host;
      if (host) {
        if (host instanceof Polymer.Element) {
          return host;
        } else {
          return this._styleOwnerForNode(host);
        }
      }
      return this._documentOwner;
    },
    _isRootOwner(node) {
      return (node === this._documentOwner);
    },
    _applyStyleProperties(host) {
      var oldScopeSelector = host.__scopeSelector;
      host.__scopeSelector = this._generateScopeSelector(host.is);
      var style = Polymer.StyleProperties.applyElementStyle(host, host.__styleProperties, host.__scopeSelector, null);
      if (!this.nativeShadow) {
        Polymer.StyleProperties.applyElementScopeSelector(host, host.__scopeSelector, oldScopeSelector);
      }
      return style;
    },
    _updateProperties(host) {
      var owner = this._styleOwnerForNode(host);
      var ownerProperties = owner.__styleProperties;
      var props = Object.create(ownerProperties || null);
      var hostAndRootProps = Polymer.StyleProperties.hostAndRootPropertiesForScope(host, host.__styleRules);
      var propertiesMatchingHost = Polymer.StyleProperties.propertyDataFromStyles(owner.__styleRules, host).properties;
      Object.assign(
        props,
        hostAndRootProps.hostProps,
        propertiesMatchingHost,
        hostAndRootProps.rootProps
      );
      this._mixinOverrideStyles(props, host.__overrideStyleProperties);
      Polymer.StyleProperties.reify(props);
      host.__styleProperties = props;
      var ownProps = {};
      if (host.__ownStylePropertyNames) {
        for (var i = 0, n; i < host.__ownStylePropertyNames.length; i++) {
          n = host.__ownStylePropertyNames[i];
          ownProps[n] = props[n];
        }
      }
      host.__ownStyleProperties = ownProps;
    },
    _mixinOverrideStyles(props, overrides) {
      for (var p in overrides) {
        var v = overrides[p];
        // skip override props if they are not truthy or 0
        // in order to fall back to inherited values
        if (v || v === 0) {
          props[p] = v;
        }
      }
    },
    _updateNativeProperties(element, properties) {
      // remove previous properties
      for (var p in properties) {
        // NOTE: for bc with shim, don't apply null values.
        if (p === null) {
          element.style.removeProperty(p);
        } else {
          element.style.setProperty(p, properties[p]);
        }
      }
    },
    // transforms a style such that it is scope-safe for the document scope.
    transformForDocument(style) {
      var shouldAdd = !style.__cssRules;
      var rules = Polymer.StyleUtil.rulesForStyle(style);
      if (shouldAdd) {
        var root = this._documentOwner;
        root.__documentStyles = root.__documentStyles || [];
        root.__documentStyles.push(style);
        // keep 1 aggregated set of style rules for the root.
        root.__styleRules = root.__styleRules || {rules: []};
        root.__styleRules.rules.push(rules);
      }
      var self = this;
      Polymer.StyleUtil.forEachRule(rules,
        function(rule) {
          // shim the selector for current runtime settings
          if (!self.nativeShadow) {
            Polymer.StyleTransformer.documentRule(rule);
          } else {
            Polymer.StyleTransformer.normalizeRootSelector(rule);
          }
          // run the apply shim if unbuilt and using native css custom properties
          if (self.nativeCss && !self.nativeCssApply) {
            Polymer.ApplyShim.transformRule(rule);
          }
        }
      );
      // custom properties shimming
      // (if we use native custom properties, no need to apply any property shimming)
      if (this.nativeCss) {
        // TODO(dfreedm): replace build logic.
        // there's no targeted build, so the shimmed styles must be applied.
        style.removeAttribute('type');
        style.textContent = Polymer.StyleUtil.toCssText(rules);
      }
    }
  }

  // bc...
  Polymer.updateStyles = function(properties) {
    StyleLib.markDocumentDirty();
    StyleLib.applyStyle(StyleLib._documentOwner, properties);
  }

  Polymer.StyleLib = StyleLib;
})();
</script>
