<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="style-settings.html">
<link rel="import" href="style-gather.html">
<link rel="import" href="style-transformer.html">
<link rel="import" href="style-util.html">
<link rel="import" href="style-properties.html">
<link rel="import" href="apply-shim.html">
<script>
(function() {
  'use strict';

  var StyleLib = {
    scopeCounter: {},
    nativeShadow: Polymer.StyleSettings.nativeShadow,
    nativeCss: Polymer.StyleSettings.nativeCssVariables,
    nativeCssApply: Polymer.StyleSettings.nativeCssApply,
    _rootOwner: document.documentElement,
    _generateScopeSelector(name) {
      var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;
      return name + '-' + id;
    },
    _prepareTemplate(template, tagname) {
      var cssText = Polymer.StyleGather.cssFromElement(template);
      if (!this.nativeShadow) {
        template._placeholder = Polymer.StyleUtil.applyStylePlaceHolder(tagname);
        Polymer.StyleTransformer.dom(template.content, tagname);
      }
      var ast = Polymer.CssParse.parse(cssText);
      if (this.nativeCss && !this.nativeCssApply) {
        Polymer.ApplyShim.transformRules(ast);
      }
      template._styleAst = ast;
    },
    prepareHost(host, template) {
      if (!template._prepared) {
        this._prepareTemplate(template, host.localName);
        var ownPropertyNames = [];
        if (!this.nativeCss) {
          ownPropertyNames = Polymer.StyleProperties.decorateStyles(template._styleAst, host);
        }
        if (!ownPropertyNames.length || this.nativeCss) {
          var cssText = Polymer.StyleTransformer.elementStyles(host, template._styleAst);
          if (cssText.length) {
            var target = this.nativeShadow ? template.content : null;
            Polymer.StyleUtil.applyCss(cssText, host.localName, target, template._placeholder)
          }
        }
        template._ownPropertyNames = ownPropertyNames;
        template._prepared = true;
      }
      host.__styleRules = template._styleAst;
      host.__placeholder = template._placeholder;
      if (!this.nativeCss) {
        host.__styleProperties = null;
        host.__ownStyleProperties = null;
        host.__scopeSelector = null;
        host.__ownStylePropertyNames = template._ownPropertyNames;
      }
    },
    applyStyle(host, overrideProps) {
      if (this.nativeCss) {
        this._updateNativeProperties(host, overrideProps);
      } else {
        this.ensureRootStyleApplied();
        this._updateProperties(host, overrideProps);
        if (host.__ownStylePropertyNames && host.__ownStylePropertyNames.length) {
          // TODO: use caching
          this._applyStyleProperties(host);
        }
        var root = this._isRootOwner(host) ? host : host.shadowRoot;
        this._applyToDescendants(root);
      }
    },
    ensureRootStyleApplied() {
      if (!this._rootOwner.__appliedRootStyle) {
        this._applyRootStyle();
      }
    },
    invalidateRootStyle() {
      this._rootOwner.__appliedRootStyle = false;
    },
    _applyRootStyle() {
      var root = this._rootOwner;
      if (!this.nativeCss) { 
        this._updateProperties(root);
        var s$ = root.__scopeElements;
        for (var i=0; i < s$.length; i++) {
          Polymer.StyleProperties.applyCustomStyle(s$[i], 
            root.__styleProperties);
        }
      }
      root.__appliedRootStyle = true;
    },
    _applyToDescendants(root) {
      var c$ = root.children;
      for (var i = 0, c; i < c$.length; i++) {
        c = c$[i];
        if (c.shadowRoot) {
          this.applyStyle(c);
        }
        this._applyToDescendants(c);
      }
    },
    _styleOwnerForNode(node) {
      var root = Polymer.Utils.ownerRootForNode(node);
      return ShadyDom.isShadyRoot(root) ? root.host : this._rootOwner;
    },
    _isRootOwner(node) {
      return (node === this._rootOwner);
    },
    _applyStyleProperties(host) {
      var oldScopeSelector = host.__scopeSelector;
      host.__scopeSelector = this._generateScopeSelector(host.localName);
      var style = Polymer.StyleProperties.applyElementStyle(host, host.__styleProperties, host.__scopeSelector, null);
      if (!this.nativeShadow) {
        Polymer.StyleProperties.applyElementScopeSelector(host, host.__scopeSelector, oldScopeSelector);
      }
      return style;
    },
    _updateProperties(host, overrideProps) {
      var owner = this._styleOwnerForNode(host);
      var ownerProperties = owner.__styleProperties;
      var props = Object.create(ownerProperties || null);
      var hostAndRootProps = Polymer.StyleProperties.hostAndRootPropertiesForScope(host, host.__styleRules);
      var propertiesMatchingHost = Polymer.StyleProperties.propertyDataFromStyles(owner.__styleRules, host).properties;
      Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps, overrideProps);
      Polymer.StyleProperties.reify(props);
      host.__styleProperties = props;
      var ownProps = {};
      if (host.__ownStylePropertyNames) {
        for (var i = 0, n; i < host.__ownStylePropertyNames.length; i++) {
          n = host.__ownStylePropertyNames[i];
          ownProps[n] = props[n];
        }
      }
      host.__ownStyleProperties = ownProps;
    },
    _updateNativeProperties(element, properties) {
      var oldPropertyNames = element.__customStyleProperties;
      if (oldPropertyNames) {
        // remove previous properties
        for (var i=0; i < oldPropertyNames.length; i++) {
          element.style.removeProperty(oldPropertyNames[i]);
        }
      }
      var propertyNames = [];
      // apply properties
      for (var p in properties) {
        // NOTE: for bc with shim, don't apply null values.
        if (properties[p] !== null) {
          element.style.setProperty(p, properties[p]);
          propertyNames.push(p);
        }
      }
      element.__customStyleProperties = propertyNames;
    },
    applyDocumentStyle(style) {
      var shouldAdd = !Boolean(style.__cssRules);
      var rules = Polymer.StyleUtil.rulesForStyle(style);
      if (shouldAdd) {
        var root = this._rootOwner;
        root.__scopeElements = root.__scopeElements || [];
        root.__scopeElements.push(style); 
        // keep 1 aggregated set of style rules for the root.
        root.__styleRules = root.__styleRules || {rules: []};
        root.__styleRules.rules.push(rules);
      }
      var self = this;
      Polymer.StyleUtil.forEachRule(rules,
        function(rule) {
          // shim the selector for current runtime settings
          if (!self.nativeShadow) {
            Polymer.StyleTransformer.documentRule(rule);
          }
          // run the apply shim if unbuilt and using native css custom properties
          if (self.nativeCss && !self.nativeCssApply) {
            Polymer.ApplyShim.transformRule(rule);
          }
        }
      );
      // custom properties shimming
      // (if we use native custom properties, no need to apply any property shimming)
      if (this.nativeCss) {
        // TODO(dfreedm): replace build logic.
        // there's no targeted build, so the shimmed styles must be applied.
        style.textContent = Polymer.StyleUtil.toCssText(rules);
      }
    }
  }

  Polymer.updateStyles = function(properties) {
    StyleList.invalidateRootStyle();
    StyleLib.applyStyle(StyleLib._rootOwner, properties);
  }

  Polymer.StyleLib = StyleLib;
})();
</script>
