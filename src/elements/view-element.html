<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/batched-effects.html">

<script>
(function() {

  'use strict';

  var events = new Polymer.GestureEventListeners();
  var attributes = new Polymer.AttributeToFromProperty();
  var templateStamp = new Polymer.TemplateStamp(events);
  var data = new Polymer.BatchedEffects(templateStamp, attributes);

  let callbacks;
  let afterNextRender = function(cb) {
    if (callbacks) {
      callbacks.push(cb);
    } else {
      callbacks = [cb];
      requestAnimationFrame(function() {
        callbacks.forEach(function(fn) {
          fn();
        });
        callbacks = null;
      });
    }
  }

  class ViewElement extends HTMLElement {

    createdCallback() {
      if (!this.constructor.prototype.hasOwnProperty('__hasEffects')) {
        this.constructor.prototype.__hasEffects = true;
        this.installEffects(this.constructor.prototype);
      }
    }

    attributeChangedCallback(name, old, value) {
      var attrs = this.constructor.observedAttributes;
      // TODO(sorvell): remove when using v1 custom elements.
      if (attrs && attrs.indexOf(name) >= 0) {
        attributes.attributeToProperty(this, name, value);
      }
    }

    attachedCallback() {
      if (!this.__hasAttached) {
        this.__hasAttached = true;
        this.firstAttached();
      }
    }

    firstAttached() {
      var dom = this.stampDom();
      this.attachDom(dom);
      data.enablePropertyEffects(this);
      afterNextRender(() => {
        this.asyncInit();
      });
    }

    installEffects() {
      if (this.template) {
        data.bindTemplate(this.constructor, this.template);
      }
    }

    stampDom() {
      if (this.template) {
        return data.stamp(this.template, this);
      }
    }

    attachDom(dom) {
      if (dom) {
        if (!this.shadowRoot) {
          this.createShadowRoot();
        }
        this.shadowRoot.appendChild(dom);
      }
    }

    asyncInit() {
      this.addListeners();
      this.ensureAttributes();
    }

    addListeners() {}

    ensureAttributes() {}

  }

  ViewElement.events = events;
  ViewElement.attributes = attributes;
  ViewElement.data = data;

  Polymer.ViewElement = ViewElement;

})();
</script>