<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../legacy/dom-module.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/case-map.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">
<link rel="import" href="../styling/style-gather.html">
<link rel="import" href="../styling/style-util.html">

<script>
(function() {

  'use strict';

  var utils = Polymer.Utils;
  var caseMap = Polymer.CaseMap;

  var events = new Polymer.GestureEventListeners();
  var templateStamp = new Polymer.TemplateStamp(events);
  var attributes = new Polymer.AttributeToFromProperty();
  var data = new Polymer.MetaEffects(templateStamp, attributes);

  var ElementMixin = function(Base) {

    class PolymerElement extends data.extendWithAPI(Base) {

      // returns the config object on specifically on `this` class (not super)
      // config is used for:
      // (1) super chain mixes togther to make `flattenedProperties` which is
      // then used to make observedAttributes and set property defaults
      // (2) properties effects and observers are created from it at `finalize` time.
      static get _ownConfig() {
        if (!this.hasOwnProperty('__ownConfig')) {
          this.__ownConfig = this.hasOwnProperty('config') ? this.config : {};
        }
        return this.__ownConfig;
      }

      // a flattened list of properties mixed together from the chain of all
      // constructor's `config.properties`
      // This list is used to create
      // (1) observedAttributes,
      // (2) element default values
      static get _flattenedProperties() {
        if (!this.hasOwnProperty('__flattenedProperties')) {
          this.__flattenedProperties = this._ownConfig.properties || {};
          var superCtor = Object.getPrototypeOf(this.prototype).constructor;
          if (superCtor.prototype instanceof PolymerElement) {
            this.__flattenedProperties = utils.mixin(
              Object.create(superCtor._flattenedProperties),
              this.__flattenedProperties);
          }
        }
        return this.__flattenedProperties;
      }

      static get observedAttributes() {
        if (!this.hasOwnProperty('_observedAttributes')) {
          // observedAttributes must be finalized at registration time
          this._observedAttributes = this.addPropertiesToAttributes(
            this._flattenedProperties, []);
          // TODO(kschaaf): revisit: capture import document, to aid finding dom-module
          var currentScript = document._currentScript || document.currentScript;
          this.__importDoc = currentScript && currentScript.ownerDocument;
        }
        return this._observedAttributes;
      }

      static addPropertiesToAttributes(properties, attrs) {
        for (var prop in properties) {
          attrs.push(Polymer.CaseMap.camelToDashCase(prop));
        }
        return attrs;
      }

      static get _finalized() {
        return this.hasOwnProperty('__finalized');
      }

      static set _finalized(value) {
        this.__finalized = value;
      }

      // TODO(sorvell): need to work on public api surrouding `finalize`.
      // Due to meta-programming, it's awkward to make a subclass impl of this.
      // However, a user might want to call `finalize` prior to define to do
      // this work eagerly. Need to also decide on `finalizeConfig(config)` and
      // `finalizeTemplate(template)`. Both are public but have simiarly
      // awkward subclassing characteristics.
      static _finalize() {
        var proto = this.prototype;
        if (!this._finalized) {

          var superProto = Object.getPrototypeOf(proto);
          var superCtor = superProto && superProto.constructor;
          if (superCtor.prototype instanceof PolymerElement) {
            superCtor._finalize();
          }
          this._finalized = true;
          if (this.hasOwnProperty('is') && this.is) {
            Polymer.telemetry.register(proto);
          }
          var config = this._ownConfig;
          if (config) {
            this.finalizeConfig(config);
          }
          if (this.template) {
            var template = this.template.cloneNode(true);
            this.finalizeTemplate(template);
          }
        }
      }

      static createProperties(properties) {
        if (properties) {
          this.data.createProperties(this.prototype, properties);
        }
      }

      static createMethodObservers(observers) {
        if (observers) {
          this.data.createMethodObservers(this.prototype, observers);
        }
      }

      static finalizeConfig(config) {
        this.createProperties(config.properties);
        this.createMethodObservers(config.observers);
      }

      static get template() {
        if (!this.hasOwnProperty('_template')) {
          // TODO(sorvell): `__importDoc` may not be set if super class
          // has not run defined... falling back to document here is
          // incorrect. This gambit cannot work as is since if the superclass
          // document cannot be discovered via the subclass.
          // TODO(sorvell): support more ways to acquire template.
          // this requires `is` on constructor...
          this._template = Polymer.DomModule.import(this.is,
          'template', this.__importDoc || document) ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf(this.prototype).constructor.template;
        }
        return this._template;
      }

      static finalizeTemplate(template) {
        // TODO(sorvell): cannot use `this` here, refactor this to only do
        // template preparation and take a name.
        // TODO(dfreedm): factor so that we do not need an object/element
        // argument
        var info = {
          localName: this.is,
          is: this.is,
          extends: this.extends,
          __cssBuild: this.__cssBuild,
          __placeholder: this.__placeholder
        };
        // support `include="module-name"`
        let cssText = Polymer.StyleGather.cssFromElement(template);
        if (cssText) {
          var style = document.createElement('style');
          style.textContent = cssText;
          template.content.insertBefore(style, template.content.firstChild);
        }
        if (window.ShadyStyling) {
          ShadyStyling.prepareTemplate(info, template);
        }
        // TODO(dfreedm): remove when style stuff is refactored
        // away from using element as input.
        var proto = this.prototype;
        proto.__notStyleScopeCacheable = info.__notStyleScopeCacheable;
        this.data.clearPropagateEffects(proto);
        this.data.bindTemplate(proto, template);
        proto._template = template;
      }

      constructor() {
        super();
        // note: `this.constructor.prototype` is wrong in Safari so make sure to
        // use `__proto__`
        if (!this.constructor._finalized) {
          this.constructor._finalize();
        }
        Polymer.telemetry.instanceCount++;
        // setup batched effects library; will call initialize when flushing
        this.constructor.data.prepare(this, this.ready);
        // add self to host's pending client list
        hostStack.registerHost(this);
        // apply defaults first.
        this.constructor.data.setPropertyDefaults(this,
          this.constructor._flattenedProperties);
      }

      // reserved for canonical behavior
      connectedCallback() {
        if (hostStack.isEmpty()) {
          this.constructor.data.flush(this);
          this.updateStyles();
        }
        this.isAttached = true;
      }

      ready() {
        if (!this.root) {
          if (this._template) {
            // BREAKME(sorvell): v0 support removed
            this.root = this.attachShadow({mode: 'open'});
          } else {
            this.root = this;
          }
        }
        if (this._template) {
          hostStack.beginHosting(this);
          var dom = this.constructor.data.stamp(this, this._template);
          this.root.appendChild(dom);
          hostStack.endHosting(this);
        }
        this.constructor.data.flush(this);
      }

      addListeners(listeners) {
        this.constructor.events.addMethodListeners(this, listeners);
      }

      ensureAttributes(attrs) {
        this.constructor.attributes.ensureAttributes(this, attrs);
      }

      disconnectedCallback() {
        this.isAttached = false;
      }

      attributeChangedCallback(name, old, value) {
        var property = caseMap.dashToCamelCase(name);
        var type = this.constructor._flattenedProperties[property].type;
        if (!this.constructor.data.hasReadOnlyEffect(this, property)) {
          this.constructor.attributes.attributeToProperty(this,
            name, value, type);
        }
      }

      updateStyles(properties) {
        if (window.ShadyStyling) {
          ShadyStyling.applyStyle(this, properties);
        }
      }

      arrayDelete(arrayOrPath, item) {
        var index;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          var arr = Polymer.Path.get(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(path, index, 1);
          }
        }
      }
    }

    PolymerElement.events = events;
    PolymerElement.templateStamp = templateStamp;
    PolymerElement.attributes = attributes;
    PolymerElement.data = data;

    return PolymerElement;

  }

  var hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length-1];
        data.enqueueClient(host, inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  // telemetry
  Polymer.telemetry = {
    instanceCount: 0,
    registrations: [],
    _regLog: function(prototype) {
      console.log('[' + prototype.is + ']: registered')
    },
    register: function(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    dumpRegistrations: function() {
      this.registrations.forEach(this._regLog);
    }
  };

  // TODO(sorvell): similar to but simpler than mixin.with... just use that?
  Polymer.CachedMixin = function(mixin) {
    return function(Base) {
      if (!mixin.__mixinApplications) {
        mixin.__mixinApplications = new WeakMap();
      }
      var application = mixin.__mixinApplications.get(Base);
      if (!application) {
        application = mixin(Base);
        mixin.__mixinApplications.set(Base, application);
      }
      return application;
    }
  }

  Polymer.ElementMixin = Polymer.CachedMixin(ElementMixin);

  Polymer.Element = Polymer.ElementMixin(HTMLElement);

  Polymer.updateStyles = function() {
    if (window.ShadyStyling) {
      ShadyStyling.updateStyles();
    }
  };

})();
</script>
