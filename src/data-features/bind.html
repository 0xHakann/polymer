<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../data/bind.html">
<link rel="import" href="../data/bind-effects.html">
<link rel="import" href="../data/bind-annotations.html">

<script>

  /**
   * Needs new name.
   *
   * Support for the declarative property sugaring via a `bind` object
   * on the prototype.
   *
   * Building applications by hand, a pattern emerges: operations such as
   * data propagation need to trigger effects. For example, changes to data
   * need to be reflected into DOM, or trigger additional value computations.
   *
   * This module provides an API for registering effects against properties.
   * The effect data is consumed by the `bind-effects` module which compiles
   * the effects into efficient JavaScript that is triggered, e.g., when a
   * property is set to a new value.
   *
   * Property effects can be created imperatively, by template-annotations
   * (e.g. mustache notation), or by declaration in the `bind` object.
   *
   * The bind object syntax is as follows:
   *
   * bind {
   *   // if `method` is the name of a method on the current object, the
   *   // method is invoked with the property changes. The method is provided
   *   // arguments as follows: `method(value, oldValue)`
   *   property: 'method'
   *
   *   // if the value is not the name of a method, it's assumed to be a
   *   // id of an element in the `$` hash. Remember that when using a
   *   // template, `$` maps element ids to elements. By default, changes in
   *   // the named property are sent to the target element's `textContent`.
   *   // In this case, when `property2` changes, it's value is set to
   *   // `this.$.myId.textContent`.
   *   property2: 'myId'
   *
   *   // A target property other than `textContent` can be specified using
   *   // dot notation. In this case, when `property3` changes, it's value is
   *   // set to `this.$.myId.value`.
   *   property3: 'myId.value'
   *
   *   // To have a property modification trigger multiple side effects, use
   *   // an array.
   *   property4: [
   *    'property4Changed',
   *    'myId.data',
   *    'otherId.value'
   *   ]
   * }
   *
   * @class feature: bind
   */

  using(['bind', 'annotations-bind'], function(Bind, Annotations) {

    // TODO(sjmiles): note 'true' argument at the bottom causing this feature
    // to be inserted at the top of the features list. This was a quick-fix.

    Base.addFeature({

      // prototyping

      register: function(prototype) {
        Bind.prepareModel(prototype);
        prototype._addPropertyBindEffects(prototype.bind);
      },

      finishBindRegistration: function() {
        var annotes = this._template && this._template.map;
        if (annotes) {
          Annotations.preprocessBindAnnotations(this, annotes);
        }
        Bind.createBindings(this);
      },

      addPropertyEffect: function(property, kind, effect) {
        return Bind.addPropertyEffect(this, property, kind, effect);
      },

      _addPropertyBindEffects: function(effects) {
        for (var n in effects) {
          var effect = effects[n];
          if (typeof effect === 'object') {
            // multiplexed definition
            for (var nn in effect) {
              this._addPropertyBindEffect(n, effect[nn]);
            }
          } else {
            // single definition
            this._addPropertyBindEffect(n, effect);
          }
        }
      },

      _addPropertyBindEffect: function(property, effect) {
        var kind = 'bind';
        if (typeof this[effect] === 'function') {
          kind = 'method';
        }
        this.addPropertyEffect(property, kind, effect);
      },

      // instancing

      init: function() {
        Bind.prepareInstance(this);
      },

      // Bind module facade

      _createBindings: function() {
        Bind.createBindings(this);
      },

      _setupBindListeners: function() {
        Bind.setupBindListeners(this);
      }

    }, true);

  });

</script>
