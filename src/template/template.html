<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>
/**
 * Scans a template to produce an annotation list that that associates
 * metadata culled from markup with tree locations 
 * metadata and information to associate the metadata with nodes in an instance.
 *
 * Supported expressions include:
 *
 * Double-mustache annotations in text content. The annotation must be the only
 * content in the tag, compound expressions are not supported.
 *
 *     <[tag]>{{annotation}}<[tag]>
 *
 * Double-escaped annotations in an attribute, either {{}} or [[]].
 *
 *     <[tag] someAttribute="{{annotation}}" another="[[annotation]]"><[tag]>
 *
 * `on-` style event declarations.
 *
 *     <[tag] on-<event-name>="annotation"><[tag]>
 *
 * Note that the `annotations` feature does not implement any behaviors
 * associated with these expressions, it only captures the data.
 *
 * Generated data-structure:
 * 
 *     [
 *       {
 *         id: '<id>',
 *         events: [
 *           {
 *             name: '<name>'
 *             value: '<annotation>'
 *           }, ...
 *         ],
 *         bindings: [
 *           {
 *             kind: ['text'|'attribute'],
 *             mode: ['{'|'['],
 *             name: '<name>'
 *             value: '<annotation>'
 *           }, ...
 *         ],
 *         // TODO(sjmiles): confusingly, this is annotation-parent, not node-parent
 *         parent: <reference to parent annotation object>,
 *         index: <integer index in parent's childNodes collection>
 *       },
 *       ...
 *     ]
 * 
 * @class Template feature
 */

  Template = {

    // instance-time

    instanceTemplate: function(template) {
      return document.importNode(template.content, true);
    },

    findAnnotatedNode: function(root, annote) {
      if (!annote.parent) {
        return root;
      }
      var parent = this.findAnnotatedNode(root, annote.parent);
      // enforce locality
      var nodes = (parent === this) ? parent.childNodes :
        (parent.lightChildren || parent.childNodes);
      return nodes[annote.index];
    },

    setupAnnotatedListeners: function(map, root, scope) {
      map.forEach(function(annotation) {
        Template._setupListeners(annotation.events, root, scope);
      });
    },

    _setupListeners: function(events, root, scope) {
      if (events && events.length) {
        var node = Template.findAnnotatedNode(root, annotation);
        events.forEach(function(e) {
          //console.log('[%s] listening for [%s] on [%s]', e.value, e.name, node.localName);
          Template.listen(node, e.name, e.value, scope);
        });
      }
    },

    listen: function(node, eventName, methodName, scope) {
      node.addEventListener(eventName, function(e) {
        if (scope[methodName]) {
          scope[methodName](e, e.detail);
        } else {
          console.warn('[%s].[%s]: handler [%s] is null in scope (%o)', 
            node.localName, eventName, methodName, scope);
        }
      });
    },

    // preprocess-time

    parseAnnotations: function(template) {
      var list = [];
      this._parseNodeAnnotations(template.content, list);
      return list;
    },

    _parseNodeAnnotations: function(node, list) {
      return node.nodeType === Node.TEXT_NODE ?
        this._parseTextNodeAnnotation(node, list) :
          this._parseElementAnnotations(node, list);
    },

    _parseTextNodeAnnotation: function(node, list) {
      var v = node.textContent, escape = v.slice(0, 2);
      if (escape === '{{' || escape === '[[') {
        var annote = {
          bindings: [{
            kind: 'text',
            mode: escape[0],
            value: v.slice(2, -2)
          }]
        };
        // NOTE: use a space here so the textNode remains; some browsers
        // (IE) evacipate an empty textNode.
        node.textContent = ' ';
        list.push(annote);
        return annote;
      }
    },

    _parseElementAnnotations: function(node, list) {
      var annote = {
        bindings: [],
        events: []
      };
      this._parseChildNodesAnnotations(node, annote, list);
      if (node.attributes) {
        this._parseNodeAttributeAnnotations(node, annote, list);
      }
      if (annote.bindings.length || annote.events.length || annote.id) {
        list.push(annote);
      }
      return annote;
    },

    _parseChildNodesAnnotations: function(root, annote, list) {
      if (root.firstChild) {
        for (var i=0, node=root.firstChild; node; node=node.nextSibling, i++) {
          var childAnnotation = this._parseNodeAnnotations(node, list);
          if (childAnnotation) {
            childAnnotation.parent = annote;
            childAnnotation.index = i;
          }
        }
      }
    },

    _parseNodeAttributeAnnotations: function(node, annotation) {
      for (var i=0, a; (a=node.attributes[i]); i++) {
        var n = a.name, v = a.value;
        // id
        if (n === 'id') {
          annotation.id = v;
        }
        // events (on-*)
        else if (n.slice(0, 3) === 'on-') {
          i--;
          node.removeAttribute(n);
          annotation.events.push({
            name: n.slice(3),
            value: v
          });
        }
        // bindings (other attributes)
        else {
          var b = this._parseNodeAttributeAnnotation(node, n, v);
          if (b) {
            i--;
            annotation.bindings.push(b);
          }
        }
      }
    },

    _parseNodeAttributeAnnotation: function(node, n, v) {
      var mode = '', escape = v.slice(0, 2);
      if (escape === '{{' || escape === '[[') {
        mode = escape[0];
        v = v.slice(2, -2);
      }
      if (mode) {
        node.removeAttribute(n);
        return {
          kind: 'attribute',
          mode: mode,
          name: n,
          value: v
        };
      }
    }

  };

</script>
