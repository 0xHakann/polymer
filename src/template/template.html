<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="annotations.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<script>
(function() {

  'use strict';

/**
 * Scans a template to produce an annotation object that stores expression
 * metadata along with information to associate the metadata with nodes in an
 * instance.
 *
 * Elements with `id` in the template are noted and marshaled into an
 * the `$` hash in an instance.
 *
 * Example
 *
 *     &lt;template>
 *       &lt;div id="foo">&lt;/div>
 *     &lt;/template>
 *     &lt;script>
 *      Polymer({
 *        task: function() {
 *          this.$.foo.style.color = 'red';
 *        }
 *      });
 *     &lt;/script>
 *
 * Other expressions that are noted include:
 *
 * Double-mustache annotations in text content. The annotation must be the only
 * content in the tag, compound expressions are not (currently) supported.
 *
 *     <[tag]>{{path.to.host.property}}<[tag]>
 *
 * Double-mustache annotations in an attribute.
 *
 *     <[tag] someAttribute="{{path.to.host.property}}"><[tag]>
 *
 * Only immediate host properties can automatically trigger side-effects.
 * Setting `host.path` in the example above triggers the binding, setting
 * `host.path.to.host.property` does not.
 *
 * `on-` style event declarations.
 *
 *     <[tag] on-<event-name>="{{hostMethodName}}"><[tag]>
 *
 * Note: **the `annotations` feature does not actually implement the behaviors
 * associated with these expressions, it only captures the data**.
 *
 * Other optional features contain actual data implementations.
 *
 * @class standard feature: annotations
 */

/*

Scans a template to produce an annotation map that stores expression metadata
and information that associates the metadata to nodes in a template instance.

Supported annotations are:

  * id attributes
  * binding annotations in text nodes
    * double-mustache expressions: {{expression}}
    * double-bracket expressions: [[expression]]
  * binding annotations in attributes
    * attribute-bind expressions: name="{{expression}} || [[expression]]"
    * property-bind expressions: name*="{{expression}} || [[expression]]"
    * property-bind expressions: name:="expression"
  * event annotations
    * event delegation directives: on-<eventName>="expression"

Generated data-structure:

  [
    {
      id: '<id>',
      events: [
        {
          mode: ['auto'|''],
          name: '<name>'
          value: '<expression>'
        }, ...
      ],
      bindings: [
        {
          kind: ['text'|'attribute'|'property'],
          mode: ['auto'|''],
          name: '<name>'
          value: '<expression>'
        }, ...
      ],
      // TODO(sjmiles): confusingly, this is annotation-parent, not node-parent
      parent: <reference to parent annotation>,
      index: <integer index in parent's childNodes collection>
    },
    ...
  ]

TODO(sjmiles): this module should produce either syntactic metadata
(e.g. double-mustache, double-bracket, star-attr), or semantic metadata
(e.g. manual-bind, auto-bind, property-bind). Right now it's half and half.

*/

  // import
  var EventListeners = Polymer.GestureEventListeners;

  Polymer.Template = {

    // construct `$` map (from id annotations)
    createIdMap: function(dom, notes) {
      var map = {};
      for (var i=0, l=notes.length, a; (i<l) && (a=notes[i]); i++) {
        if (a.id) {
          map[a.id] = Polymer.Annotations.findAnnotatedNode(dom, a);
        }
      }
      return map;
    },

    // install event listeners (from event annotations)
    installEventListeners: function(dom, notes, host) {
      for (var i=0, l=notes.length, a; (i<l) && (a=notes[i]); i++) {
        if (a.events && a.events.length) {
          var node = Polymer.Annotations.findAnnotatedNode(dom, a);
          for (var j=0, e$=a.events, e; (j<e$.length) && (e=e$[j]); j++) {
            this.addMethodListener(node, e.name, e.value, host);
          }
        }
      }
    },

    addMethodListener: function(node, eventName, methodName, host) {
      EventListeners.addMethodListener(node, eventName, methodName, host);
    },

    // push configuration references at configure time
    installTemplateContent: function(dom, notes) {
      for (var i=0; i<notes.length; i++) {
        var a = notes[i];
        if (a.templateContent) {
          var node = Polymer.Annotations.findAnnotatedNode(dom, a);
          node._content = a.templateContent;
        }
      }
    },

    stamp: function(template, inst) {
      Polymer.Annotations.parseAnnotations(template);
      var notes = template.content._notes;
      var dom = document.importNode(template.content, true);
      inst.$ = this.createIdMap(dom, notes);
      this.installTemplateContent(dom, notes);
      this.installEventListeners(dom, notes, inst);
      return dom;
    }

  };

})();
</script>
