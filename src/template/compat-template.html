<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../events/compat-events.html">
<link rel="import" href="template.html">
<script>
(function() {

  'use strict';
  /**
   * Automatic template management.
   *
   * The `template` feature locates and instances a `<template>` element
   * corresponding to the current Polymer prototype.
   *
   * The `<template>` element may be immediately preceeding the script that
   * invokes `Polymer()`.
   *
   * @class standard feature: template
   */

  // imports
  var CompatEvents = Polymer.CompatEvents;

  var CompatTemplate = Object.create(Polymer.Template);

  Polymer.Utils.mixin(CompatTemplate, {

    _prepTemplate: function(proto) {
      // locate template using dom-module
      if (proto._template === undefined) {
        proto._template = Polymer.DomModule.import(proto.is, 'template');
      }
      // stick finger in footgun
      if (proto._template && proto._template.hasAttribute('is')) {
        // TODO(sorvell): logging
        // this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' +
        //   'must not be a type-extension, found', this._template,
        //   'Move inside simple <template>.'));
      }
      // bootstrap the template if it has not already been
      if (proto._template && !proto._template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(proto._template);
      }
    },

    addMethodListener: function(node, eventName, methodName, host) {
      CompatEvents.addMethodListener(node, eventName, methodName, host);
    }
  });

  CompatTemplate.Mixin = {

    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @method instanceTemplate
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate: function(template) {
      var dom =
        document.importNode(template._content || template.content, true);
      return dom;
    },

    /**
     * Rewrites a given URL relative to the original location of the document
     * containing the `dom-module` for this element.  This method will return
     * the same URL before and after vulcanization.
     *
     * @method resolveUrl
     * @param {string} url URL to resolve.
     * @return {string} Rewritten URL relative to the import
     */
    resolveUrl: function(url) {
      // TODO(sorvell): do we want to put the module reference on the prototype?
      var module = Polymer.DomModule.import(this.is);
      var root = '';
      if (module) {
        var assetPath = module.getAttribute('assetpath') || '';
        root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
      }
      return Polymer.ResolveUrl.resolveUrl(url, root);
    }

  };

  Polymer.CompatTemplate = CompatTemplate;

})();
</script>
