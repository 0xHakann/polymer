<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/compat-utils.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">

<script>
(function() {

  'use strict';

  var utils = Polymer.Utils;
  var caseMap = Polymer.CaseMap;
  var behaviors = Polymer.Behaviors;
  var events = new Polymer.GestureEventListeners();
  var templateStamp = new Polymer.TemplateStamp(events);
  var attributes = new Polymer.AttributeToFromProperty();
  var data = new Polymer.MetaEffects(templateStamp, attributes);

  Polymer.Base = {

    // Used for `isInstance` type checking; cannot use `instanceof` because
    // there is no common Polymer.Base in the prototype chain between type
    // extensions and normal custom elements
    __isPolymerInstance__: true,

    createdCallback: function() {
      var proto = this.constructor.prototype;
      if (!proto.hasOwnProperty('__hasRegisterFinished')) {
        proto.__hasRegisterFinished = true;
        var meta = behaviors.register(proto);
        if (meta.properties) {
          data.createProperties(proto, meta.properties);
        }
        if (meta.observers) {
          data.createMultiObservers(proto, meta.observers);
        }
        if (proto._template === undefined) {
          proto._template = Polymer.DomModule.import(proto.is, 'template');
        }
        if (proto._template) {
          Polymer.StyleUtil.prepStyleIncludes(proto._template.content);
          data.bindTemplate(proto, proto._template);
        } else {
          // non-template elements always initialize.
          proto.initializeWhenCreated = true;
        }
        behaviors.callMethod(proto, 'registered');
      }
      Polymer.telemetry.instanceCount++;
      // apply defaults first.
      data.applyPropertyDefaults(this);
      // TODO(sorvell): remove when using V1 Custom Elements.
      attributes.simulateV1AttributeCallbacks(this);
      behaviors.callMethod(this, 'created');
      // TODO(sorvell): doc!! elements can set this flag if they must 
      // initilize when created and not attached.
      if (this.initializeWhenCreated) {
        this.ensureInitialized();
      }
    },

    // reserved for canonical behavior
    attachedCallback: function() {
      this.ensureInitialized();
      this.isAttached = true;
      behaviors.callMethod(this, 'attached');
    },

    ensureInitialized: function() {
      if (this.__initialized) {
        return;
      }
      this.__initialized = true;
      if (this.__meta.listeners) {
        var l$ = this.__meta.listeners;
        for (var i=0, l; (i<l$.length) && (l=l$[i]); i++) {
          events.addMethodListener(this, l.event, l.method);
        }
      }
      if (this.__meta.hostAttributes) {
        var a$ = this.__meta.hostAttributes;
        for (var a in a$) {
          attributes.ensureAttribute(this, a$[a], a);
        }
      }
      if (this._template) {
        var dom = data.stamp(this._template, this);
        this.root = this.createShadowRoot();
        data.configureProperties(this);
        this.root.appendChild(dom);
      } else {
        this.root = this;
        data.configureProperties(this);
      }
      behaviors.callMethod(this, 'ready');
    },

    // reserved for canonical behavior
    detachedCallback: function() {
      this.isAttached = false;
      behaviors.callMethod(this, 'detached');
    },

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @method extend
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend: function(prototype, api) {
      return utils.extend(prototype, api);
    },

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @method mixin
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin: function(target, source) {
      return utils.mixin(target, source);
    },

    // TODO(sorvell): move out of here?
    chainObject: function(object, inherited) {
      if (object && inherited && object !== inherited) {
        if (!Object.__proto__) {
          object = this.extend(Object.create(inherited), object);
        }
        object.__proto__ = inherited;
      }
      return object;
    },

    /* **** Begin Template **** */
    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @method instanceTemplate
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate: function(template) {
      var dom =
        document.importNode(template._content || template.content, true);
      return dom;
    },

    /**
     * Rewrites a given URL relative to the original location of the document
     * containing the `dom-module` for this element.  This method will return
     * the same URL before and after vulcanization.
     *
     * @method resolveUrl
     * @param {string} url URL to resolve.
     * @return {string} Rewritten URL relative to the import
     */
    resolveUrl: function(url) {
      // TODO(sorvell): do we want to put the module reference on the prototype?
      var module = Polymer.DomModule.import(this.is);
      var root = '';
      if (module) {
        var assetPath = module.getAttribute('assetpath') || '';
        root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
      }
      return Polymer.ResolveUrl.resolveUrl(url, root);
    },
    /* **** End Template **** */

    /* **** Begin Attributes **** */
    attributeChangedCallback: function(name, old, value) {
      var property = caseMap.dashToCamelCase(name);
      var info = this.__meta.properties && this.__meta.properties[property];
      
      if (info && !info.readOnly) {
        attributes.attributeToProperty(this, name, value, info.type);
      }
      behaviors.callMethod(this, 'attributeChanged', [name, old, value]);
    },

    serialize: function(value) {
      return attributes.serialize(value);
    },

    deserialize: function(value, type) {
      return attributes.deserialize(value, type);
    },

    reflectPropertyToAttribute: function(property, attribute, value) {
      attributes.propertyToAttribute(this, property, attribute, value);
    },

    serializeValueToAttribute: function(value, attribute, node) {
      node = node || this;
      attributes.valueToAttribute(node, value, attribute, value);
    },

    /* **** End Attributes **** */

    /* **** Begin Events **** */
    fire: function(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      var event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable)
      });
      event.detail = detail;
      var node = options.node || this;
      node.dispatchEvent(event)
      return event;
    },

    listen: function(node, eventName, methodName) {
      node = node || this;
      node.__eventHandlers = node.__eventHandlers || {};
      var key = eventName + methodName;
      if (!node.__eventHandlers[key]) {
        node.__eventHandlers[key] = 
          events.addMethodListener(node, eventName, methodName, this);
      }
    },

    unlisten: function(node, eventName, methodName) {
      node = node || this;
      var key = eventName + methodName;
      var handler = node.__eventHandlers && node.__eventHandlers[key];
      if (handler) {
        events.removeListener(node, eventName, handler);
        node.__eventHandlers[key] = null;
      }
    }, 
    
    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @method setScrollDirection
     * @param {String=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {HTMLElement=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection: function(direction, node) {
      node = node || this;
      events.constructor.lib.setTouchAction(node, direction || 'auto');
    }
    /* **** End Events **** */

  };

  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance__);
  };

  // telemetry
  Polymer.telemetry.instanceCount = 0;

  Polymer.Base.mixin(Polymer.Base, Polymer.CompatUtils.Mixin);

  Polymer.V1Element = function() {};
  Polymer.V1Element.prototype = Polymer.Base;

})();
</script>
