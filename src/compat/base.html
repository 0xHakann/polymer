<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/compat-utils.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../events/compat-events.html">
<link rel="import" href="../attributes/compat-attributes.html">
<link rel="import" href="../template/compat-template.html">
<link rel="import" href="../properties/compat-data.html">

<script>
(function() {

  'use strict';

  var Utils = Polymer.Utils;
  var Behaviors = Polymer.CompatBehaviors;
  var Data = Polymer.CompatData;
  var Events = Polymer.CompatEvents;
  var Template = Polymer.CompatTemplate;
  var Attributes = Polymer.CompatAttributes;

  Polymer.Base = {

    // Used for `isInstance` type checking; cannot use `instanceof` because
    // there is no common Polymer.Base in the prototype chain between type
    // extensions and normal custom elements
    __isPolymerInstance__: true,

    // `this` context is a prototype, not an instance
    registerCallback: function() {
      this._template = Template.prepTemplate(this, this._template);
      // new behaviors / meta (ignores any behaviors from superclass)
      var behaviors = this.hasOwnProperty('behaviors') ? 
        Behaviors.prepBehaviors(this, this.behaviors) : [];
      var meta = Behaviors.createMeta(this, behaviors);
      if (meta.properties) {
        Data.createProperties(this, meta.properties);
      }
      if (meta.observers) {
        Data.createMultiObservers(this, meta.observers);
      }
      // create meta/behaviors for runtime processing (merge with superclass)
      if (this.__meta) {
        this.__meta = Behaviors.copyMeta(this.__meta);
        Behaviors.mergeMeta(this.__meta, meta);
      } else {
        this.__meta = meta;  
      }
      this.__behaviors = this.__behaviors ? this.__behaviors.concat(behaviors) :
        behaviors;
      if (this._template) {
        Polymer.StyleUtil.prepStyleIncludes(this._template.content);
        Data.bindTemplate(this, this._template);
      }
      Behaviors.callMethod(this, 'registered');
    },

    createdCallback: function() {
      Polymer.telemetry.instanceCount++;
      Behaviors.callMethod(this, 'created');
      if (this.__meta.listeners) {
        Events.addListeners(this, this.__meta.listeners);
      }
      if (this.__meta.hostAttributes) {
        Attributes.applyAttributes(this, this.__meta.hostAttributes);
      }
      if (this._template) {
        var dom = Data.stamp(this._template, this);
        this.root = this.createShadowRoot();
        Data.configureProperties(this);
        this.root.appendChild(dom);
      } else {
        this.root = this;
        Data.configureProperties(this);
      }
      Behaviors.callMethod(this, 'ready');
    },

    // reserved for canonical behavior
    attachedCallback: function() {
      this.isAttached = true;
      Behaviors.callMethod(this, 'attached');
    },

    // reserved for canonical behavior
    detachedCallback: function() {
      this.isAttached = false;
      Behaviors.callMethod(this, 'detached');
    },

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @method extend
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend: function(prototype, api) {
      return Utils.extend(prototype, api);
    },

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @method mixin
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin: function(target, source) {
      return Utils.mixin(target, source);
    },

    // TODO(sorvell): move out of here?
    chainObject: function(object, inherited) {
      if (object && inherited && object !== inherited) {
        if (!Object.__proto__) {
          object = this.extend(Object.create(inherited), object);
        }
        object.__proto__ = inherited;
      }
      return object;
    }

  };

  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance__);
  };

  // telemetry
  Polymer.telemetry.instanceCount = 0;

  // TODO(sorvell): avoid doing this? seeing everything public on this prototype
  // is probably useful.
  Polymer.Base.mixin(Polymer.Base, Events.Mixin);
  Polymer.Base.mixin(Polymer.Base, Attributes.Mixin);
  Polymer.Base.mixin(Polymer.Base, Template.Mixin);
  Polymer.Base.mixin(Polymer.Base, Polymer.CompatUtils.Mixin);

  Polymer.Element = function() {};
  Polymer.Element.prototype = Polymer.Base;

})();
</script>
