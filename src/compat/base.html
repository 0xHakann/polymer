<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/compat-utils.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../events/gestures.html">
<link rel="import" href="../events/event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">

<script>
(function() {

  'use strict';

  var Utils = Polymer.Utils;
  var CaseMap = Polymer.CaseMap;
  var Behaviors = Polymer.Behaviors;
  var Events = new Polymer.EventListeners(Polymer.Gestures);
  var Attributes = new Polymer.AttributeToFromProperty();
  var TemplateStamp = new Polymer.TemplateStamp(Events);
  var Data = new Polymer.MetaEffects(TemplateStamp, Attributes);

  Polymer.Base = {

    // Used for `isInstance` type checking; cannot use `instanceof` because
    // there is no common Polymer.Base in the prototype chain between type
    // extensions and normal custom elements
    __isPolymerInstance__: true,

    // `this` context is a prototype, not an instance
    registerCallback: function() {
      if (this._template === undefined) {
        this._template = Polymer.DomModule.import(this.is, 'template');
      }
      // new behaviors / meta (ignores any behaviors from superclass)
      var behaviors = this.hasOwnProperty('behaviors') ? 
        Behaviors.prepBehaviors(this, this.behaviors) : [];
      var meta = Behaviors.createMeta(this, behaviors);
      if (meta.properties) {
        Data.createProperties(this, meta.properties);
      }
      if (meta.observers) {
        Data.createMultiObservers(this, meta.observers);
      }
      // create meta/behaviors for runtime processing (merge with superclass)
      if (this.__meta) {
        this.__meta = Behaviors.copyMeta(this.__meta);
        Behaviors.mergeMeta(this.__meta, meta);
      } else {
        this.__meta = meta;  
      }
      this.__behaviors = this.__behaviors ? this.__behaviors.concat(behaviors) :
        behaviors;
      if (this._template) {
        Polymer.StyleUtil.prepStyleIncludes(this._template.content);
        Data.bindTemplate(this, this._template);
      }
      Behaviors.callMethod(this, 'registered');
    },

    createdCallback: function() {
      Polymer.telemetry.instanceCount++;
      Behaviors.callMethod(this, 'created');
      if (this.__meta.listeners) {
        var l$ = this.__meta.listeners;
        for (var i=0, l; (i<l$.length) && (l=l$[i]); i++) {
          Events.addMethodListener(this, l.event, l.method);
        }
      }
      if (this.__meta.hostAttributes) {
        Attributes.ensureAttributes(this, this.__meta.hostAttributes);
      }
      if (this._template) {
        var dom = Data.stamp(this._template, this);
        this.root = this.createShadowRoot();
        Data.configureProperties(this);
        this.root.appendChild(dom);
      } else {
        this.root = this;
        Data.configureProperties(this);
      }
      Behaviors.callMethod(this, 'ready');
    },

    // reserved for canonical behavior
    attachedCallback: function() {
      this.isAttached = true;
      Behaviors.callMethod(this, 'attached');
    },

    // reserved for canonical behavior
    detachedCallback: function() {
      this.isAttached = false;
      Behaviors.callMethod(this, 'detached');
    },

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @method extend
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend: function(prototype, api) {
      return Utils.extend(prototype, api);
    },

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @method mixin
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin: function(target, source) {
      return Utils.mixin(target, source);
    },

    // TODO(sorvell): move out of here?
    chainObject: function(object, inherited) {
      if (object && inherited && object !== inherited) {
        if (!Object.__proto__) {
          object = this.extend(Object.create(inherited), object);
        }
        object.__proto__ = inherited;
      }
      return object;
    },

    /* **** Begin Template **** */
    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @method instanceTemplate
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate: function(template) {
      var dom =
        document.importNode(template._content || template.content, true);
      return dom;
    },

    /**
     * Rewrites a given URL relative to the original location of the document
     * containing the `dom-module` for this element.  This method will return
     * the same URL before and after vulcanization.
     *
     * @method resolveUrl
     * @param {string} url URL to resolve.
     * @return {string} Rewritten URL relative to the import
     */
    resolveUrl: function(url) {
      // TODO(sorvell): do we want to put the module reference on the prototype?
      var module = Polymer.DomModule.import(this.is);
      var root = '';
      if (module) {
        var assetPath = module.getAttribute('assetpath') || '';
        root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
      }
      return Polymer.ResolveUrl.resolveUrl(url, root);
    },
    /* **** End Template **** */

    /* **** Begin Attributes **** */
    attributeChangedCallback: function(name, oldValue, newValue) {
      var property = CaseMap.dashToCamelCase(name);
      var info = this.__meta.properties && this.__meta.properties[property];
      if (info && !info.readOnly) {
        Attributes.attributeToProperty(this, info.attribute, property, 
          info.type);
      }
      Behaviors.callMethod(this, 'attributeChanged', 
        [name, oldValue, newValue]);
    },

    serialize: function(value) {
      return Attributes.serialize(value);
    },

    deserialize: function(value, type) {
      return Attributes.deserialize(value, type);
    },

    reflectPropertyToAttribute: function(property, attribute, value) {
      Attributes.propertyToAttribute(this, property, attribute, value);
    },

    serializeValueToAttribute: function(value, attribute, node) {
      node = node || this;
      Attributes.valueToAttribute(node, value, attribute, value);
    },

    /* **** End Attributes **** */

    /* **** Begin Events **** */
    fire: function(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      var event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable)
      });
      event.detail = detail;
      var node = options.node || this;
      node.dispatchEvent(event)
      return event;
    },

    listen: function(node, eventName, methodName) {
      node = node || this;
      node.__eventHandlers = node.__eventHandlers || {};
      var key = eventName + methodName;
      if (!node.__eventHandlers[key]) {
        node.__eventHandlers[key] = 
          Events.addMethodListener(node, eventName, methodName, this);
      }
    },

    unlisten: function(node, eventName, methodName) {
      node = node || this;
      var key = eventName + methodName;
      var handler = node.__eventHandlers && node.__eventHandlers[key];
      if (handler) {
        Events.removeListener(node, eventName, handler);
        node.__eventHandlers[key] = null;
      }
    }, 
    
    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @method setScrollDirection
     * @param {String=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {HTMLElement=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection: function(direction, node) {
      node = node || this;
      Polymer.Gestures.setTouchAction(node, direction || 'auto');
    }
    /* **** End Events **** */

  };

  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance__);
  };

  // telemetry
  Polymer.telemetry.instanceCount = 0;

  Polymer.Base.mixin(Polymer.Base, Polymer.CompatUtils.Mixin);

  Polymer.V1Element = function() {};
  Polymer.V1Element.prototype = Polymer.Base;

})();
</script>
