<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/utils.html">
<script>
(function() {
  'use strict';

  Polymer.Behaviors = {

    metaProperties: {
      hostAttributes: true,
      properties: true,
      observers: true,
      listeners: true,
    },
    
    metaMethods: {
      beforeRegister: true,
      registered: true,
      created: true,
      attached: true,
      detached: true,
      attributeChanged: true,
      ready: true
    },

    mixinBehaviors: function(prototype, behaviors) {
      var base = prototype.__proto__;
      for (var i=behaviors.length-1, a=prototype, b; i >= 0; i--) {
        b = behaviors[i];
        if (!this.hasBehavior(prototype, b)) {
          a = this.mixinProto(a, b);
        }
      }
      // now put original prototype at the bottom
      a.__proto__ = base;
    },

    mixinProto: function(prototype, supr) {
      supr = Polymer.Utils.extend({}, supr);
      prototype.__proto__ = supr;
      return supr;
    },

    hasBehavior: function(prototype, behavior) {
      while (prototype) {
        if (behavior === prototype) {
          return true;
        }
        prototype = prototype.__proto__;
      }
    },

    // hostAttributes: yougest wins
    // properties: 
    // observers: additive
    // listeners: additive
    mergeMeta: function(prototype) {
    },

    // TODO(sorvell): experimental!!
    // options:
    // 1. fallback to 1.0 way of calling the stack of behavior methods auto.
    // 2. require es6
    // 3. wrap functions with super proto in the closure.
    // 4. something like this...
    callSuper: function(methodName, args) {
      args = args ? Array.prototype.slice.call(args) : [];
      var lastArg = args[args.length-1];
      var proto = Polymer.isInstance(lastArg) ? args.pop() : this.__proto__;
      var next = proto.__proto__;
      if (next[methodName]) {
        args.push(next);
        next[methodName].apply(this, args);
      }
    }

  };

  Polymer.Behaviors.Mixin = {
    callSuper: Polymer.Behaviors.callSuper
  };

})();
</script>
