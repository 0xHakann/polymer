<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/case-map.html">
<script>
(function() {

  'use strict';

  // 'import'
  var CaseMap = Polymer.CaseMap;
  var Utils = Polymer.Utils;

  /**
   * Automatically extend using objects referenced in `behaviors` array.
   *
   *     someBehaviorObject = {
   *       accessors: {
   *        value: {type: Number, observer: '_numberChanged'}
   *       },
   *       observers: [
   *         // ...
   *       ],
   *       ready: function() {
   *         // called before prototoype's ready
   *       },
   *       _numberChanged: function() {}
   *     };
   *
   *     Polymer({
   *
   *       behaviors: [
   *         someBehaviorObject
   *       ]
   *
   *       ...
   *
   *     });
   *
   * Each behavior object may define lifecycle callbacks, `properties`,
   * `hostAttributes`, `observers` and `listeners`.
   *
   * Lifecycle callbacks will be called for each behavior in the order given
   * in the `behaviors` array, followed by the callback on the prototype.
   * Additionally, any non-lifecycle functions on the behavior object are
   * mixed into the base prototype, such that same-named functions on the
   * prototype take precedence, followed by later behaviors over earlier
   * behaviors.
   * @class base feature: behaviors
   */

  Polymer.Behaviors = {

    // special properties on behaviors are not mixed in and are instead
    // either processed specially (e.g. listeners, properties) or available
    // for calling via doBehavior (e.g. created, ready)
    _behaviorProperties: {

      // elminate?
      created: true,
      beforeRegister: true,
      //
      hostAttributes: true,
      properties: true,
      observers: true,
      listeners: true,
      registered: true,
      attached: true,
      detached: true,
      attributeChanged: true,
      ready: true

    },

    register: function(proto) {
      // new behaviors / meta (ignores any behaviors from superclass)
      var behaviors = proto.hasOwnProperty('behaviors') ?
        this.prepBehaviors(proto, proto.behaviors) : [];
      var meta = this.createMeta(proto, behaviors);
      // create meta/behaviors for runtime processing (merge with superclass)
      if (proto.__meta) {
        proto.__meta = this.copyMeta(proto.__meta);
        this.mergeMeta(proto.__meta, meta);
      } else {
        proto.__meta = meta;
      }
      proto.__behaviors = this.__behaviors ?
        this.__behaviors.concat(behaviors) :
        behaviors;
      return meta;
    },

    createObservedAttributes(proto) {
      // TODO(sorvell): remove when using V1 custom elements.
      var ctor = proto.constructor;
      if (!ctor.hasOwnProperty('observedAttributes')) {
        ctor.observedAttributes =
          ctor.observedAttributes ?
          ctor.observedAttributes.slice() : [];
      }
      var attrs = ctor.observedAttributes;
      if (proto.behaviors) {
        for (var i=0; i<proto.behaviors.length; i++) {
          this._accumulateObservedAttributes(attrs, proto.behaviors[i]);
        }
      }
      this._accumulateObservedAttributes(attrs, proto);
    },

    _accumulateObservedAttributes(attrs, behavior) {
      if (behavior.properties) {
        for (var prop in behavior.properties) {
          var attr = Polymer.CaseMap.camelToDashCase(prop);
          if (attrs.indexOf(attr) < 0) {
            attrs.push(attr);
          }
        }
      }
    },

    /**
     * Array of objects to extend this prototype with.
     *
     * Each entry in the array may specify either a behavior object or array
     * of behaviors.
     *

     */
    prepBehaviors: function(prototype, behaviors) {
      var behaviorSet = [];
      // iteration 1
      behaviors = behaviors ? this._flattenBehaviorsList(behaviors) : [];
      // iteration 2
      // traverse the behaviors in _reverse_ order (youngest first) because
      // `_mixinBehavior` has _first property wins_ behavior, this is done
      // to optimize # of calls to `_copyOwnProperty`
      for (var i=behaviors.length-1; i>=0; i--) {
        var b = behaviors[i];
        if (behaviorSet.indexOf(b) === -1) {
          this._mixinBehavior(b, prototype);
          behaviorSet.unshift(b);
        }
      }
      return behaviorSet;
    },

    _flattenBehaviorsList: function(behaviors) {
      var flat = [];
      for (var i=0; i < behaviors.length; i++) {
        var b = behaviors[i];
        if (b instanceof Array) {
          flat = flat.concat(this._flattenBehaviorsList(b));
        }
        // filter out null entries so other iterators don't need to check
        else if (b) {
          flat.push(b);
        } else {
          console.warn('_flattenBehaviorsList: behavior is null, check for missing or 404 import');
        }
      }
      return flat;
    },

    _mixinBehavior: function(b, prototype) {
      var n$ = Object.getOwnPropertyNames(b);
      for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        if (!this._behaviorProperties[n] && !prototype.hasOwnProperty(n)) {
          Utils.copyOwnProperty(n, b, prototype);
        }
      }
    },

    callMethod: function(host, name, args) {
      var b$ = host.__behaviors;
      if (b$) {
        for (var i=0; i < b$.length; i++) {
          this._invokeMethod(host, b$[i], name, args);
        }
      }
      this._invokeMethod(host, host, name, args);
    },

    _invokeMethod: function(host, behavior, name, args) {
      var fn = behavior[name];
      if (fn) {
        fn.apply(host, args);
      }
    },

    createMeta: function(host, behaviors) {
      var b$ = behaviors ? behaviors.slice() : [];
      b$.push({
        listeners: host.hasOwnProperty('listeners') && host.listeners,
        hostAttributes: host.hasOwnProperty('hostAttributes') && host.hostAttributes,
        properties: host.hasOwnProperty('properties') && host.properties,
        observers: host.hasOwnProperty('observers') && host.observers
      });
      var meta = {};
      for (var i=0, b; (i<b$.length) && (b=b$[i]); i++) {
        this.mergeMeta(meta, b);
      }
      return meta;
    },

    mergeMeta: function(meta, addProps) {
      if (addProps.listeners) {
        meta.listeners = meta.listeners || [];
        this._addListeners(meta.listeners, addProps.listeners);
      }
      if (addProps.hostAttributes) {
        meta.hostAttributes = meta.hostAttributes || {};
        this._addHostAttributes(meta.hostAttributes, addProps.hostAttributes);
      }
      if (addProps.properties) {
        meta.properties = meta.properties || {};
        this._addProperties(meta.properties, addProps.properties);
      }
      if (addProps.observers) {
        meta.observers = meta.observers || [];
        this._addObservers(meta.observers, addProps.observers);
      }
      return meta;
    },

    copyMeta: function(meta) {
      var copy = {};
      if (meta.listeners) {
        copy.listeners = meta.listeners.slice();
      }
      if (meta.hostAttributes) {
        Object.create(meta.hostAttributes)
      }
      if (meta.properties) {
        copy.properties = {};
        for (var i in meta.properties) {
          copy.properties[i] = Object.create(meta.properties[i]);
        }
      }
      if (meta.observers) {
        copy.observers = meta.observers.slice();
      }
      return copy;
    },

    _addListeners: function(store, addProps) {
      for (var i in addProps) {
        store.push({event: i, method: addProps[i]});
      }
    },

    _addHostAttributes: function(store, addProps) {
      for (var i in addProps) {
        store[i] = addProps[i];
      }
    },

    _addProperties: function(store, addProps) {
      for (var i in addProps) {
        if (typeof addProps[i] !== 'object') {
          addProps[i] = {value: addProps[i]};
        }
        if (!store[i]) {
          store[i] = {
            // TODO(sorvell): optimization, goes elsewhere?
            attribute: CaseMap.camelToDashCase(i)
          };
        }
        this._aggregateProperty(store[i], addProps[i]);
      }
    },

    _aggregateProperty: function(store, add) {
      // type: last wins
      if (add.type) {
        store.type = add.type;
      }
      // value: last wins
      if (add.value !== undefined) {
        store.value = add.value;
      }
      // reflectToAttr: last wins
      if (add.reflectToAttribute) {
        store.reflectToAttribute = add.reflectToAttribute;
      }
      // notify: last wins?
      if (add.notify) {
        store.notify = add.notify;
      }
      // computed: cannot change
      if (!store.computed) {
        store.computed = add.computed;
      }
      // readOnly: truthy wins
      if (!store.readOnly) {
        store.readOnly = Boolean(store.computed) || add.readOnly;
      }
      // observer... convert to array
      if (add.observer) {
        if (store.observer) {
          if (typeof store.observer !== 'object') {
            store.observer = [store.observer];
          }
          store.observer.push(add.observer);
        } else {
          store.observer = add.observer;
        }
      }
    },

    _addObservers: function(store, list) {
      for (var i=0; i<list.length; i++) {
        store.push(list[i]);
      }
    }

  };

})();
</script>
