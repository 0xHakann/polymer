<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/case-map.html">
<link rel="import" href="../utils/async-render.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">
<link rel="import" href="dom-module.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../styling/style-lib.html">

<script>
(function() {

  'use strict';

  var caseMap = Polymer.CaseMap;
  var behaviors = Polymer.Behaviors;
  var events = new Polymer.GestureEventListeners();
  var templateStamp = new Polymer.TemplateStamp(events);
  var attributes = new Polymer.AttributeToFromProperty();
  var data = new Polymer.MetaEffects(templateStamp, attributes);

  var hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length-1];
        data.enqueueClient(host, inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  class CoreElement extends HTMLElement {

    // Non-lazy registration work goes here
    static get observedAttributes() {
      // TODO(kschaaf): revisit: capture import document, to aid finding dom-module
      var currentScript = document._currentScript || document.currentScript;
      this.prototype.__importDoc = currentScript && currentScript.ownerDocument;
      // observedAttributes must be finalized at registration time
      return behaviors._accumulateObservedAttributes(this.prototype, []);
    }

    constructor() {
      super();
      // note: `this.constructor.prototype` is wrong in Safari so make sure to
      // use `__proto__`
      var proto = this.__proto__;
      if (!proto.hasOwnProperty('__hasDecoratedClass')) {
        proto.is = this.localName;
        proto.__hasDecoratedClass = true;
        this.decorateClass();
      } else if (proto.hasOwnProperty('__hasDecoratedClass')) {
        Polymer.StyleLib.prepareHost(this, proto._template);
      }
      Polymer.telemetry.instanceCount++;
      // setup batched effects library; will call initialize when flushing
      data.prepare(this, this.ready);
      // add self to host's pending client list
      hostStack.registerHost(this);
      // apply defaults first.
      data.setPropertyDefaults(this);
    }

    decorateClass() {
      var proto = this.__proto__;
      var meta = behaviors.register(proto);
      if (meta.properties) {
        data.createProperties(proto, meta.properties);
      }
      if (meta.observers) {
        data.createMultiObservers(proto, meta.observers);
      }
      if (proto._template === undefined) {
        proto._template = Polymer.DomModule.import(proto.is, 'template', 
          this.__importDoc);
      }
      if (proto._template) {
        Polymer.CompatStyleUtil.normalizeForBC(proto._template.content);
        Polymer.StyleLib.prepareHost(this, proto._template);
        data.bindTemplate(proto, proto._template);
      }
    }

    // reserved for canonical behavior
    connectedCallback() {
      if (hostStack.isEmpty()) {
        data.flush(this);
        this.updateStyles();
      }
      this.isAttached = true;
    }

    ready() {
      var self = this;
      Polymer.AsyncRender.afterRender(function() {
        self.lazyReady();
      });
      if (!this.root) {
        if (this._template) {
          // BREAKME(sorvell): remove v0 support when we can...
          this.root = Polymer.shadowDomV0 ? this.createShadowRoot() :
            this.attachShadow({mode: 'open'});
        } else {
          this.root = this;
        }
      }
      if (this._template) {
        hostStack.beginHosting(this);
        var dom = data.stamp(this, this._template);
        this.root.appendChild(dom);
        hostStack.endHosting(this);
      }
      data.flush(this);
    }

    lazyReady() {
      if (this.__lazyReadied) {
        return;
      }
      this.__lazyReadied = true;
      if (this.__meta.listeners) {
        var l$ = this.__meta.listeners;
        for (var i=0, l; (i<l$.length) && (l=l$[i]); i++) {
          events.addMethodListener(this, l.event, l.method);
        }
      }
      if (this.__meta.hostAttributes) {
        var a$ = this.__meta.hostAttributes;
        for (var a in a$) {
          attributes.ensureAttribute(this, a, a$[a]);
        }
      }
    }

    // reserved for canonical behavior
    disconnectedCallback() {
      this.isAttached = false;
    }

    /* **** Begin Attributes **** */
    attributeChangedCallback(name, old, value) {
      var property = caseMap.dashToCamelCase(name);
      var info = this.__meta.properties && this.__meta.properties[property];
      if (info && !info.readOnly) {
        attributes.attributeToProperty(this, name, value, info.type);
      }
    }

    serialize(value) {
      return attributes.serialize(value);
    }

    deserialize(value, type) {
      return attributes.deserialize(value, type);
    }

    reflectPropertyToAttribute(property, attribute, value) {
      attributes.propertyToAttribute(this, property, attribute, value);
    }

    serializeValueToAttribute(value, attribute, node) {
      node = node || this;
      attributes.valueToAttribute(node, value, attribute, value);
    }

    updateStyles(properties) {
      Polymer.StyleLib.applyStyle(this, properties);
    }

  }

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance);
  };

  // telemetry
  Polymer.telemetry = Polymer.telemetry || {}
  Polymer.telemetry.instanceCount = 0;

  Polymer.CoreElement = CoreElement;

})();
</script>
