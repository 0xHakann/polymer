<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/case-map.html">
<link rel="import" href="../utils/async-render.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">
<link rel="import" href="dom-module.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../styling/style-lib.html">

<script>
(function() {

  'use strict';

  var utils = Polymer.Utils;
  var caseMap = Polymer.CaseMap;
  var behaviors = Polymer.Behaviors;
  var events = new Polymer.GestureEventListeners();
  var templateStamp = new Polymer.TemplateStamp(events);
  var attributes = new Polymer.AttributeToFromProperty();
  var data = new Polymer.MetaEffects(templateStamp, attributes);

  var hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length-1];
        data.enqueueClient(host, inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  class CoreElement extends HTMLElement {

    /* meta data info:
      At class decoration time, add all of these on the prototype. 
      We create a flattened list of these things and re-add all of them. 
      However, this duplicates work since any already decorated superclasses have already made these observers.
      * properties
      * observers

      At instnace "lazy ready" time, for the class and all superclasses these must be applied.
      We create a flattened list of these things.
      * hostAttributes
      * listeners
    */

    static accumulateMeta(ctor) {
      var meta = ctor.ownMeta;
      if (meta) {
        if (!meta._accumulated) {
          var superCtor = Object.getPrototypeOf(ctor.prototype).constructor;
          var superMeta = ctor.accumulateMeta(superCtor);
          if (superMeta) {
            ctor.mergeListeners(meta, superMeta);
            ctor.mergeHostAttributes(meta, superMeta);
            ctor.mergeObservers(meta, superMeta);
            // should only build properties down to...
            // something with?
            ctor.mergeProperties(meta, superMeta);
          }
          meta._accumulated = true;   
        }
      }
      return meta;
    }

    static mergeListeners(target, source) {
      // create listeners array.
      target._listeners = [];
      if (target.listeners) {
        for (var l in target.listeners) {
          target._listeners.push({event: l, method: target.listeners[l]});
        }
      }
      // concat source listeners
      target._listeners = target._listeners.concat(source._listeners);
    }

    static mergeHostAttributes(target, source) {
      if (target.hostAttributes) {
        if (source.hostAttributes) {
          utils.mixin(target.hostAttributes, source.hostAttributes);
        }
      } else {
        target.hostAttributes = source.hostAttributes || {};
      }
      
    }

    static mergeObservers(target, source) {
      target.observers = target.observers ?
        target.observers.concat(source.observers) : 
        source.observers || [];
    }

    static mergeProperties(target, source) {
      var props = target.properties || {};
      // set defaults in properties
      for (var k in props) {
        var prop = props[k];
        // TODO(sorvell): suppor this? (value shorthand)
        if (typeof prop !== 'object') {
          props[k] = {value: prop};
        }
        prop.attribute = caseMap.camelToDashCase(k);
      }
      // merge other props
      for (var p in source.properties) {
        var sourceProp = source.properties[p];
        if (!props[p]) {
          props[p] = sourceProp;
        } else {
          this.mergeProperty(props[p], sourceProp);
        }
      } 
      target.properties = props;
    }

    static mergeProperty(target, source) {
      // type: last wins
      if (target.type === undefined) {
        target.type = source.type;
      }
      // value: last wins
      if (target.value === undefined) {
        target.value = source.value;
      }
      // reflectToAttr: last wins
      if (!target.reflectToAttribute) {
        target.reflectToAttribute = source.reflectToAttribute;
      }
      // notify: last wins?
      if (!target.notify) {
        target.notify = source.notify;
      }
      // computed: cannot change
      if (source.computed) {
        target.computed = source.computed;
      }
      // readOnly: truthy wins
      if (!target.readOnly) {
        target.readOnly = Boolean(target.computed) || source.readOnly;
      }
      // observer... convert to array
      if (source.observer) {
        if (target.observer) {
          if (typeof target.observer !== 'object') {
            target.observer = [target.observer];
          }
          target.observer.push(source.observer);
        } else {
          target.observer = source.observer;
        }
      }
    }

    // Non-lazy registration work goes here
    static get observedAttributes() {
      // TODO(kschaaf): revisit: capture import document, to aid finding dom-module
      var currentScript = document._currentScript || document.currentScript;
      this.prototype.__importDoc = currentScript && currentScript.ownerDocument;
      // observedAttributes must be finalized at registration time
      return this.accumulateObservedAttributes(this);
    }
    
    static accumulateObservedAttributes(ctor) {
      if (!ctor.hasOwnProperty('_observedAttributes')) {
        var attrs = [];
        // crawl down chain as long as we have accumulate api.
        if (ctor.accumulateObservedAttributes) {
          // TODO(sorvell): better way than manually crawling?
          var superCtor = Object.getPrototypeOf(ctor.prototype).constructor;
          attrs = attrs.concat(ctor.accumulateObservedAttributes(superCtor));
          var meta = ctor.ownMeta;
          if (meta.properties) {
            for (var prop in meta.properties) {
              var attr = Polymer.CaseMap.camelToDashCase(prop);
              if (attrs.indexOf(attr) < 0) {
                attrs.push(attr);
              }
            }
          }
        }
        ctor._observedAttributes = attrs;
      } 
      return ctor._observedAttributes;
    }

    static get ownMeta() {
      if (!this.hasOwnProperty('_ownMeta')) {
        this._ownMeta = this.hasOwnProperty('meta') ? this.meta : {};
      }
      return this._ownMeta;
    }

    constructor() {
      super();
      // note: `this.constructor.prototype` is wrong in Safari so make sure to
      // use `__proto__`
      var proto = Object.getPrototypeOf(this);
      if (this.decorateClass(proto)) {
        Polymer.StyleLib.prepareHost(this, proto._template);
      }
      Polymer.telemetry.instanceCount++;
      // setup batched effects library; will call initialize when flushing
      data.prepare(this, this.ready);
      // add self to host's pending client list
      hostStack.registerHost(this);
      // apply defaults first.
      data.setPropertyDefaults(this, this.constructor.ownMeta.properties);
    }

    decorateClass(proto) {
      if (proto.hasOwnProperty('__hasDecoratedClass')) {
        return true;
      }
      var superProto = Object.getPrototypeOf(proto);
      if (superProto.decorateClass) {
        this.decorateClass(superProto);
      }
      proto.__hasDecoratedClass = true;
      this.constructor.accumulateMeta(proto.constructor);
      var meta = this.constructor.ownMeta;
      if (meta.properties) {
        data.createProperties(proto, meta.properties);
      }
      if (meta.observers) {
        data.createMultiObservers(proto, meta.observers);
      }
      // TODO(sorvell): support more ways to acquire template.
      // this requires `is` on constructor...
      if (proto._template === undefined) {
        proto._template = Polymer.DomModule.import(proto.constructor.is, 
          'template', proto.__importDoc);
      }
      if (proto._template) {
        Polymer.CompatStyleUtil.normalizeForBC(proto._template.content);
        Polymer.StyleLib.prepareHost(this, proto._template);
        data.bindTemplate(proto, proto._template);
      }
    }

    // reserved for canonical behavior
    connectedCallback() {
      if (hostStack.isEmpty()) {
        data.flush(this);
        this.updateStyles();
      }
      this.isAttached = true;
    }

    ready() {
      var self = this;
      Polymer.AsyncRender.afterRender(function() {
        if (!self.__lazyReadied) {
          self.__lazyReadied = true;
          self.lazyReady();
        }
      });
      if (!this.root) {
        if (this._template) {
          // BREAKME(sorvell): remove v0 support when we can...
          this.root = Polymer.shadowDomV0 ? this.createShadowRoot() :
            this.attachShadow({mode: 'open'});
        } else {
          this.root = this;
        }
      }
      if (this._template) {
        hostStack.beginHosting(this);
        var dom = data.stamp(this, this._template);
        this.root.appendChild(dom);
        hostStack.endHosting(this);
      }
      data.flush(this);
    }

    lazyReady() {
      var meta = this.constructor.ownMeta;
      if (meta._listeners) {
        var l$ = meta._listeners;
        for (var i=0, l; (i<l$.length) && (l=l$[i]); i++) {
          events.addMethodListener(this, l.event, l.method);
        }
      }
      if (meta.hostAttributes) {
        var a$ = meta.hostAttributes;
        for (var a in a$) {
          attributes.ensureAttribute(this, a, a$[a]);
        }
      }
    }

    // reserved for canonical behavior
    disconnectedCallback() {
      this.isAttached = false;
    }

    /* **** Begin Attributes **** */
    attributeChangedCallback(name, old, value) {
      var property = caseMap.dashToCamelCase(name);
      var info = this.__meta.properties && this.__meta.properties[property];
      if (info && !info.readOnly) {
        attributes.attributeToProperty(this, name, value, info.type);
      }
    }

    serialize(value) {
      return attributes.serialize(value);
    }

    deserialize(value, type) {
      return attributes.deserialize(value, type);
    }

    reflectPropertyToAttribute(property, attribute, value) {
      attributes.propertyToAttribute(this, property, attribute, value);
    }

    serializeValueToAttribute(value, attribute, node) {
      node = node || this;
      attributes.valueToAttribute(node, value, attribute, value);
    }

    updateStyles(properties) {
      Polymer.StyleLib.applyStyle(this, properties);
    }

  }

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance);
  };

  // telemetry
  Polymer.telemetry = Polymer.telemetry || {}
  Polymer.telemetry.instanceCount = 0;

  Polymer.CoreElement = CoreElement;

})();
</script>
