<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../utils/boot.html">
<link rel="import" href="../utils/case-map.html">
<link rel="import" href="../utils/async-render.html">
<link rel="import" href="../events/gesture-event-listeners.html">
<link rel="import" href="../template/template-stamp.html">
<link rel="import" href="../attributes/attribute-to-from-property.html">
<link rel="import" href="../properties/meta-effects.html">
<link rel="import" href="dom-module.html">
<link rel="import" href="behaviors.html">
<link rel="import" href="../styling/style-lib.html">

<script>
(function() {

  'use strict';

  var caseMap = Polymer.CaseMap;
  var behaviors = Polymer.Behaviors;
  var events = new Polymer.GestureEventListeners();
  var templateStamp = new Polymer.TemplateStamp(events);
  var attributes = new Polymer.AttributeToFromProperty();
  var data = new Polymer.MetaEffects(templateStamp, attributes);

  var hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        var host = this.stack[this.stack.length-1];
        data.enqueueClient(host, inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      var stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  class CoreElement extends HTMLElement {

    /*
    static makeMeta() {
      this._meta = this.copyMeta(proto.__meta);
      this.mergeMeta(proto._meta, meta);
    }

    createMeta: function(host, behaviors) {
      var b$ = behaviors ? behaviors.slice() : [];
      b$.push({
        listeners: host.hasOwnProperty('listeners') && host.listeners,
        hostAttributes: host.hasOwnProperty('hostAttributes') && host.hostAttributes,
        properties: host.hasOwnProperty('properties') && host.properties,
        observers: host.hasOwnProperty('observers') && host.observers
      });
      var meta = {};
      for (var i=0, b; (i<b$.length) && (b=b$[i]); i++) {
        this.mergeMeta(meta, b);
      }
      return meta;
    },

    mergeMeta: function(meta, addProps) {
      if (addProps.listeners) {
        meta.listeners = meta.listeners || [];
        this._addListeners(meta.listeners, addProps.listeners);
      }
      if (addProps.hostAttributes) {
        meta.hostAttributes = meta.hostAttributes || {};
        this._addHostAttributes(meta.hostAttributes, addProps.hostAttributes);
      }
      if (addProps.properties) {
        meta.properties = meta.properties || {};
        this._addProperties(meta.properties, addProps.properties);
      }
      if (addProps.observers) {
        meta.observers = meta.observers || [];
        this._addObservers(meta.observers, addProps.observers);
      }
      return meta;
    },

    copyMeta: function(meta) {
      var copy = {};
      if (meta.listeners) {
        copy.listeners = meta.listeners.slice();
      }
      if (meta.hostAttributes) {
        Object.create(meta.hostAttributes)
      }
      if (meta.properties) {
        copy.properties = {};
        for (var i in meta.properties) {
          copy.properties[i] = Object.create(meta.properties[i]);
        }
      }
      if (meta.observers) {
        copy.observers = meta.observers.slice();
      }
      return copy;
    },

    _addListeners: function(store, addProps) {
      for (var i in addProps) {
        store.push({event: i, method: addProps[i]});
      }
    },

    _addHostAttributes: function(store, addProps) {
      for (var i in addProps) {
        store[i] = addProps[i];
      }
    },

    _addProperties: function(store, addProps) {
      for (var i in addProps) {
        if (typeof addProps[i] !== 'object') {
          addProps[i] = {value: addProps[i]};
        }
        if (!store[i]) {
          store[i] = {
            // TODO(sorvell): optimization, goes elsewhere?
            attribute: CaseMap.camelToDashCase(i)
          };
        }
        this._aggregateProperty(store[i], addProps[i]);
      }
    },

    _aggregateProperty: function(store, add) {
      // type: last wins
      if (add.type) {
        store.type = add.type;
      }
      // value: last wins
      if (add.value !== undefined) {
        store.value = add.value;
      }
      // reflectToAttr: last wins
      if (add.reflectToAttribute) {
        store.reflectToAttribute = add.reflectToAttribute;
      }
      // notify: last wins?
      if (add.notify) {
        store.notify = add.notify;
      }
      // computed: cannot change
      if (!store.computed) {
        store.computed = add.computed;
      }
      // readOnly: truthy wins
      if (!store.readOnly) {
        store.readOnly = Boolean(store.computed) || add.readOnly;
      }
      // observer... convert to array
      if (add.observer) {
        if (store.observer) {
          if (typeof store.observer !== 'object') {
            store.observer = [store.observer];
          }
          store.observer.push(add.observer);
        } else {
          store.observer = add.observer;
        }
      }
    },

    _addObservers: function(store, list) {
      for (var i=0; i<list.length; i++) {
        store.push(list[i]);
      }
    }
    */
    // Non-lazy registration work goes here
    static get observedAttributes() {
      // TODO(kschaaf): revisit: capture import document, to aid finding dom-module
      var currentScript = document._currentScript || document.currentScript;
      this.prototype.__importDoc = currentScript && currentScript.ownerDocument;
      // observedAttributes must be finalized at registration time
      var attrs = this.accumulateObservedAttributes(this);
      console.log(attrs);
      return attrs;
    }
    
    static accumulateObservedAttributes(ctor) {
      if (!ctor.hasOwnProperty('_observedAttributes')) {
        // crawl down chain as long as we can accumulate.
        var attrs;
        if (ctor.accumulateObservedAttributes) {
          var proto = Object.getPrototypeOf(ctor.prototype);
          var superCtor = proto && proto.constructor;
          attrs = ctor.accumulateObservedAttributes(superCtor);
          var meta = ctor.getOwnMeta && ctor.getOwnMeta();
          if (meta && meta.properties) {
            for (var prop in meta.properties) {
              var attr = Polymer.CaseMap.camelToDashCase(prop);
              if (attrs.indexOf(attr) < 0) {
                attrs.push(attr);
              }
            }
          }
        }
        ctor._observedAttributes = attrs || [];
      } 
      return ctor._observedAttributes.slice();
    }

    static getOwnMeta() {
      if (!this.hasOwnProperty('_meta')) {
        this._meta = this.hasOwnProperty('meta') ? this.meta : null;
      }
      return this._meta;
    }

    constructor() {
      super();
      // note: `this.constructor.prototype` is wrong in Safari so make sure to
      // use `__proto__`
      var proto = this.__proto__;
      if (!proto.hasOwnProperty('__hasDecoratedClass')) {
        proto.is = this.localName;
        proto.__hasDecoratedClass = true;
        this.decorateClass();
      } else if (proto.hasOwnProperty('__hasDecoratedClass')) {
        Polymer.StyleLib.prepareHost(this, proto._template);
      }
      Polymer.telemetry.instanceCount++;
      // setup batched effects library; will call initialize when flushing
      data.prepare(this, this.ready);
      // add self to host's pending client list
      hostStack.registerHost(this);
      // apply defaults first.
      data.setPropertyDefaults(this);
    }

    decorateClass() {
      var proto = this.__proto__;
      var meta = behaviors.register(proto);
      if (meta.properties) {
        data.createProperties(proto, meta.properties);
      }
      if (meta.observers) {
        data.createMultiObservers(proto, meta.observers);
      }
      if (proto._template === undefined) {
        proto._template = Polymer.DomModule.import(proto.is, 'template', 
          this.__importDoc);
      }
      if (proto._template) {
        Polymer.CompatStyleUtil.normalizeForBC(proto._template.content);
        Polymer.StyleLib.prepareHost(this, proto._template);
        data.bindTemplate(proto, proto._template);
      }
    }

    // reserved for canonical behavior
    connectedCallback() {
      if (hostStack.isEmpty()) {
        data.flush(this);
        this.updateStyles();
      }
      this.isAttached = true;
    }

    ready() {
      var self = this;
      Polymer.AsyncRender.afterRender(function() {
        self.lazyReady();
      });
      if (!this.root) {
        if (this._template) {
          // BREAKME(sorvell): remove v0 support when we can...
          this.root = Polymer.shadowDomV0 ? this.createShadowRoot() :
            this.attachShadow({mode: 'open'});
        } else {
          this.root = this;
        }
      }
      if (this._template) {
        hostStack.beginHosting(this);
        var dom = data.stamp(this, this._template);
        this.root.appendChild(dom);
        hostStack.endHosting(this);
      }
      data.flush(this);
    }

    lazyReady() {
      if (this.__lazyReadied) {
        return;
      }
      this.__lazyReadied = true;
      if (this.__meta.listeners) {
        var l$ = this.__meta.listeners;
        for (var i=0, l; (i<l$.length) && (l=l$[i]); i++) {
          events.addMethodListener(this, l.event, l.method);
        }
      }
      if (this.__meta.hostAttributes) {
        var a$ = this.__meta.hostAttributes;
        for (var a in a$) {
          attributes.ensureAttribute(this, a, a$[a]);
        }
      }
    }

    // reserved for canonical behavior
    disconnectedCallback() {
      this.isAttached = false;
    }

    /* **** Begin Attributes **** */
    attributeChangedCallback(name, old, value) {
      var property = caseMap.dashToCamelCase(name);
      var info = this.__meta.properties && this.__meta.properties[property];
      if (info && !info.readOnly) {
        attributes.attributeToProperty(this, name, value, info.type);
      }
    }

    serialize(value) {
      return attributes.serialize(value);
    }

    deserialize(value, type) {
      return attributes.deserialize(value, type);
    }

    reflectPropertyToAttribute(property, attribute, value) {
      attributes.propertyToAttribute(this, property, attribute, value);
    }

    serializeValueToAttribute(value, attribute, node) {
      node = node || this;
      attributes.valueToAttribute(node, value, attribute, value);
    }

    updateStyles(properties) {
      Polymer.StyleLib.applyStyle(this, properties);
    }

  }

  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }

  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance);
  };

  // telemetry
  Polymer.telemetry = Polymer.telemetry || {}
  Polymer.telemetry.instanceCount = 0;

  Polymer.CoreElement = CoreElement;

})();
</script>
