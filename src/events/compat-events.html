<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="gesture-event-listeners.html">
<link rel="import" href="event-dispatch.html">

<script>
(function() {

  'use strict';

  var CompatEvents = Object.create(Polymer.GestureEventListeners);

  Polymer.Utils.mixin(CompatEvents, {

    /**
     * Object containing entries specifying event listeners to create on each
     * instance of this element, where keys specify the event name and values
     * specify the name of the handler method to call on this prototype.
     *
     * Example:
     *
     *
     *     Polymer({
     *
     *       listeners: {
     *         // `click` events on the host are delegated to `clickHandler`
     *         'tap': 'tapHandler'
     *       },
     *
     *       ...
     *
     *     });
     */
    addListeners: function(node, listeners) {
      for (var i=0, l; (i<listeners.length) && (l=listeners[i]); i++) {
        this.addMethodListener(node, l.event, l.method);
      }
    },

    listen: function(node, eventName, methodName) {
      var handler = this._recallEventHandler(this, 
        eventName, node, methodName);
      // reuse cache'd handler
      if (!handler) {
        handler = this._createEventHandler(
          node, eventName, methodName);
      }
      // don't call _listen if we are already listening
      if (handler._listening) {
        return;
      }
      this.addListener(node, eventName, handler);
      handler._listening = true;
    },

    /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @method unlisten
     * @param {Element} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     */
    unlisten: function(node, eventName, methodName) {
      // leave handler in map for cache purposes
      var handler = this._recallEventHandler(
        this, eventName, node, methodName);
      if (handler) {
        this.removeListener(node, eventName, handler);
        handler._listening = false;
      }
    }, 

    _boundListenerKey: function(eventName, methodName) {
      return (eventName + ':' + methodName);
    },

    _recordEventHandler: function(host, eventName, target, methodName, handler) {
      var hbl = host.__boundListeners;
      if (!hbl) {
        hbl = host.__boundListeners = new WeakMap();
      }
      var bl = hbl.get(target);
      if (!bl) {
        bl = {};
        hbl.set(target, bl);
      }
      var key = this._boundListenerKey(eventName, methodName);
      bl[key] = handler;
    },

    _recallEventHandler: function(host, eventName, target, methodName) {
      var hbl = host.__boundListeners;
      if (!hbl) {
        return;
      }
      var bl = hbl.get(target);
      if (!bl) {
        return;
      }
      var key = this._boundListenerKey(eventName, methodName);
      return bl[key];
    },

    _createEventHandler: function(node, eventName, methodName) {
      var host = node;
      var handler = function(e) {
        if (host[methodName]) {
          host[methodName](e, e.detail);
        } else {
          host._warn(host._logf('_createEventHandler', 'listener method `' +
            methodName + '` not defined'));
        }
      };
      handler._listening = false;
      this._recordEventHandler(host, eventName, node, methodName, handler);  
      return handler;
    }

  });

  CompatEvents.Mixin = {

    listeners: {},

    fire: function(type, detail, options) {
      return Polymer.EventDispatch.fire(this, type, detail, options);
    },

    listen: function(node, eventName, methodName) {
      Polymer.CompatEvents.listen(node, eventName, methodName);
    },

    unlisten: function(node, eventName, methodName) {
      Polymer.CompatEvents.unlisten(node, eventName, methodName);
    }, 
    
    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @method setScrollDirection
     * @param {String=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {HTMLElement=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection: function(direction, node) {
      Polymer.CompatEvents.setScrollDirection(direction, node);
    }

  };

  // export
  Polymer.CompatEvents = CompatEvents;


})();
</script>