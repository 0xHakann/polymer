<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="annotations.html">

<script>

  /*
   * Parses the annotations list created by `annotations` features to perform
   * declarative desugaring.
   *
   * Depends on `annotations` feature and `bind` feature.
   *
   * Two tasks are supported:
   *
   * - nodes with 'id' are described in a virtual annotation list at
   *   registration time. This list is then concretized per instance.
   *
   * - Simple mustache expressions consisting of a single property name
   *   in a `textContent` context are bound using `bind` features
   *   `bindMethod`. In this mode, the bound method is constructed at
   *   registration time, so marshaling is done done via the concretized
   *   `_nodes` at every access.
   *
   *   TODO(sjmiles): ph3ar general confusion between registration and
   *   instance time tasks. Is there a cleaner way to disambiguate?
   */
  TemplateBind = {

    // construct binding meta-data 
    
    _preprocessBindAnnotations: function(prototype, list) {
      // create a virtual annotation list, must be concretized at instance time
      prototype._nodes = [];
      // process annotations that have been parsed from template
      list.forEach(function(annotation) {
        // where to find the node in the concretized list
        var index = prototype._nodes.push(annotation) - 1;
        // TODO(sjmiles): we need to support multi-bind, right now you only get
        // one (not including kind === `id`)
        annotation.bindings.forEach(function(binding) {
          prototype._bindAnnotationBinding(binding, index);
        });
      });
    },

    // _nodes[index][<binding.name=>]{{binding.value}}
    _bindAnnotationBinding: function(binding, index) {
      // capture the node index
      binding.index = index;
      // discover top-level property (model) from path
      var path = binding.value;
      var i = path.indexOf('.');
      // [name=]{{model[.subpath]}}
      var model = (i >= 0) ? path.slice(0, i) : path;
      // add 'annotation' binding effect for property 'model'
      this.addPropertyEffect(model, 'annotation', binding);
    }

    // concretize `_nodes` map (annotation based)
    
    marshalAnnotatedNodes: function(nodes, root) {
      return nodes.map(function(a) {
        return Template.findAnnotatedNode(root, a);
      };
    }

  });

</script>
