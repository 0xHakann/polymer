<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>

  modulate('bind', function() {
    var Bind = {

      // for instances

      prepareInstance: function(inst) {
        inst._data = Object.create(null);
      },

      setupBindListeners: function(inst) {
        inst._bindListeners.forEach(function(info) {
          // <node>.on.<property>-changed: <path]> = e.detail.value
          //console.log('[_setupBindListener]: [%s][%s] listening for [%s][%s-changed]', this.localName, info.path, info.id || info.index, info.property);
          var fn = new Function('e', 'this.' + info.path + ' = e.detail.value;');
          var node = info.id ? inst.$[info.id] : inst._nodes[info.index];
          node.addEventListener(info.property + '-changed', fn.bind(this));
        });
      },

      // for prototypes

      _builders: {},
      
      addBuilder: function(kind, builder) {
        this._builders[kind] = builder;
      },

      addBuilders: function(builders) {
        for (var n in builders) {
          this._builders[n] = builders[n];
        }
      },

      prepareModel: function(model) {
        model._propertyEffects = {};
        model._bindListeners = [];
        model._setData = this._setData;
      },

      // TODO(sjmiles): ad-hoc telemetry
      _telemetry: {
        _setDataCalls: 0
      },

      _setData: function(property, value) {
        // TODO(sjmiles): ad-hoc telemetry
        //Base._telemetry._setDataCalls++;
        var old = this._data[property];
        if (old !== value) {
          this._data[property] = value;
        }
        return old;
      },

      addPropertyEffect: function(model, property, kind, effect) {
        var fx = model._propertyEffects[property];
        if (!fx) {
          fx = model._propertyEffects[property] = [];
        }
        fx.push({
          kind: kind,
          effect: effect
        });
      },

      createBindings: function(model) {
        var fx$ = model._propertyEffects;
        if (fx$) {
          //console.group(this.name);
          for (var n in fx$) {
            //console.group(n);
            var fx = fx$[n];
            fx.sort(this._sortPropertyEffects);
            //console.log(fx);
            //
            var compiledEffects = fx.map(function(x) {
              return this._buildEffect(model, n, x);
            }, this);
            //
            this._bindPropertyEffects(model, n, compiledEffects);
            //console.log(fxt.join('\n'));
            //console.groupEnd();
          }
          //console.groupEnd();
        }
      },

      _sortPropertyEffects: function(a, b) {
        if (a.kind === 'compute' || b.kind === 'notify') {
          return -1;
        }
        if (a.kind === 'notify' || b.kind === 'compute') {
          return 1;
        }
        return 0;
      },

      _buildEffect: function(model, property, fx) {
        var b = this._builders[fx.kind];
        if (b) {
          return b(model, property, fx.effect);
        } else {
          throw('bind._buildEffect: missing builder kind [' + fx.kind + ']');
        }
      },

      // create accessors that implement effects
      _bindPropertyEffects: function(model, property, effects) {
        var defun = {
          get: function() {
            return this._data[property];
          }
        }
        if (effects.length) {
          // combine effects
          // var group = '\'' + this.name + ':' + property + '\'';
          // effects.unshift('console.group(' + group + ');');
          // effects.push('console.groupEnd(' + group + ');');
          effects = effects.join('\n\t\t');
          // construct effector
          var effector = '_' + property + 'Effector';
          model[effector] = new Function('old', effects);
          // construct setter body
          var body  = [ 
            'var old = this._setData(\'' + property + '\', value);',
            'if (value !== old) {',
            '  this.' + effector + '(old);',
            '}'
          ].join('\n');
          var setter = new Function('value', body);
          // ReadOnly properties have a private setter only
          //if (this.isReadOnlyProperty(property)) {
          //  this['_set_' + property] = setter;
          //}
          // other properties have a proper setter
          //else {
            defun.set = setter;
          //}
        }
        Object.defineProperty(model, property, defun);
        //console.log(prop.set ? prop.set.toString() : '(read-only)');
      },

      // end of builders

      _addAnnotatedListener: function(model, index, property, path) {
        // <node>.on.<property>-changed: <path> = e.detail.value
        model._bindListeners.push({
          index: index,
          property: property,
          path: path
        });
      },

      _bindAnnotationProperty: function(name, path, index) {
        return 'this._nodes[' + index + '].' + name
            + ' = this._data.' + path + ';';
      },

      _addBindListener: function(property, path, id) {
        var bl = this._requireBindListeners(property);
        bl.targets.push({
          id: id,
          path: path
        });
      }

    };

    return Bind;

  });

</script>
