<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="templatizer.html">
<link rel="import" href="../array-observe.html">
<link rel="import" href="../collection.html">

<script>

  using(['ArrayObserve', 'Collection', 'Debounce'], function(ArrayObserve, Collection, Debounce) {
    /**
     * Creates a pseudo-custom-element that maps property values to bindings
     * in DOM.
     * 
     * `stamp` method creates an instance of the pseudo-element. The instance
     * references a document-fragment containing the stamped and bound dom
     * via it's `root` property. 
     *  
     */

    var debounceDistribute;

    Polymer({

      is: 'x-repeat',
      extends: 'template',

      published: {
        items: Array,
        sort: Function,
        filter: Function,
        observe: String,
        delay: Number
      },

      mixins: [
        'Templatizer'
      ],

      bind: {
        'sort': '_sortChanged',
        'filter': '_filterChanged',
        'observe': '_observeChanged',
        'items.*': '_itemsChanged'
      },

      created: function() {
        this.boundCollectionObserver = this.render.bind(this);
      },

      attached: function() {
        // Templatizing (generating the instance constructor) needs to wait
        // until attached, since it may not have its template content handed
        // back to it until then, following its host template stamping
        if (!this.ctor) {
          this.templatize(this);
        }
        if (this._renderPendingAttach) {
          this._renderPendingAttach = false; 
          this.render();
        }
      },

      _sortChanged: function() {
        this._sortFn = this.sort && (typeof this.sort == 'function' ? 
          this.sort : this.host[this.sort].bind(this.host));
        this.debounce('render', this.render);
      },

      _filterChanged: function() {
        this._filterFn = this.filter && (typeof this.filter == 'function' ? 
          this.filter : this.host[this.filter].bind(this.host));
        this.debounce('render', this.render);
      },

      _observeChanged: function() {
        this._observePaths = this.observe && 
          this.observe.replace('.*', '.').split(' ');
      },

      _itemsChanged: function(items, old, path) {
        if (path) {
          this._notifyElement(path, items);
          this._checkObservedPaths(path);
        } else {
          if (old) {
            this._unobserveCollection(old);
          }
          if (items) {
            this._observeCollection(items);
            this.debounce('render', this.render);
          }
        }          
      },

      _checkObservedPaths: function(path) {
        if (this._observePaths && path.indexOf('items.') === 0) {
          path = path.substring(path.indexOf('.', 6) + 1);
          var paths = this._observePaths;
          for (var i=0; i<paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.debounce('render', this.render, this.delay);
              return;
            }
          }
        }
      },

      _observeCollection: function(items) {
        this.collection = Collection.get(items);
        this.collection.observe(this.boundCollectionObserver);
      },

      _unobserveCollection: function(items) {
        var collection = Collection.get(items);
        collection.unobserve(this.boundCollectionObserver);
      },

      render: function(splices) {
        // TODO(kschaaf): should actually queue splices also
        if (!this.isAttached) {
          // Render must follow attachment
          this._renderPendingAttach = true;
          return;
        }
        if (this.host) {
          this.host.localDom.batch();
          this._render(splices);
          this.host.debounce('distribute', function() {
            this.localDom.distribute();
          });
        } else {
          this._render(splices);
        }
      },

      _render: function(splices) {
        var c = this.collection;
        var rowForKey = this._rowForKey = {};
        var keys;
        if (!this._sortFn && splices) {
          keys = this._orderedKeys;
          this._applySplices(splices);
        } else {
          keys = this._orderedKeys = c.getKeys();
        }
        // Filter
        if (this._filterFn) {
          keys = keys.filter(function(a, b) {
            return this._filterFn(c.getItem(a), c.getItem(b));
          }, this);
        }
        // Sort
        if (this._sortFn) {
          keys.sort(function(a, b) {
            return this._sortFn(c.getItem(a), c.getItem(b));
          }.bind(this));
        }
        // Assign
        this.rows = this.rows || [];

        for (var i=0; i<keys.length; i++) {
          var row = this.rows[i];
          if (!row) {
            this.rows.push(row = this._insertRow(i));
          }
          var key = keys[i];
          row.item = c.getItem(key);
          row.key = key;
          rowForKey[key] = i;
        }
        // Remove extra
        for (; i<this.rows.length; i++) {
          this._detachRow(this.rows[i]);
        }
        this.rows.splice(keys.length, this.rows.length-keys.length);
      },

      _applySplices: function(splices) {
        var keys = this._orderedKeys;
        for (var i=0; i<splices.length; i++) {
          var s = splices[i];
          var args = [s.index, s.removed.length].concat(s.added);
          keys.splice.apply(keys, args);
        }
      },

      _detachRow: function(row) {
        for (var i=0; i<row._children.length; i++) {
          var el = row._children[i];
          if (this.host) {
            var parentNode = this.lightDom.elementParent();
            this.host.localDom.removeChild(el, parentNode);
          }
          row.root.appendChild(el);
        }
      },

      _insertRow: function(idx) {
        var row = this._generateRow(idx);
        var beforeRow = this.rows[idx];
        var beforeNode = beforeRow ? beforeRow._children[0] : this;
        var parentNode = this.lightDom.elementParent();
        if (this.host) {
          this.host.localDom.insertBefore(row.root, beforeNode, parentNode);
        } else {
          parentNode.insertBefore(row.root, beforeNode);
        }
        return row;
      },

      _generateRow: function(idx) {
        var row = this.stamp({
          pathDelegate: this
        });
        // each row is a document fragment which is lost when we appendChild,
        // so we have to track each child individually
        var children = [];
        for (var n = row.root.firstChild; n; n=n.nextSibling) {
          children.push(n);
          n._templateInstance = row;
        }
        // Since archetype overrides Base/HTMLElement, Safari complains
        // when accessing `children`
        row._children = children;
        return row;
      },

      _notifyDelegatePath: function(row, path, value) {
        this.notifyPath(path.replace('item', 'items.' + row.key), value);
      },

      _notifyElement: function(path, value) {
        // 'items.'.length == 6
        var dot = path.indexOf('.', 6);
        var key = path.substring(6, dot < 0 ? path.length : dot);
        var idx = this._rowForKey[key];
        var row = this.rows[idx];
        if (row) {
          if (dot >= 0) {
            path = 'item.' + path.substring(dot+1);
            row.notifyPath(path, value, true);
          } else {
            row.item = value;
          }
        }
      },

      itemForElement: function(el) {
        while (el && !el._templateInstance) {
          el = el.parentNode;
        }
        return el._templateInstance.item;
      },

      keyForElement: function(el) {
        while (el && !el._templateInstance) {
          el = el.parentNode;
        }
        return el._templateInstance.key;
      },

      indexForElement: function(el) {
        while (el && !el._templateInstance) {
          el = el.parentNode;
        }
        return this.rows.indexOf(el._templateInstance);
      }

    });

  });

</script>
