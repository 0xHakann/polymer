<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="settings.html">
<link rel="import" href="dom-innerHTML.html">
<script>
(function() {
  
  'use strict';

  // native add/remove
  var nativeInsertBefore = Element.prototype.insertBefore;
  var nativeAppendChild = Element.prototype.appendChild;
  var nativeRemoveChild = Element.prototype.removeChild;
  
  /**
   * TreeApi is a dom manipulation library used by Shady/Polymer.dom to 
   * manipulate composed and logical trees.
   */
  var TreeApi = Polymer.TreeApi = {
    
    // sad but faster than slice...
    arrayCopyChildNodes: function(parent) {
      var copy=[], i=0;
      for (var n=parent.firstChild; n; n=n.nextSibling) {
        copy[i++] = n;
      }
      return copy;
    },

    arrayCopyChildren: function(parent) {
      var copy=[], i=0;
      for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {
        copy[i++] = n;
      }
      return copy;
    },

    arrayCopy: function(a$) {
      var l = a$.length;
      var copy = new Array(l);
      for (var i=0; i < l; i++) {
        copy[i] = a$[i];
      }
      return copy;
    }

  };

  Polymer.TreeApi.Logical = {

    hasChildNodes: function(node) {
      return Boolean(node.__childNodes !== undefined);
    },

    hasParentNode: function(node) {
      return Boolean(node.__parentNode);
    },

    getChildNodes: function(node) {
      // note: we're distinguishing here between undefined and false-y:
      // hasChildNodes uses undefined check to see if this element has logical
      // children; the false-y check indicates whether or not we should rebuild
      // the cached childNodes array.
      if (this.hasChildNodes(node)) {
        if (!node.__childNodes) {
          node.__childNodes = [];
          for (var n=node.__firstChild; n; n=n.__nextSibling) {
            node.__childNodes.push(n);
          } 
        }
        return node.__childNodes;
      } else {
        // TODO(sorvell): it's more correct to `Composed.getChildNodes`
        // instead of `childNodes` here but any trivial failure 
        //to use Polymer.dom will result in an error.
        return node.childNodes;
      }
    },

    getParentNode: function(node) {
      return node.__parentNode || TreeApi.Composed.getParentNode(node);
    },

    getFirstChild: function(node) {
      return node.__firstChild || TreeApi.Composed.getFirstChild(node);
    },

    getLastChild: function(node) {
      return node.__lastChild || TreeApi.Composed.getLastChild(node);
    },

    getNextSibling: function(node) {
      return node.__nextSibling || TreeApi.Composed.getNextSibling(node);
    },

    getPreviousSibling: function(node) {
      return node.__previousSibling || TreeApi.Composed.getPreviousSibling(node);
    },

    getFirstElementChild: function(node) {
      if (node.__firstChild) {
        var n = node.__firstChild;
        while (n && n.nodeType !== Node.ELEMENT_NODE) {
          n = n.__nextSibling;
        }
        return n;
      } else {
        return TreeApi.Composed.getFirstElementChild(node);
      }
    },

    getLastElementChild: function(node) {
      if (node.__lastChild) {
        var n = node.__lastChild;
        while (n && n.nodeType !== Node.ELEMENT_NODE) {
          n = n.__previousSibling;
        }
        return n;
      } else {
        return TreeApi.Composed.getLastElementChild(node);
      }
    },

    getNextElementSibling: function(node) {
      if (node.__nextSibling) {
        var n = node.__nextSibling;
        while (n && n.nodeType !== Node.ELEMENT_NODE) {
          n = n.__nextSibling;
        }
        return n;
      } else {
        return TreeApi.Composed.getNextElementSibling(node);
      }
    },

    getPreviousElementSibling: function(node) {
      if (node.__previousSibling) {
        var n = node.__previousSibling;
        while (n && n.nodeType !== Node.ELEMENT_NODE) {
          n = n.__previousSibling;
        }
        return n;
      } else {
        return TreeApi.Composed.getPreviousElementSibling(node);
      }
    },

    // Capture the list of light children. It's important to do this before we
    // start transforming the DOM into "rendered" state.
    // Children may be added to this list dynamically. It will be treated as the
    // source of truth for the light children of the element. This element's
    // actual children will be treated as the rendered state once this function
    // has been called.
    saveChildNodes: function(node) {
      if (!this.hasChildNodes(node)) {
        node.__firstChild = node.firstChild;
        node.__lastChild = node.lastChild;
        node.__childNodes = [];
        for (var n=node.firstChild; n; n=n.nextSibling) {
          n.__parentNode = node;
          node.__childNodes.push(n);
          n.__nextSibling = n.nextSibling;
          n.__previousSibling = n.previousSibling;
        }
      }
    },

    recordInsertBefore: function(node, container, ref_node) {
      container.__childNodes = null;
      // handle document fragments
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        // TODO(sorvell): remember this for patching:
        // the act of setting this info can affect patched nodes
        // getters; therefore capture childNodes before patching.
        for (var n=node.firstChild; n; n=n.nextSibling) {
          this._linkNode(n, container, ref_node);  
        }
      } else {
        this._linkNode(node, container, ref_node);
      }
    },

    _linkNode: function(node, container, ref_node) {
      // update ref_node.previousSibling <-> node
      node.__previousSibling = ref_node ? ref_node.__previousSibling : 
        container.__lastChild;
      if (node.__previousSibling) {
        node.__previousSibling.__nextSibling = node;
      }
      // update node <-> ref_node
      node.__nextSibling = ref_node;
      if (node.__nextSibling) {
        node.__nextSibling.__previousSibling = node;
      }
      // update node <-> container
      node.__parentNode = container;
      if (ref_node) {
        if (ref_node === container.__firstChild) {
          container.__firstChild = node;
        }
      } else {
        container.__lastChild = node;
        if (!container.__firstChild) {
          container.__firstChild = node;
        }
      }
      // remove caching of childNodes
      container.__childNodes = null;
    },

    recordRemoveChild: function(node, container) {
      if (node === container.__firstChild) {
        container.__firstChild = node.__nextSibling;
      }
      if (node === container.__lastChild) {
        container.__lastChild = node.__previousSibling;
      }
      var p = node.__previousSibling;
      var n = node.__nextSibling;
      if (p) {
        p.__nextSibling = n;
      }
      if (n) {
        n.__previousSibling = p;
      }
      node.__parentNode = node.__previousSibling = node.__nextSibling = null;
      // remove caching of childNodes
      container.__childNodes = null;
    },

  }

  // TODO(sorvell): composed tree manipulation is made available
  // (1) to maninpulate the composed tree, and (2) to track changes
  // to the tree for optional patching pluggability.
  Polymer.TreeApi.Composed = {

    
    ensureParentNodes: function(parent, children) {
    },

    getChildNodes: function(node) {
      return Polymer.TreeApi.arrayCopyChildNodes(node);
    },

    getParentNode: function(node) {
      return node.parentNode;
    },

    getFirstChild: function(node) {
      return node.firstChild;
    },

    getLastChild: function(node) {
      return node.lastChild;
    },

    getNextSibling: function(node) {
      return node.nextSibling;
    },

    getPreviousSibling: function(node) {
      return node.previousSibling;
    },

    getFirstElementChild: function(node) {
      return node.firstElementChild;
    },

    getLastElementChild: function(node) {
      return node.lastElementChild;
    },

    getNextElementSibling: function(node) {
      return node.nextElementSibling;
    },

    getPreviousElementSibling: function(node) {
      return node.previousElementSibling;
    },

    // composed tracking needs to reset composed children here in case
    // they may have already been set (this shouldn't happen but can 
    // if dependency ordering is incorrect and as a result upgrade order 
    // is unexpected)
    clearChildNodes: function(node) {
      node.textContent = '';
    },

    insertBefore: function(parentNode, newChild, refChild) {
      return nativeInsertBefore.call(parentNode, newChild, refChild || null);
    },

    appendChild: function(parentNode, newChild) {
      return nativeAppendChild.call(parentNode, newChild);
    },

    removeChild: function(parentNode, node) {
      return nativeRemoveChild.call(parentNode, node);
    }

  };

})();
</script>