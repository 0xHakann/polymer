<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>

  Polymer.Base = {

    // pluggable features
    // `this` context is a prototype, not an instance
    _addFeature: function(feature) {
      this.extend(this, feature);
    },

    // `this` context is a prototype, not an instance
    registerCallback: function() {
      this._registerFeatures();  // abstract
      this.registered();
    },

    // for overriding
    // `this` context is a prototype, not an instance
    registered: function() {
    },

    createdCallback: function() {
      Polymer.telemetry.instanceCount++;
      this.root = this;
      //this.beforeCreated();
      this._doBehavior('created');
      //this.created();
      //this.afterCreated();
      this._initFeatures(); // abstract
    },

    // for overriding
    //beforeCreated: function() {
    //},

    // for overriding
    //created: function() {
    //},

    // for overriding
    //afterCreated: function() {
    //},

    // reserved for canonical behavior
    attachedCallback: function() {
      this.isAttached = true;
      this._doBehavior('attached');
      //this.attached();
    },

    // for overriding
    //attached: function() {
    //},

    // reserved for canonical behavior
    detachedCallback: function() {
      this.isAttached = false;
      this._doBehavior('detached');
      //this.detached();
    },

    // for overriding
    //detached: function() {
    //},

    // reserved for canonical behavior
    attributeChangedCallback: function(name) {
      this.setAttributeToProperty(this, name);
      //this.attributeChanged.apply(this, arguments);
      this._doBehavior('attributeChanged', arguments);
    },

    // for overriding
    //attributeChanged: function() {
    //},

    // TODO(sjmiles): leaving these abstract is probably less confusing than
    // leaving unused 'explanatory' implementations here
    /*
    _doBehavior: function(name, args) {
      this._invokeBehavior(this, args);
    },

    _invokeBehavior: function(b, args) {
      var fn = b[fn];
      if (fn) {
        fn.apply(this, args || Polymer.nar);
      }
    },
    */

    // copy own properties from `api` to `prototype`
    extend: function(prototype, api) {
      if (prototype && api) {
        Object.getOwnPropertyNames(api).forEach(function(n) {
          this.copyOwnProperty(n, api, prototype);
        }, this);
      }
      return prototype || api;
    },

    copyOwnProperty: function(name, source, target) {
      var pd = Object.getOwnPropertyDescriptor(source, name);
      if (pd) {
        Object.defineProperty(target, name, pd);
      }
    }

  };

  if (Object.__proto__) {
    Polymer.Base.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        object.__proto__ = inherited;
      }
      return object;
    };
  } else {
    Polymer.Base.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        var chained = Object.create(inherited);
        object = Polymer.Base.extend(chained, object);
      }
      return object;
    };
  }

  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);

  // TODO(sjmiles): ad hoc telemetry
  Polymer.telemetry.instanceCount = 0;

</script>
