<!--
Copyright 2012 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<element name="g-component">
  <script>
    // FOUC prevent, if user sets opacity 0 on body
    window.addEventListener("WebComponentsReady", function() {
      document.body.style.opacity = 1;
    });

    // conventional names for automation

    var conventions = {
      ATTRIBUTES_ATTRIBUTE: "attributes",
      DELEGATES_DIRECTIVE: "bind",
      OBSERVE_DIRECTIVE: "observe",
      PROPERTY_CHANGED_SUFFIX: "Changed",
      CUSTOM_EVENT_PREFIX: "on-",
      BINDING_OUT_SUFFIX: "Output",
      BINDING_IN_SUFFIX: "Input"
    };

    // decorate HTMLElementElement with toolkit API
    
    HTMLElementElement.prototype.component = component;

    // entry point for declarative component definition
    
    function component(inLifecycle) {
      var lifecycle = inLifecycle || {};
      var attributes = this.element.attributes;
      //
      this.lifecycle({
        shadowRootCreated: function(inRoot) {
          initialize.call(this, inRoot, lifecycle);
        },
        created: function() {
          // TODO(sjmiles): notional event delegate attached to DOM tree
          //   to explore declarative event mapping as platform feature
          this.controller = this;
          // automate basic tasks, so applications never have to
          automateInstance.call(this,
            // TODO(sjmiles): replace with conventions.CUSTOM_EVENT_PREFIX
            attributes.handlers
          );
          // process parsed attributes as inputs (the initial mutation)
          takeAttributes.call(this);
          // invoke user's initialization
          if (lifecycle.created) {
            lifecycle.created.call(this);
          }
          // attach MutationObserver so that changes in the attributes
          // are reflected in the matching properties
          this.attributeObserver = new AttributeObserver(this);
          //console.dir(this);
        }
      });
      //
      var p = lifecycle.prototype || {};
      // set up property observers
      automatePrototype.call(p, 
        attributes[conventions.ATTRIBUTES_ATTRIBUTE],
        lifecycle[conventions.OBSERVE_DIRECTIVE]
      );
      //
      // attach some misc API
      //
      // TODO(sjmiles): this is probably not the best way to do this
      // better to insert another link in the prototype chain,
      // but it's unclear if HTMLElementElement, et al, support this
      //
      // not scoped (utils methods do not use 'this')
      p.utils = utils;
      // scoped (depend on 'this')
      p.fireEvent = fireEvent;
      p.asyncMethod = asyncMethod;
      p.setPropertySilently = setPropertySilently;
      //
      // install our prototype (can p be a chain?)
      this.generatedConstructor.prototype = p;
    };

    // lifecycle
    
    // per-type, this == prototype
    var automatePrototype = function(inAttributes, inPublished) {
      // TODO(sjmiles): scoping is tricky
      // this function is called in the context of a prototype, therefore
      // this localModel is a repository for default properties only
      // instances should chain their localModel to this prototypical one
      this.localModel = {};
      bindAttributes.call(this, inAttributes);
      bindProperties.call(this, inPublished);
    };

    // per-root
    var initialize = function(inRoot, inLifecycle) {
      // we actually only want to do this per-instance, but it has to be 
      // the first thing we do and we have no other entry point
      if (!this.hasOwnProperty('localModel')) {
        // the prototypical localModel contains our default values, so
        // using copy-on-write feature of javascript is convenient here
        this.localModel = Object.create(this.localModel);
        bindDelegates.call(this, inLifecycle[conventions.DELEGATES_DIRECTIVE]);
      }
      // map nodes to their id's
      establishNodeReferences.call(this, inRoot);
      // invoke user's initialization
      if (inLifecycle.shadowRootCreated) {
        inLifecycle.shadowRootCreated.call(this, inRoot);
      }
      // parse custom declarative event syntax out of DOM
      bindAllCustomEvents(inRoot);
      // model binding fixups for root, if it exists
      if (inRoot) {
        // ShadowDOM: inRoot.model doesn't propagate, that propagation is 
        // rooted in light DOM; simulate by installing a local model in 
        // each immediate child
        injectScope(inRoot.childNodes, this.localModel, this.localModelDelegate);
        // parse and apply model binding markup in DOM
        bindModel(inRoot.childNodes);
        // TODO(sjmiles): nodes created ex-post facto need similar treatment
      }
    };

    // per-instance
    var automateInstance = function(inHandlers) {
      bindEvents.call(this, inHandlers);
    };

    // property bindings
    //
    // sets up observable properties
    //
    // an observable property with <name> will automatically call
    // <name>Changed method when the property value changes
    // (if <name>Changed exists, late-bound)

    var bindProperties = function(inProperties) {
      if (inProperties) {
        Object.keys(inProperties).forEach(function(n) {
          bindProperty.call(this, n, inProperties[n]);
        }, this);
      }
    };

    // sometimes called in the context of a prototype
    // localModel on the prototype is storage for default property values
    var bindProperty = function(inName, inValue) {
      if (!this.localModel.hasOwnProperty(inName)) {
        // weak-bound <inName>Changed caller
        var changeEffect = sideEffectFactory(inName);
        // use get/set so we can catch side-effects
        // TODO(sjmiles): if we can switch to Object.observe
        // then we can watch 'this' directly for property
        // changes and dispense with get/set
        Object.defineProperty(this, inName, {
          get: function() {
            return this.localModel[inName];
          },
          set: function(v) {
            var old = this.localModel[inName];
            this.localModel[inName] = v;
            if (old !== v) {
              changeEffect.call(this, old);
            }
          }
        });
      }
      setPropertySilently.call(this, inName, inValue);
    };

    var sideEffectFactory = function(inName) {
      var fn = appendChangedSuffix(inName);
      return function(inOld) {
        if (!squelchSideEffects) {
          invoke.call(this, fn, [inOld]);
        }
      };
    };
    
    var setPropertySilently = function(inName, inValue) {
      this.localModel[inName] = inValue;
    };

    var invoke = function(inMethod, inArgs) {
      if (this[inMethod]) {
        return this[inMethod].apply(this, inArgs || []);
      }
    };

    var appendChangedSuffix = function(inName) {
      return inName + conventions.PROPERTY_CHANGED_SUFFIX;
    };

    var propertyChanged = function(inName, inOld) {
      invoke.call(this, appendChangedSuffix(inName), [inOld]);
    };

    var squelchSideEffects = false;

    // helper for shim tree magic

    var deref = function(inNode) {
      return inNode && (inNode.baby || inNode);
    };

    // attribute bindings
    //
    // <element attributes="attr1, attr2..."
    //
    // create matching observed properties attr1, attr2, etc.

    var bindAttributes = function(inAttributes) {
      var attrs = this.boundAttributes = [];
      if (inAttributes) {
        var a$ = inAttributes.value;
        var bindables = a$.split(a$.indexOf(',') >= 0 ? ',' : ' ');
        bindables.forEach(function(a) {
          a = a.trim();
          attrs.push(a);
          bindProperty.call(this, a, this[a]);
        }, this);
      }
    };

    // event bindings
    //
    // <element handlers="onclick: click, onkeypress: keypress, ..."
    //
    // create listeners on instances that map named events to
    // methods on the instance

    var bindEvents = function(inEvents) {
      if (inEvents) {
        var bindables = inEvents.value.split(",");
        bindables.forEach(function(e) {
          // event name: handler name pairs
          var pair = e.split(":");
          var event = pair[0].trim();
          var handler = pair[1].trim();
          if (this[handler]) {
            this.addEventListener(event, this[handler].bind(this));
          }
        }, this);
      }
    };

    // model bindings
    //
    // convert {{macro}} strings in markup into MDV bindings
    //
    // MDV usually does this work but requires an additional
    // nested template and functions asynchronously

    var bindModel = function(inNodes) {
      var bindMustache = function(inN, inNameOrValue, inValue) {
        if ((inValue || inNameOrValue).search(bindModel.mustache) >= 0) {
          inN.addBinding(inNameOrValue, inValue);
        }
      };
      Array.prototype.forEach.call(inNodes, function(n) {
        n = deref(n);
        if (n.nodeName == "#text") {
          // text-node binding
          bindMustache(n, n.textContent);
        } else if (n.attributes && n.tagName !== "TEMPLATE") {
          // attribute bindings
          Array.prototype.forEach.call(n.attributes, function(a) {
            bindMustache(n, a.name, a.value);
          });
          bindModel(n.childNodes);
        }
      });
    };
    bindModel.mustache = /\{\{([^{}]*)}}/g;

    // manually cascade a model and a delegate 
    var injectScope = function(inNodes, inLocalModel, inLocalModelDelegate) {
      Array.prototype.forEach.call(inNodes, function(n) {
        n.model = inLocalModel;
        n.modelDelegate = inLocalModelDelegate;
        // if there is a baby, do it too
        n = n.baby;
        if (n) {
          n.model = inLocalModel;
          n.modelDelegate = inLocalModelDelegate;
        }
        //console.log('injectScope', inLocalModel);
        //console.dir(n)
      });
    };

    // node bindings
    //
    // local nodes that have ID and store references to them in
    // this.$ hash

    var establishNodeReferences = function(inRoot) {
      // establish $ instance variable
      this.$ = this.$ || {};
      // populate $ from nodes with ID from the LOCAL tree
      if (inRoot) {
        var nodes = ShadowDOM.localQueryAll(inRoot, "[id]");
        Array.prototype.forEach.call(nodes, function(n) {
          this.$[n.id] = deref(n);
        }, this);
      }
    };

    // data bindings
    //
    // <name>: ['<path dependency>', '<path dependency>'...]
    //
    // bind MDV macros of the form {{<name>}} to formatting methods
    // in inNode using MDV delegates
    //

    var bindDelegates = function(inDelegates) {
      if (inDelegates) {
        var node = this;
        this.localModelDelegate = function(inBinding) {
          if (inBinding in inDelegates) {
            var dependencies = inDelegates[inBinding] || [inBinding];
            if (typeof dependencies == 'string') {
              dependencies = [dependencies];
            }
            //console.log("bindDelegates:", inBinding, dependencies, node);
            var inMethod = inBinding + conventions.BINDING_IN_SUFFIX;
            var outMethod = inBinding + conventions.BINDING_OUT_SUFFIX;
            return [
              dependencies,
              function(/*inValues*/) {
                return delegateBinding(node, outMethod, arguments);
              },
              function(/*inValues*/) {
                return delegateBinding(node, inMethod, arguments);
              }
            ];
          }
        };
      }
    };

    var delegateBinding = function(inNode, inDelegate, inValues) {
      // late binding to named delegate function
      var fn = inNode[inDelegate];
      var value = fn ? fn.apply(inNode, inValues) : undefined;
      // whenever undefined, echo back first input value
      if (value === undefined) {
        value = inValues[0];
      }
      //console.log(inDelegate, inValues, value);
      return value;
    };

    var deref = function(inNode) {
      return inNode && (inNode.baby || inNode);
    };

    var establishNodeReferences = function(inRoot) {
      this.$ = this.$ || {};
      // search the LOCAL tree
      if (inRoot) {
        var nodes = ShadowDOM.localQueryAll(inRoot, "[id]");
        Array.prototype.forEach.call(nodes, function(n) {
          this.$[n.id] = deref(n);
        }, this);
      }
    };

    // attribute mutations

    var deserializeValue = function(inValue) {
      switch (inValue) {
        case "":
        case "true":
          return true;
        case "false":
          return false;
        case "\\false":
          return "false";
        }
        return isNaN(inValue) ? inValue : parseFloat(inValue);
    };

    // propagate initial bound-attribute values into properties
    // as a batch, invoking side-effects only after all
    // properties are initialized

    var takeAttributes = function() {
      var changed = [];
      try {
        squelchSideEffects = true;
        this.boundAttributes.forEach(function(a) {
          if (this.hasAttribute(a)) {
            // get raw attribute value
            var value = this.getAttribute(a);
            // filter out 'mustached' values, these are to be
            // replaced with bound-data and are not runtime
            // values themselves
            if (value.search(bindModel.mustache) >= 0) {
              return;
            }
            // deserialize Boolean or Number values from attribute
            value = deserializeValue(value);
            if (this[a] !== value) {
              // track values that differ from property values
              changed.push({name: a, old: this[a]});
              // install new value (side-effects squelched)
              this[a] = value;
            }
          }
        }, this);
      } finally {
        squelchSideEffects = false;
      }
      // invoke side-effects in a batch after initializing
      // all values
      changed.forEach(function(c) {
        propertyChanged.call(this, c.name, c.old);
      }, this);
    };

    var attributeChanged = function(inName) {
      this[inName] = deserializeValue(this.getAttribute(inName));
    };

    var handleMutations = function(inMxns) {
      inMxns.forEach(function(inMxn) {
        var name = inMxn.attributeName;
        if (this.boundAttributes.indexOf(name) >= 0) {
          attributeChanged.call(this, name);
        }
      }, this);
    };

    var AttributeObserver = function(inNode) {
      var observer = new WebKitMutationObserver(handleMutations.bind(inNode));
      observer.observe(inNode, {
        attributes: true,
        attributeOldValue: true
      });
      return observer;
    };

    // fireEvent impl

    var fireEvent = function(inType, inDetail) {
      this.asyncMethod("dispatchEvent", [
        new CustomEvent(inType, {bubbles: true, detail: inDetail})
      ]);
    };

    // asyncMethod impl

    var asyncMethod = function(inMethod, inArgs, inTimeout) {
      return window.setTimeout(function() {
        this[inMethod].apply(this, inArgs);
      }.bind(this), inTimeout || 0);
    };

    // utility methods (utils)

    // job

    var job = function(inJobName, inJob, inWait) {
      var name = inJobName || ("__" + Math.random());
      job.stop(name);
      job._jobs[name] = setTimeout(function() {
        job.stop(name);
        inJob();
      }, inWait);
      return name;
    };
    job.stop = function(inJobName) {
      if (job._jobs[inJobName]) {
        clearTimeout(job._jobs[inJobName]);
        delete job._jobs[inJobName];
      }
    };
    job._jobs = {};

    // target finding

    var findDistributedTarget = function(inTarget, inNodes) {
      // find first ancestor of target (including itself) that
      // is in inNodes, if any
      var n = inTarget;
      while (n && n != this) {
        var i = Array.prototype.indexOf.call(inNodes, n);
        if (i >= 0) {
          return i;
        }
        n = n.parentNode;
      }
    };

    // string interpolation
    var macroize = function(inText, inMap, inPattern) {
      var result = inText, pattern = inPattern || macroize.pattern;
      var fn = function(macro, name) {
        var v = inMap[name];
        return (v === undefined || v === null) ? macro : v;
      };
      result = result.replace(pattern, fn);
      return result;
    };
    // Matches macros of the form {{name}}.
    macroize.pattern = /\{{([^{}]*)\}}/g;

    // collect utils

    var utils = {
      job: job,
      macroize: macroize,
      findDistributedTarget: findDistributedTarget
    };

    // newer experimental event handler

    var findController = function(inNode) {
      // find the shadow root that contains inNode
      var n = inNode.changeling || inNode;
      while (n.parentNode && n.tagName !== 'SHADOW-ROOT') {
        n = n.parentNode;
        if (n.changeling) {
          n = n.changeling;
        }
      }
      return n.host.controller;
    };

    var _ = function(inHandlerName) {
      var controller = findController(event.currentTarget);
      //console.log(inHandler, owner, event);
      if (controller && controller[inHandlerName]) {
        controller[inHandlerName](event);
      }
    };

    // automagic event mapping
    //
    // locate attributes of the form <prefix><eventName>="<methodName>" and
    // map <eventName> events to method <methodName> to inNode's controller
    //

    var bindCustomEvent = function(inNode, inEventName, inHandler) {
      var h = inNode.__athandlers = inNode.__athandlers || {};
      if (!h[inEventName]) {
        //console.log("bindCustomEvent:", inEventName, inHandler, inNode);
        h[inEventName] = function() {
          _(inHandler);
        };
        inNode.addEventListener(inEventName, h[inEventName]);
      }
    };

    var bindCustomEvents = function(inNode) {
      var prefix = conventions.CUSTOM_EVENT_PREFIX;
      var a$ = inNode.attributes;
      if (a$) {
        for (var i=0, a; a=a$[i]; i++) {
          if (a.name.slice(0, prefix.length) == prefix) {
            bindCustomEvent(inNode, a.name.slice(prefix.length), a.value);
          }
        }
      }
    };

    // TODO(sjmiles): improper tree walking (?)
    var _bindAllCustomEvents = function(inNode) {
      bindCustomEvents(inNode);
      if (inNode.childNodes) {
        for (var i=0, c; c=deref(inNode.childNodes[i]); i++) {
          if (c.tagName !== 'SHADOW') {
            bindAllCustomEvents(c);
          }
        }
      }
    };

    var eventsObserver = function(inNode) {
      // TODO(sjmiles): optimize so we only bind new nodes
      new WebKitMutationObserver(_bindAllCustomEvents.bind(this, inNode))
        .observe(inNode, {
          childList: true,
          subTree: true
        });
    };

    var bindAllCustomEvents = function(inNode) {
      if (inNode) {
        _bindAllCustomEvents(inNode);
        // we need this for custom events in iterated templates
        eventsObserver(inNode);
      }
    };

    // polyfill for DOMTokenList features:
    //  add/remove multiple classes
    //  arity-2 toggle

    (function() {
      'use strict';
      var add = DOMTokenList.prototype.add;
      var remove = DOMTokenList.prototype.remove;
      DOMTokenList.prototype.add = function() {
        for (var i = 0; i < arguments.length; i++) {
          add.call(this, arguments[i]);
        }
      };
      DOMTokenList.prototype.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
          remove.call(this, arguments[i]);
        }
      };
      DOMTokenList.prototype.toggle = function(name, value) {
        if (value == undefined) {
          value = !this.contains(name);
        }
        value ? this.add(name) : this.remove(name);
      };
    })();
  </script>
</element>

