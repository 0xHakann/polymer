<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../lib/css-parse.html">
<script>

  modulate('Style-transformer', ['Css-parse'], function(css) {

    /* Transforms ShadowDOM styling into ShadyDOM styling

     Transformations:

     * scoping: 

        * elements in scope get scoping selector class="x-foo-scope"
        * selectors re-written as follows:

          div button -> div.x-foo-scope button.x-foo-scope

     * :host -> scopeName

     * :host(...), :host-context(...): NOT SUPPORTED

     * ::content -> ' ' NOTE: requires use of scoping selector and selectors
       cannot otherwise be scoped:
       e.g. :host ::content > .bar -> x-foo > .bar

     * ::shadow, /deep/: NOT SUPPORTED

    */

    function transformDom(dom, scope) {
      var selector = scope + SCOPE_SUFFIX;
      _transformDom(dom, selector);
    }

    function _transformDom(node, selector) {
      if (node.classList) {
        node.classList.add(selector);
      }
      for (var e=node.firstElementChild; e; e=e.nextElementSibling) {
        _transformDom(e, selector);
      }
    }

    function transformStyle(style, scope) {
      var tree = css.parse(style.textContent);
      onTransformRules(tree, function(rule) {
        transformRule(rule, scope);
      });
      return css.stringify(tree);
    }

    function onTransformRules(node, cb) {
      var s = node.selector;
      var skipRules = false;
      if (s) {
        if (s.indexOf(AT_RULE) !== 0) {
          cb(node);
        } else {
          skipRules = (s.indexOf(KEYFRAME_RULE) >= 0);
        }
      }
      var r$ = node.rules;
      if (r$ && !skipRules) {
        for (var i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
          onTransformRules(r, cb);
        }
      }
    }

    function transformRule(rule, scope) {
      var p$ = rule.selector.split(SELECTOR_SEP);
      for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {
        p$[i] = transformComplexSelector(p, scope);
      }
      rule.selector = p$.join(SELECTOR_SEP);
      // console.log('transformRule', rule.selector);
    }

    function transformComplexSelector(selector, scope) {
      var stop = false;
      return selector.replace(SIMPLE_RX, function(s) {
        if (!stop) {
          var o = transformCompoundSelector(s, scope);
          if (o.stop) {
            stop = true;
          }
          s = o.value;  
        }
        return s;
      });
    }

    function transformCompoundSelector(selector, scope) {
      if (selector.indexOf(HOST) >=0) {
        selector = selector.replace(HOST, scope);
      } else {
        selector = transformSimpleSelector(selector, scope);
      }
      var stop;
      if (selector.indexOf(CONTENT) >= 0) {
        selector = selector.replace(CONTENT, ' ');
        stop = true;
      }
      return {value: selector, stop: stop};
    }

    function transformSimpleSelector(selector, scope) {
      var p$ = selector.split(PSEUDO_PREFIX);
      p$[0] += CLASS_PREFIX + scope + SCOPE_SUFFIX;
      return p$.join(PSEUDO_PREFIX);
    }

    var SCOPE_SUFFIX = '';
    var AT_RULE = '@';
    var KEYFRAME_RULE = 'keyframe';
    var SELECTOR_SEP = ',';
    var SIMPLE_RX = /([^\s>+~]+)/g
    var HOST = ':host';
    var CONTENT = "::content";
    var CLASS_PREFIX = '.';
    var PSEUDO_PREFIX = ':';

    // exports
    return {
      dom: transformDom,
      style: transformStyle
    };

  });
</script>
