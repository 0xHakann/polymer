<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
  
  using('Base', function(Base) {

    /**
      Implements `shadyRoot` compatible dom scoping using native ShadowDOM.
    */

    Base.addFeature({
      _prepContent: function() {
        this._useContent = this._useContent || Boolean(this._template);
        this.lightDom = new DomRoot(this);
      },

      // this should happen only 1x.
      distributeContent: function() {
        if (this.shadowRoot) {
          return;
        }
        // compose "clients"
        var c$ = this._getDistributionClients();
        for (var i=0, l= c$.length, c; (i<l) && (c=c$[i]); i++) {
          c.distributeContent();
        }
        // compose self
        if (this._useContent) {
          this._createShadowRoot();
        } else if (this.root !== this) {
          this.appendChild(this.root);
          this.root = this;
        }
      },

      _createShadowRoot: function() {
        var root = this.createShadowRoot();
        this.localDom = new DomRoot(root);
        root.appendChild(this.root);
        this.root = root;
      },

      querySelectorAllComposed: function(selector, node) {
        node = node || this;
        var list = node.querySelectorAll(selector);
        list = Array.prototype.slice.call(list, 0);
        var c$ = node.querySelectorAll('content');
        for (var i=0, l=c$.length, m; i < l; i++) {
          this._querySelectorComposed(selector, c$[i], list);
        }
        return list;
      },

      _querySelectorComposed: function(selector, node, list) {
        list = list || [];
        var d$ = node.getDistributedNodes();
        for (var i=0, l=d$.length, d; (i<l) && (d=d$[i]); i++) {
          if ((d.nodeType === Node.ELEMENT_NODE) &&
            this.elementMatches(selector, d)) {
            list.push(d);
          }
        }
        return list.length ? list : null;
      },

    });


    var DomRoot = function(node, host) {
      this.node = node;
    };

    DomRoot.prototype = {
      
      get children() {
        return this.node.childNodes;
      },

      appendChild: function(node) {
        this.node.appendChild(node);
      },

      insertBefore: function(node, ref_node) {
        this.node.insertBefore(node, ref_node);
      },

      removeChild: function(node) {
        this.node.removeChild(node);
      },

      querySelector: function(selector) {
        return this.node.querySelector(selector);
      },

      // note returns a real Array.
      querySelectorAll: function(selector) {
        var list = this.node.querySelectorAll(selector);
        return Array.prototype.slice.call(list, 0);
      }


            
    };

  });

</script>
