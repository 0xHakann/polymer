<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>

  using('Base', function(Base) {

    /**

      Implements a pared down version of ShadowDOM's scoping, which is easy to
      polyfill across browsers.

    */

    Base.addFeature({

      // TODO(sjmiles): ad-hoc signal for `ShadowDOM-lite-enhanced` nodes
      isHost: true,

      _bootContent: function() {
        this._useContent = this._useContent ||
          Boolean(this._template &&
          this._template.content.querySelector('content'));
      },

      poolContent: function() {
        if (this._useContent) {
          // capture lightChildren to help reify dom scoping
          saveLightChildrenIfNeeded(this);
        }
      },

      distributeContent: function() {
        // logically distribute self
        if (this._useContent) {
          if (!this.shadyRoot) {
            this.shadyRoot = this.root;
            this.root = this;
          }
          // reset distributions
          this._resetDistribution(this.shadyRoot);
          // compute which nodes should be distributed where
          // TODO(jmesserly): this is simplified because we assume a single
          // ShadowRoot per host and no `<shadow>`.
          this._distributePool(this.shadyRoot, this._collectPool());
        }
        // now fully distribute/compose "clients"
        var c$ = this._getDistributionClients();
        for (var i=0, l= c$.length, c; (i<l) && (c=c$[i]); i++) {
          c.distributeContent();
        }
        // compose self
        if (this._useContent) {
          this._composeTree(this);
        } else if (this.root !== this) {
          this.appendChild(this.root);
          this.root = this;
        }
      },

      // TODO(jmesserly): these methods will perform in O(N^2) where N is the
      // number of times they are called. That is because each call does
      // `distibuteContent` and the work it needs to do increases with each
      // subsequent call. An alternative approach would be to schedule the work,
      // and do it asynchronously, which would give us O(N) performance because
      // we'd do it once per frame in the worst case.
      /**
        Adds the given `node` to the element's `lightChildren`, optional at the
        index specified by `opt_index`. This method also performs
        dom composition.
      */
      addLightChild: function(node, opt_index) {
        saveLightChildrenIfNeeded(this);
        if (opt_index === undefined) {
          this.lightChildren.push(node);
        } else {
          this.lightChildren.splice(opt_index, 0, node);
        }
        this.distributeContent();
      },

      /**
        Removes the given `node` from the element's `lightChildren`.
        This method also performs dom composition.
      */
      removeLightChild: function(node) {
        saveLightChildrenIfNeeded(this);
        var index = this.lightChildren.indexOf(node);
        if (index < 0) {
          throw Error('The node to be removed is not a light child of this node');
        }
        this.lightChildren.splice(index, 1);
        this.distributeContent();
      },

      // This is a polyfill for Element.prototype.matches, which is sometimes
      // still prefixed. Alternatively we could just polyfill it somewhere.
      // Note that the arguments are reversed from what you might expect.
      elementMatches: function(selector, node) {
        if (node === undefined) {
          node = this;
        }
        return matchesSelector.call(node, selector);
      },

      /**
        Returns the list of childNodes in the element's local dom.
      */
      get localChildren() {
        return getLightChildren(this.shadyRoot || this);
      },

      /**
        Returns an array of elements matching the given css `selector` contained
        within the element's local dom.
      */
      querySelectorLocal: function(selector) {
        var self = this;
        return this.queryLocal(function(n) {
          return self.elementMatches(selector, n);
        });
      },

      queryLocal: function(matcher) {
        var c$ = this.localChildren;
        var list = [];
        for (var i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE) {
            this._queryLocal(c, matcher, list);
          }
        }
        return list;
      },

      _queryLocal: function(node, matcher, list) {
        if (matcher(node)) {
          list.push(node);
        }
        var c$ = getLightChildren(node);
        for (var i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE) {
            this._queryLocal(c, matcher, list);
          }
        }
      },

      // Many of the following methods are all conceptually static, but they are
      // included here as "protected" methods to allow overriding.

      _resetDistribution: function(node) {
        var children = getLightChildren(node);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (isInsertionPoint(child)) {
            child._distributedNodes = [];
          } else if (child._destinationInsertionPoints) {
            child._destinationInsertionPoints = undefined;
          }
          this._resetDistribution(child);
        }
      },

      _collectPool: function() {
        // Gather the pool of nodes that should be distributed. We will combine
        // these with the "content root" to arrive at the composed tree.
        var pool = [];
        var children = getLightChildren(this);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (isInsertionPoint(child)) {
            pool.push.apply(pool, child._distributedNodes);
          } else {
            pool.push(child);
          }
        }
        return pool;
      },

      _distributePool: function(node, pool) {
        if (isInsertionPoint(node)) {
          // distribute nodes from the pool that this selector matches
          var content = node;
          var anyDistributed = false;
          for (var i = 0; i < pool.length; i++) {
            var node = pool[i];
            // skip nodes that were already used
            if (!node) {
              continue;
            } 
            // distribute this node if it matches
            if (this._matchesContentSelect(node, content)) {
              distributeNodeInto(node, content);
              // remove this node from the pool
              pool[i] = undefined;
              // since at least one node matched, we won't need fallback content
              anyDistributed = true;
            }
          }
          // Fallback content if nothing was distributed here
          if (!anyDistributed) {
            var children = getLightChildren(content);
            for (var i = 0; i < children.length; i++) {
              distributeNodeInto(children[i], content);
            }
          }
          return;
        }
        // recursively distribute.
        var children = getLightChildren(node);
        for (var i = 0; i < children.length; i++) {
          this._distributePool(children[i], pool);
        }
      },

      _getDistributionClients: function() {
        return this._clients ? this._clients :
          this.queryLocal(function(n) {
            // TODO(sorvell): need a better test here
            return Boolean(n.distributeContent);
          });
      },

      _composeTree: function(node) {
        var children = this._composeNode(node);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          // If the child has a content root, let it compose itself.
          if (!child._useContent) {
            this._composeTree(child);
          }
        }
        this._updateChildNodes(node, children);
      },

      _composeNode: function(node) {
        var children = [];
        var c$ = getLightChildren(node.shadyRoot || node);
        for (var i = 0; i < c$.length; i++) {
          var child = c$[i];
          if (isInsertionPoint(child)) {
            var distributedNodes = child._distributedNodes;
            for (var j = 0; j < distributedNodes.length; j++) {
              var distributedNode = distributedNodes[j];
              if (isFinalDestination(child, distributedNode)) {
                children.push(distributedNode);
              }
            }
          } else {
            children.push(child);
          }
        }
        return children;
      },

      _updateChildNodes: function(node, children) {
        // Add the children that need to be added. 
        // NOTE: we do this left-to-right in order to maintain the same
        // attach order as the platform does.
        for (var i=0, l=children.length, c, b; (i<l) && (c=children[i]); i++) {
          b = children[i-1] || null;
          if (c.parentNode != node || c.previousSibling != b) {
            insertBefore(node, c, b && b.nextSibling)
          }
        }
        // We just added nodes in order, starting from an unknown point;
        // therefore delete everything before and after the expected children.
        var last = children[children.length-1];
        var lastChild = node.lastChild;
        while (lastChild && lastChild != last) {
          node.removeChild(lastChild);
          lastChild = node.lastChild;
        }
        var first = children[0];
        var firstChild = node.firstChild;
        while (firstChild && firstChild != first) {
          node.removeChild(firstChild);
          firstChild = node.firstChild;
        }
      },

      _matchesContentSelect: function(node, contentElement) {
        var select = contentElement.getAttribute('select');
        // no selector matches all nodes (including text)
        if (!select) {
          return true;
        }
        select = select.trim();
        // same thing if it had only whitespace
        if (!select) {
          return true;
        }
        // selectors can only match Elements
        if (!(node instanceof Element)) {
          return false;
        }
        // only valid selectors can match:
        //   TypeSelector
        //   *
        //   ClassSelector
        //   IDSelector
        //   AttributeSelector
        //   negation
        var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
        if (!validSelectors.test(select)) {
          return false;
        }
        // TODO(sorvell): This try..catch seems unfortunate and will nerf 
        // performance, can we remove?
        try {
          return this.elementMatches(select, node);
        } catch (ex) {
          // Invalid selector.
          return false;
        }
      }
    });

    function distributeNodeInto(child, insertionPoint) {
      insertionPoint._distributedNodes.push(child);
      var points = child._destinationInsertionPoints;
      if (!points) {
        child._destinationInsertionPoints = [insertionPoint];
      } else {
        points.push(insertionPoint);
      }
    }

    function isFinalDestination(insertionPoint, node) {
      var points = node._destinationInsertionPoints;
      return points && points[points.length - 1] === insertionPoint;
    }

    function isInsertionPoint(node) {
      // TODO(jmesserly): we could add back 'shadow' support here.
      return node.localName == 'content';
    }

    function getLightChildren(node) {
      var children = node.lightChildren;
      return children ? children : node.childNodes;
    }

    function insertBefore(parentNode, newChild, refChild) {
      // remove child from its old parent first
      remove(newChild);
      // make sure we never lose logical DOM information:
      // if the parentNode doesn't have lightChildren, save that information now.
      saveLightChildrenIfNeeded(parentNode);
      // insert it into the real DOM
      parentNode.insertBefore(newChild, refChild);
    }

    function remove(node) {
      var parentNode = node.parentNode;
      if (!parentNode) return;
      // make sure we never lose logical DOM information:
      // if the parentNode doesn't have lightChildren, save that information now.
      saveLightChildrenIfNeeded(parentNode);
      // remove it from the real DOM
      parentNode.removeChild(node);
    }

    function saveLightChildrenIfNeeded(node) {
      // Capture the list of light children. It's important to do this before we
      // start transforming the DOM into "rendered" state.
      // 
      // Children may be added to this list dynamically. It will be treated as the
      // source of truth for the light children of the element. This element's
      // actual children will be treated as the rendered state once lightChildren
      // is populated.
      if (!node.lightChildren) {
        var children = [];
        for (var child = node.firstChild; child; child = child.nextSibling) {
          children.push(child);
          child.lightParent = node;
        }
        node.lightChildren = children;
      }
    }

    var p = Element.prototype;
    var matchesSelector = p.matches || p.matchesSelector ||
        p.mozMatchesSelector || p.msMatchesSelector ||
        p.oMatchesSelector || p.webkitMatchesSelector;

  });

</script>
