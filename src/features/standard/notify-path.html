<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>

  /**
   * Changes to an object sub-field (aka "path") via a binding
   * (e.g. `<x-foo value="{{item.subfield}}"`) will notify other elements bound to
   * the same object automatically.
   *
   * When modifying a sub-field of an object imperatively
   * (e.g. `this.item.subfield = 42`), in order to have the new value propagated
   * to other elements, a special `setPath(path, value)` API is provided.
   * `setPath` sets the object field at the path specified, and then notifies the
   * binding system so that other elements bound to the same path will update.
   * 
   * Example:
   * 
   *     Polymer({
   *   
   *       name: 'x-date',
   *   
   *       published: {
   *         date: {
   *           type: Object,
   *           notify: true
   *          }
   *       },
   *   
   *       attached: function() {
   *         this.date = {};
   *         setInterval(function() {
   *           var d = new Date();
   *           // Required to notify elements bound to date of changes to sub-fields
   *           // this.date.seconds = d.getSeconds(); <-- Will not notify
   *           this.setPath('date.seconds', d.getSeconds());
   *           this.setPath('date.minutes', d.getMinutes());
   *           this.setPath('date.hours', d.getHours() % 12);
   *         }.bind(this), 1000);
   *       }
   *   
   *     });
   *
   *  Allows bindings to `date` sub-fields to update on changes:
   *
   *     <x-date date="{{date}}"></x-date>
   *
   *     Hour: <span>{{date.hours}}</span>
   *     Min:  <span>{{date.minutes}}</span>
   *     Sec:  <span>{{date.seconds}}</span>
   *
   * @class data feature: path notification
   */

using('Base', function(Base) {

  Base.addFeature({
    /**
      Notify that a path has changed. For example:

          this.item.user.name = 'Bob';
          this.notifyPath('item.user.name', this.item.user.name);

      Returns true if notification actually took place, based on
      a dirty check of whether the new value was already known
    */
    notifyPath: function(path, value, fromAbove) {
      var old = this._setData(path, value);
      // manual dirty checking for now...
      if (old !== value) {
        // Take path effects at this level for exact path matches,
        // and notify down for any bindings to a subset of this path
        this._pathEffector(path, value);
        // Send event to notify the path change upwards
        // Optimization: don't notify up if we know the notification
        // is coming from above already (avoid wasted event dispatch)
        if (!fromAbove) {
          // TODO(sorvell): should only notify if notify: true?
          this._notifyPath(path, value);
        }
        return true;
      }
    },

    /**
      Convienence method for setting a value to a path and calling
      notify path
    */
    setPath: function(path, value) {
      var parts = path.split('.');
      if (parts.length > 1) {
        var last = parts.pop();
        var prop = this;
        while (parts.length && (prop=prop[parts.shift()])) {
          if (!prop) {
            return;
          }
        }
        // TODO(kschaaf): want dirty-check here?
        // if (prop[last] !== value) {
          prop[last] = value;          
          this.notifyPath(path, value);
        // }
      } else {
        this[path] = value;
      }
    },

    getPath: function(path) {
      var parts = path.split('.');
      var last = parts.pop();
      var prop = this;
      while (parts.length && (prop=prop[parts.shift()])) {
        if (!prop) {
          return;
        }
      }
      return prop[last];
    },

    addPathBindMethod: function(path, method) {
      var fx$ = this._pathEffects || (this._pathEffects = []);
      var match = path.indexOf('.*') == (path.length-2);
      if (match) {
        path = path.slice(0, -2);
      }
      fx$.push({path: path, match: match, method: method});
    },

    // TODO(kschaaf): This machine can be optimized to memoize compiled path
    // effectors as new paths are notified for performance, since it involves
    // a fair amount of runtime lookup
    _pathEffector: function(path, value) {
      var model = modelForPath(path);
      var fx$ = this._propertyEffects[model];
      fx$.forEach(function(x) {
        if (x.kind === 'annotation') {
          var effect = x.effect;
          var n = this._nodeForBinding(effect);
          if (n) {
            if (effect.value === path) {
              n[effect.name || 'textContent'] = value;
            } else if (effect.value.indexOf(path) == 0) {
              n[effect.name || 'textContent'] = this.getPath(effect.value);
            // path == item.stuff.count
            // value == item.stuff 
            // name == zizz
            // calls effect n.notifyPath for zizz.count
            } else if ((path.indexOf(effect.value) === 0) && n.notifyPath) {
              var p = this._fixPath(effect.name , effect.value, path);
              n.notifyPath(p, value, true);
            }
          }
        }
      }, this);
      if (this._pathEffects) {
        this._pathEffects.forEach(function(x) {
          if (x.path == path || (x.match && path.indexOf(x.path) === 0)) {
            var fn = this[x.method];
            if (fn) {
              fn(value, path);
            }
          }
        }, this);
      }
    },

    _fixPath: function(property, root, path) {
      return property + path.slice(root.length);
    },

    _notifyPath: function(path, value) {
      var event = modelForPath(path) + EVENT_PATH_CHANGED;
      this.fire(event, { path: path, value: value }, null, false);
    },

    _nodeForBinding: function(info) {
      return info.id ? this.$[info.id] : this._nodes[info.index];
    },

    _isPublishedObject: function(property) {
      return this.published[property] &&
        (this.published[property].type === Object);
    }

  });

  function modelForPath(path) {
    return path.split('.').shift();
  }

  var EVENT_CHANGED = '-changed';
  var EVENT_PATH_CHANGED = '-path' + EVENT_CHANGED;

});

</script>
