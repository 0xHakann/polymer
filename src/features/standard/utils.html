<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../more/debounce.html">

<script>

using(['Base', 'Debounce'], function(Base, Debounce) {

  Base.addFeature({

    $$: function(slctr) {
      return this.root.querySelector(slctr);
    },
    
    toggleClass: function(name, bool, node) {
      node = node || this;
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    },

    toggleAttribute: function(name, bool, node) {
      (node || this)[bool ? 'setAttribute' : 'removeAttribute'](name, '');
    },

    attributeFollows: function(name, neo, old) {
      if (old) {
        old.removeAttribute(name);
      } 
      if (neo) {
        neo.setAttribute(name, '');
      }
    },

    // TODO(sjmiles): use a dictionary for options after `detail`
    fire: function(type, detail, onNode, bubbles, cancelable) {
      var node = onNode || this;
      var detail = (detail === null || detail === undefined) ? {} : detail;
      var event = new CustomEvent(type, {
        bubbles: bubbles !== undefined ? bubbles : true,
        cancelable: cancelable !== undefined ? cancelable : true,
        detail: detail
      });
      node.dispatchEvent(event);
      return event;
    },

    async: function(method) {
      var handled = false;
      var handle = function() {
        if (!handled) {
          handled = true;
          method.call(this);
        }
      }.bind(this);
      // minimize latency by racing timeout against rAF
      setTimeout(handle);
      requestAnimationFrame(handle);
    },

    queryHost: function(node) {
      return this.host || this._queryHost(this);
    },

    _queryHost: function(node) {
      return node && 
        (node.host || (node.host = this._queryHost(node.parentNode)));
    },

    transform: function(node, transform) {
      node.style.webkitTransform = transform;
      node.style.transform = transform;
    },

    translate3d: function(node, x, y, z) {
      this.transform(node, 'translate3d(' + x + ',' + y + ',' + z + ')');
    },

    importHref: function(href, onload, onerror) {
      var l = document.createElement('link');
      l.rel = 'import';
      l.href = href;
      if (onload) {
        l.onload = onload.bind(this);
      }
      if (onerror) {
        l.onerror = onerror.bind(this);
      }
      document.head.appendChild(l);
      return l;
    },

    /**
     * Debounce signals. 
     * 
     * Call `debounce` to defer a named signal, and all subsequent matching signals, 
     * until a wait time has elapsed with no new signal.
     * 
     *     debouncedClickAction: function(e) {
     *       // processClick only when it's been 100ms since the last click
     *       this.debounce('click', function() {
     *        this.processClick;
     *       }, 100);
     *     }
     *
     * @method debounce
     * @param String {String} signalName A string identifier to debounce.
     * @param Function {Function} callback A function that is called (with `this` context) when the wait time elapses.
     * @param Number {Number} wait Time in milliseconds (ms) after the last signal that must elapse before invoking `callback`
     * @type Handle
     */
    debounce: function(signalName, callback, wait) {
      var n = '___' + signalName;
      this[n] = Debounce.call(this, this[n], callback, wait);
    }

  });

});

</script>
