WORK IN PROGRESS

# Polymer 0.8 Primer

## Feature Layering

Polymer 0.8 is currently layered into 3 sets of features provided as 3 discrete HTML imports, such that an individual element developer can depend on a version of Polymer whose feature set matches their tastes/needs.  For authors who opt out of the more opinionated local DOM or data-binding features, their element's dependencies would not be payload- or runtime-burdened by these higher-level features, to the extend that a user didn't depend on other elements using those features on that page.  That said, all features are designed to have low runtime cost when unused by a given element.

Higher layers depend on lower layers, and elements requiring lower layers will actually be imbued with features of the highest-level version of Polymer used on the page (those elements would simply not use/take advantage of those features).  This provides a good tradeoff between element authors being able to avoid direct dependencies on unused features when their element is used standalone, while also allowing end users to mix-and-match elements created with different layers on the same page.

Below is a description of the current Polymer layers and included features, followed by individual feature guides.

### polymer-micro.html
Bare-minum Custom Element sugaring

| Feature | Usage 
|---------|-------
| [Custom element constructor](#element-constructor) | Polymer.Class({ … });
| [Custom element registration](#register-element) | Polymer({ name: ‘...’,  … }};
| [Bespoke constructor support](#bespoke-constructor) | constructor: function() { … }
| [Basic lifecycle callbacks](#basic-callbacks) | created, attached, detached, attributeChanged
| [Native HTML element extension](#type-extension) | extends: ‘…’
| [Publish API](#published-api) | published: { … }
| [Attribute deserialization to property](#attribute-deserialization) | published: { \<property>: \<Type> }
| [Set boolean host attributes](#host-attributes) | hostAttributes: [ … ]
| [Module registry](#module-registry) | modularize, using
| [Prototype Mixins](#prototype-mixins) | mixins: [ … ]

### polymer-mini.html
Custom Elements with Templates stamped into "local DOM"

| Feature | Usage 
|---------|-------
| Template stamping into local DOM | \<dom-module>\<template>...\</template>\</dom-module>
| Light child (re-)distribution	| \<content>
| Top-down callback after distribution| configure: function() { … }
| Bottom-up callback after configuration| ready: function() { … }

### polymer.html (standard)
Custom elements with declarative data binding, events, and property nofication

| Feature | Usage 
|---------|-------
| [Local node marshalling](#node-marshalling) | this.$.\<id>
| Event listener setup| listeners: { ‘\<node>.\<event>’: ‘function’, ... }
| Annotated event listener setup | \<element on-[event]=”function”>
| Key listener setup| keyPresses: { '\<cha]r>' | \<code>: ‘function’, … }
| Utilities | toggleClass, toggleAttribute, fire, async, …
| Property change callbacks | bind: { \<property>: ‘function’ }
| Declarative property binding | \<element prop=”{{property|path}}”
| Computed properties | compute: { \<property>: ‘function(\<property>)’ }
| Set path with notification | setPath(\<path>, \<value>)
| Attribute-based layout | layout.html (layout horizontal flex ...)

# Polymer Micro Features

<a name="element-constructor"></a>
## Custom Element Constructor

The most basic Polymer API is `Polymer.Class({...})`, which takes an object expressing the prototype of your custom element, chains it to Polymer's `Base` prototype (which provides value-add features described below), and returns a constructor that can be passed to `document.regsterElement()` to register your element with the HTML parser, and after which can be used to instantiate new instances of your element via code.

The only requirement for the prototype passed to `Polymer.Class` is that `is` property specifies the HTML tag name the element will be registered as.

Example:

```js
var MyElement = Polymer.Class({

	is: 'my-element',

	// See below for lifecycle callbacks
	created: function() {
		this.innerHTML = 'My element!';
	}
	
});

document.registerElement('my-element', MyElement);

// Equivalent:
var el1 = new MyElement();
var el2 = document.createElement('my-element');
```

`Polymer.Class` is designed to provide similar ergonomics to a speculative future where an ES6 class may be defined and provided to `document.registerElement` to achieve the same effect.

<a name="register-element"></a>
## Custom Element Registration

Because the vast majority of users will always want to register the custom element prototype generated by Polymer, Polymer provides a `Polymer({ ... })` function that wraps calling `Polymer.Class` and `document.registerElement`.

Example:

```js
MyElement = Polymer({

	is: 'my-element',

	// See below for lifecycle callbacks
	created: function() {
		this.innerHTML = 'My element!';
	}
	
});

var el1 = new MyElement();
var el2 = document.createElement('my-element');
```

<a name="bespoke-constructor"></a>
## Bespoke Constructor Support

While the standard `Polymer.Class()` and `Polymer()` functions return a basic constructor that can be used to instance the custom element, Polymer also supports providing a bespoke `constructor` function on the prototype that can, for example, accept arguments to configure the element.  In that case, the constructor should generally call `document.createElement(this.is)` to construct the element and return the element instance after constructing it.

Example:

```js
MyElement = Polymer({

	is: 'my-element',

	constructor: function(foo, bar) {
		var el = document.createElement(this.is);
		el.foo = foo;
		el.configureWithBar(bar);
		return el;
	},
	
	configureWithBar: function(bar) {
		...
	}
	
});

var el = new MyElement(42, 'octopus');
```

<a name="type-extension"></a>
## Native HTML Element Extension

Polymer 0.8 currently only supports extending native HTML elements (e.g. `input`, `button`, etc., as opposed to [extending other custom elements](#todo-inheritance)).  To extend a native HTML element, set the `extends` property to the tag name of the element to extend.


Example:

```js
MyInput = Polymer({

	is: 'my-input',

	extends: 'input',
	
	created: function() {
		this.style.border = '1px solid red';
	}
	
});

var el1 = new MyInput();
console.log(el1 instanceof HTMLInputElement); // true

var el2 = document.createElement('input', 'my-input');
console.log(el2 instanceof HTMLInputElement); // true
```

<a name="basic-callbacks"></a>
## Basic Lifecycle Callbacks

Polymer's Base prototype implements the standard Custom Element lifecycle callbacks to perform tasks necessary for Polymer's built-in features.  The hooks in turn call shorter-named lifecycle methods on your prototype.

- `created` instead of `createdCallback`
- `attached` instead of `attachedCallback`
- `detached` instead of `detachedCallback`
- `attributeChanged` instead of `attributeChangedCallback`

You can always fallback to using the low-level methods if you wish (in other words, you could simply implement `createdCallback` in your prototype).

Example:

```js
MyElement = Polymer({

	is: 'my-element',

	create: function() {
		console.log(this.localName + '#' + this.id + ' was created');
	},
	
	attached: function() {
		console.log(this.localName + '#' + this.id + ' was attached');
	},
	
	detached: function() {
		console.log(this.localName + '#' + this.id + ' was detached');
	},
	
	attributeChanged: function(name, type) {
		console.log(this.localName + '#' + this.id + ' attribute ' + name +
			' was changed to ' + this.getAttribute(name));
	}
	
});
```

`Polymer.Base` also implements `registerCallback`, which will be calle dby `Polymer()` to allow `Polymer.Base` to supply a layering system for Polymer abstractions.

See the [section on configuring elements](#configuring-elements) for a more in-depth description of the practical uses of each callback.


<a name="published-api"></a>
## Published API

Placing an object-valued `published` property on your prototype allows you define metadata regarding your Custom Element's API, which can then be accessed by an API for use by other Polymer features.

By itself, the `published` feature **doesn't do anything**. It only provides API for asking questions about these special properties (see featues below for details).

Example: 

```js
Polymer({

  is: 'x-custom',

  published: {
    user: String,
    isHappy: Boolean,
    count: {
      type: Number,
      readOnly: true,
      notify: true
    }
  },

  created: function() {
    this.innerHTML = 'Hello World, I am a <b>Custom Element!</b>';
  }

});
```

Remember that the fields assigned to `count`, such as `readOnly` and `notify` don't do anything by themselves, it requires other features to give them life.

<a name="attribute-deserialization"></a>
## Attribute Deserialization

If an attribute matches a property listed in the `published` object, the attribute value will assigned to a property of the same name on the element instance.  Attribute values (always strings) will be automatically converted to the published type when assigned to the property.  If no other `published` options are specified for a property, the type (specified using the type constructor, e.g. `Object`, `String`, etc.) can be set directly as the value of the property in the published object; otherwise it should be provided as the value to the `type` key in the `published` configuration object.

The type system includes support for Object values expressed as JSON, or Date objects expressed as any Date-parsable string representation. Boolean properties set based on the existence of the attribute: if the attribute exists at all, its value is true, regardless of its string-value (and the value is only false if the attribute does not exist).

Example:

```html
<script>

  Polymer({

    is: 'x-custom',

    published: {
      user: String,
      manager: {
      	type: Boolean,
      	notify: true
      }
    },

    created: function() {
      // render
      this.innerHTML = 'Hello World, my user is ' + (this.user || 'nobody') + '.' +
      	'This user is ' + (this.manager ? '' : 'not') + ' a manager.';
    }

  });

</script>

<x-custom user="Scott" manager></x-custom>
```

<a name="host-attributes"></a>
## Boolean Host Attributes

A list of attribute names to be applied to instances of the custom element can be provided as space-separated strings in the `hostAttributes` property.  These will simply be set on the element during creation.  This is intended for "boolean" attributes only, such as common layout attributes used by the [layout.html](layout-html) CSS; values cannot be supplied at this time.

Example: 

```html
<script>

  Polymer({

    is: 'x-custom',
    
    hostAttribute: 'layout horizontal fit'
	
  });

</script>
```

After creation:

```html
<x-custom layout horizontal fit></x-custom>
```

<a name="module-registry"></a>
## Module Registry

Polymer provides and internally uses a JavaScript "module registry" to organize code library code defined outside the context of a custom element prototype, and may be used to organize user code when convenient as well.  The registry is responsible for storing and retrieving JS modules by name.  As this facility does not provide dependency loading, it is the responsibility of the user to HTMLImport files containing any dependent modules before use.

Modules are registered using the `modulate` global function, passing a name to register and a factory function that returns the module:

`fun-support.html`

```js
<script>
modulate('FunSupport', function() {

	return {
		makeElementFun = function(el) {
			el.style.border = 'border: 20px dotted fuchsia;';
		}
	};

});
</script>
```

A list of module dependencies can be specified as the second parameter, which will be provided to the factory function:

`fun-support.html`

```js
<script>
modulate('FunSupport', ['Squid', 'Octopus'], function(squid, octopus) {

	// use squid & octopus
	return ...;

});
</script>
```

Modules are requested using the `using` global function, passing a list of dependencies:

`my-element.html`

```html
<!-- Load module dependency -->
<link rel="import" href="fun-support.html">

<script>
// Use module dependency
using(['FunSupport', ...], function(funSupport, ...) {

	MyElement = Polymer({

		is: 'my-element',

		created: function() {
			funSupport.makeElementFun(this);
		}
		
	});

});
</script>
```


<a name="prototype-mixins"></a>
## Prototype Mixins

Polymer will "mixin" objects specified in a `mixin` array into the prototype.  This can be useful for adding common code between multiple elements.

The current mixin feature in 0.8 is basic; it simply loops over properties in the provided object and adds property descriptors for those on the prototype (such that `set`/`get` accessors are copied in addition to properties and functions).  Note that there is currently no support for publishing properties or hooking lifecycle callbacks directly via mixins.  The general pattern is for the mixin to supply functions to be called by the target element as part of its usage contract (and should be documented as such).  These limitations will likely be revisited in the future.

The [module registry](#module-registry) should generally be used for registering mixins.  Mixins registered with the Polymer module registry may be referred to by String name without needing to expliitly request the module via `using`.  Otherwise, values in the `mixin` array should be an Object reference (generally retrieved via `using`).

Example: `fun-mixin.html`

```js
modulate('FunMixin', function() {

	return {
		funCreatedCallback: function() {
			this.makeElementFun();
		},
		
		makeElementFun = function() {
			this.style.border = 'border: 20px dotted fuchsia;';
		}
	};

});
```

Example: `my-element.html`

```html
<link rel="import" href="fun-mixin.html">

<script>
MyElement = Polymer({

	is: 'my-element',
	
	mixins: ['FunMixin'],

	created: function() {
		this.funCreatedCallback();
	}
	
});
</script>
```

# Polymer Mini Layer

<a name="template-stamping"></a>
## Template stamping into local DOM

<a name="light-distribution"></a>
## Light child (re-)distribution

<a name="configure-callback"></a>
## Top-down callback after distribution

<a name="ready-callback"></a>
## Bottom-up callback after configuration

# Polymer Standard Layer

<a name="node-marshalling"></a>
## Local node marshalling



<a name="event-listeners"></a>
## Event listener setup

<a name="annotated-listeners"></a>
## Annotated event listener setup

<a name="key-listeners"></a>
## Key listener setup

<a name="utility-functions"></a>
## Utility Functions

<a name="change-callbacks"></a>
## Property change callbacks

<a name="property-binding"></a>
## Declarative property binding

<a name="computed-properties"></a>
## Computed properties

<a name="set-path"></a>
## Set path with notification

<a name="layout-html"></a>
## Attribute-based layout


# Migration Notes

### Styling

### Self / Child Configuration

### Compound property effects

### Path notification

### Array notification

### Local / light tree API

<a name="todo-inheritance"></a>
### Mixins / Inheritance

