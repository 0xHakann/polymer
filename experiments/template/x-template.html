<style>

  x-template-proxy {
    display: none;
  }

</style>
<script>

  Polymer({
    name: 'x-template-proxy'
  });
</script>

<script>

// TODO(sorvell): we're using a proxy element to get Polymer api just until
// there's support for extending <template>.

/*
  Provides basic template stamping support. Stamps with bound mustaches and
  events when the template's `model` is set.

  NOTE: ntested templates are not currently supported at all. Instead, a `ref`
  system is provided when `x-template` needs to be in another template.

  See https://code.google.com/p/chromium/issues/detail?id=430578.

*/

(function() {
  var proto = Object.create(HTMLTemplateElement.prototype);
  var proxy;

  var refMap = {};

  extend(proto, {

    createdCallback: function() {
      if (this.id) {
        refMap[this.id] = this;
      }
      // make static proxy iff needed.
      if (!proxy) {
        proxy = document.createElement('x-template-proxy');
      }
      this.proxy = proxy;
      // collect annotations for use in binding.
      proxy.parseAnnotations(this);
      this.attributeChangedCallback('ref');
    },

    attributeChangedCallback: function(name) {
      if (name === 'ref') {
        this.ref = this.getAttribute('ref');
        if (this.model) {
          this.stamp();
        }
      }
    },

    get refTemplate() {
      return this.ref ? refMap[this.ref] : this;
    },

    set model(model) {
      this._model = model;
      this.stamp();
      // TODO(sorvell): IJFM!! simple mode.
      // Object.observe(model, this.stamp.bind(this));
    },

    get model() {
      return this._model;
    },

    stamp: function() {
      this.clear();
      var ref = this.refTemplate;
      var content = ref.content;
      // create the dom!
      var dom = document.importNode(content, true);
      this.applyBindings(dom, ref.map);
      // track number of stamped nodes so we can easily remove the stamping.
      this._stampedCount = dom.childNodes.length;
      // add to parent next to us.
      this.parentNode.insertBefore(dom, this.nextElementSibling);
    },

    // TODO(sorvell): note: any user modification of stamped dom will mess this up.
    clear: function() {
      while (this._stampedCount--) {
        this.nextSibling.remove();
      }
    },

    applyBindings: function(dom, bindingMap) {
      bindingMap.forEach(function(a) {
        var node = this.proxy.findAnnotatedNode(dom, a);
        this.bindNode(node, a);
      }, this);
    },

    bindNode: function(node, binding) {
      binding.bindings.forEach(function(b) {
        var name = b.name;
        var value = this.model[b.value];
        switch (b.kind) {
          case 'text':
            node.textContent = value || '';
            break;
          case 'attribute':
            // two-way!
            node[name] = value;
            node.addEventListener(name + '-changed', 
              this.incomingDataHandler.bind(this, name));
            break;
        }
      }, this);
      //
      if (binding.events) {
        binding.events.forEach(function(b) {
          var name = b.name;
          var value = this.model[b.value];
          if (typeof value === 'function') {
            node.addEventListener(name, value.bind(this.model));
          }
        }, this);
      }
    },

    incomingDataHandler: function(name, e) {
      this.model[name] = e.target[name];
      this.stamp();
    }

  });

  document.registerElement('x-template', {prototype: proto, extends: 'template'});

})();
</script>

