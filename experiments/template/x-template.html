<link rel="import" href="x-template-proxy.html">

<script>

/*
  Provides basic template stamping support.

  When `model` is set, the template stamps below itself in dom. If a previous
  stamping exists, it is removed first. Neoprene style bindings are created 
  for stamped elements. (NOTE: Binding paths is suppported.)

  If `model` is an Array, then the template is iterated
  for each member of the Array.

  When any bound property notifies, a `modelchanged` event is fired on the
  template.

*/

(function() {
  var proto = Object.create(HTMLTemplateElement.prototype);
  
  extend(proto, {

    createdCallback: function() {
      if (this.id && !this.getAttribute('ref')) {
        XTemplate.refMap[this.id] = this;
      }
      this.proxy = XTemplate.getProxy();
      // collect annotations for use in binding.
      this.proxy.parseAnnotations(this);
      this.attributeChangedCallback('ref');
    },

    attributeChangedCallback: function(name) {
      if (name === 'ref') {
        this.ref = this.getAttribute('ref');
        this.update();
      }
    },

    get refTemplate() {
      return this.ref ? XTemplate.refMap[this.ref] : this;
    },

    set model(model) {
      this._model = model;
      this.stamp();
      // TODO(sorvell): IJFM!! simple mode.
      // Object.observe(model, this.stamp.bind(this));
    },

    get model() {
      return this._model;
    },

    /**
     * Update template stamping, this will update the template if a model
     * exists. When the optional `model` argument is set and the model is 
     * an Array, only the template iteration corresponding to `model` will
     * be updated.
     *
     * NOTE: this method should simply update bound properties on an existing
     * stamping, but it currently restamps the template.
     *
     * TODO(sorvell): implement in place update; requires better integration
     * with node annotations.
    */
    update: function(model) {
      if (this.model) {
        var i = Array.isArray(this.model) ? this.model.indexOf(model) : -1;
        if (i >= 0) {
          this.updateInstance(i);
        } else {
          this.stamp();
        }
      }
    },

    stamp: function() {
      this.clear();
      this._controller = this.controller || this.model;
      this._refMap = this.refTemplate.map;
      this._refContent = this.refTemplate.content;
      this.contentLength = this._refContent.childNodes.length;
      var refNode = this.nextElementSibling;
      if (Array.isArray(this.model)) {
        for (var i=0, l=this.model.length, m; (i<l) && (m=this.model[i]); i++) {
          this.stampInstance(m, refNode);
        }
      } else {
        this.stampInstance(this.model, refNode);
      }
    },

    stampInstance: function(model, refNode) {
      // create the dom!
      var dom = document.importNode(this._refContent, true);
      this.applyBindings(dom, model);
      // track number of stamped nodes so we can easily remove the stamping.
      var count = dom.childNodes.length;
      this._stampedCount += count;
      // add to parent next to us.
      this.parentNode.insertBefore(dom, refNode);
    },

    // TODO(sorvell): this should actually update the template instance in 
    // place, but this requires some additional annotation information to find
    // the nodes to update.
    updateInstance: function(index) {
      // clear instance
      var n = this.nodeAtIndex(this.contentLength * index-1);
      for (var i =0; i < this.contentLength; i++) {
        n.nextSibling.remove();
      }
      var model = this.model[index];
      // stamp
      this.stampInstance(model, n.nextSibling);
    },

    // TODO(sorvell): note: any user modification of stamped dom will mess this up.
    clear: function() {
      while (this._stampedCount--) {
        this.nextSibling.remove();
      }
      this._stampedCount = 0;
    },

    applyBindings: function(dom, model) {
      this._refMap.forEach(function(a) {
        var node = this.proxy.findAnnotatedNode(dom, a);
        this.bindNode(node, model, a);
      }, this);
    },

    bindNode: function(node, model, binding) {
      node.templateModel = model;
      binding.bindings.forEach(function(b) {
        var name = b.name;
        var value = getPath(model, b.value);
        switch (b.kind) {
          case 'text':
            node.textContent = value || '';
            break;
          case 'attribute':
            // two-way!
            // TODO(sorvell): if we listen first, we get a notification
            // on setting. Sometimes this is good and sometimes it's iloop.
            node[name] = value;
            node.addEventListener(name + '-changed', 
              this.incomingDataHandler.bind(this, b, model));
            break;
        }
      }, this);
      if (binding.events) {
        binding.events.forEach(function(b) {
          var name = b.name;
          var value = this._controller[b.value];
          if (typeof value === 'function') {
            node.addEventListener(name, value.bind(this._controller));
          }
        }, this);
      }
    },


    /**
     * Two way binding change handler; when a bound property notifies 
     * the bound `model` property is set.
     * 
     * In addition a `modelchanged` event is fired on the template element.
     * This event contains detail information about the model, path, and value
     * that are changing.
    */
    incomingDataHandler: function(binding, model, e) {
      setPath(model, binding.value, e.detail);
      this.proxy.fire('modelchanged', {
        model: model,
        path: binding.value,
        value: e.detail
      }, this);
    },

    /** 
     * Returns the model for a node that was produced via template stamping.
     * Useful for determining which iteration of a model Array a given
     * node to which a node corresponds.
     */
    // note: model is memoized on node.
    getNodeModel: function(node) {
      if (node.templateModel) {
        return node.templateModel;
      }
      var model;
      if (Array.isArray(this.model)) {
        while (node.parentNode != this.parentNode) {
          node = node.parentNode;
        }
        var o = this.nodeOffset(node) - this.nodeOffset(this) - 1;
        var i = Math.floor(o / this.contentLength);
        model = this.model[i];
      } else {
        model = this.model;
      }
      return (node.templateModel = model);
    },

    nodeOffset: function(node) {
      var nodes = this.parentNode.childNodes;
      return Array.prototype.indexOf.call(nodes, node);
    },

    nodeAtIndex: function(index) {
      var i = index + this.nodeOffset(this) + 1;
      return this.parentNode.childNodes[i];
    }

  });

  // TODO(sorvell): these path getter/setters are slow.
  getPath = function(obj, path) {
    var parts = path.split('.');
    var v = obj;
    while (parts.length) {
      v = v[parts.shift()];
    }
    return v;
  };

  setPath = function(obj, path, value) {
    var parts = path.split('.');
    var prop = parts.pop();
    var o = parts.length ? getPath(obj, parts.join('.')) : obj;
    if (o) {
      o[prop] = value;
    }
  };

  document.registerElement('x-template', {prototype: proto, extends: 'template'});

})();
</script>

